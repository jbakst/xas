//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g 2011-11-12 22:43:03

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class AS3Parser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACCESSOR_ROLE", "ADDITIVE_EXP", "ANNOTATION", "ANNOTATIONS", "ANNOTATION_PARAMS", "ARGUMENT", "ARGUMENTS", "ARRAY_ACC", "ARRAY_ACCESS", "ARRAY_LITERAL", "ARRAY_SUBSCRIPT", "AS", "ASSIGN", "ASSIGNMENT_EXPR", "BAND", "BAND_ASSIGN", "BLOCK", "BNOT", "BOM", "BOR", "BOR_ASSIGN", "BREAK", "BREAK_STATEMENT", "BSLASH", "BSR", "BSR_ASSIGN", "BXOR", "BXOR_ASSIGN", "CASE", "CASE_DEFAULT", "CLASS", "CLASS_DEF", "CLASS_MEMBER", "CLASS_NAME", "COLON", "COMMA", "COMPILATION_UNIT", "CONDITION", "CONST", "CONSTANT", "CONTINUE", "CONTINUE_STATEMENT", "CTRLCHAR_ESC", "DBL_COLON", "DEC", "DECIMAL_LITERAL", "DECLARATION", "DECL_STMT", "DEFAULT", "DEFAULT_XML_NAMESPACE", "DIV", "DIV_ASSIGN", "DO", "DOT", "DO_WHILE", "DO_WHILE_LOOP", "DYNAMIC", "E4X_ATTRI", "E4X_DESC", "E4X_EXPRESSION", "EACH", "ELEMENT", "ELIST", "ELSE", "ELSE_CLAUSE", "ENCPS_EXPR", "EQUAL", "ESC", "EXPONENT", "EXPR", "EXPRESSION", "EXPR_LIST", "EXPR_STMNT", "EXTENDS", "EXTENDS_CLAUSE", "FALSE", "FLOAT_LITERAL", "FOR", "FOR_CLAUSE", "FOR_CONDITION", "FOR_EACH_LOOP", "FOR_INIT", "FOR_IN_CLAUSE", "FOR_IN_LOOP", "FOR_ITERATOR", "FOR_LOOP", "FUNCTION", "FUNCTION_CALL", "FUNC_DEF", "GE", "GET", "GT", "HEX_DIGIT", "HEX_LITERAL", "IDENT", "IDENTIFIER", "IDENTIFIER_STAR", "IF", "IF_STMT", "IMPLEMENTS", "IMPLEMENTS_CLAUSE", "IMPORT", "IMPORT_DEF", "IN", "INC", "INCLUDE_DIRECTIVE", "INTERFACE", "INTERFACE_DEF", "INTERNAL", "IS", "LAND", "LAND_ASSIGN", "LBRACK", "LCURLY", "LE", "LITERAL_DOUBLE_STRING", "LITERAL_NUMBER", "LITERAL_REGEX", "LITERAL_SINGLE_STRING", "LITERAL_STRING", "LITERAL_XML", "LNOT", "LOR", "LOR_ASSIGN", "LPAREN", "LT", "METADATA", "METADATA_ITEM", "METHOD", "METHOD_BLOCK", "METHOD_DEF", "METHOD_NAME", "MINUS", "MINUS_ASSIGN", "ML_COMMENT", "MOD", "MODIFIERS", "MODIFIER_LIST", "MOD_ASSIGN", "NAME", "NAMESPACE", "NAMESPACE_DEF", "NAMESPACE_USAGE", "NEW", "NEW_EXPR", "NEW_EXPRESSION", "NL", "NOT_EQUAL", "NULL", "OBJECT_FIELD", "OBJECT_LITERAL", "OCTAL_ESC", "OCTAL_LITERAL", "OCT_DIGIT", "PACKAGE", "PACKAGE_DECL", "PARAM", "PARAMS", "PARAM_DECL", "PARAM_LIST", "PARAM_REST_DECL", "PLUS", "PLUS_ASSIGN", "POST_DEC", "POST_INC", "PRE_DEC", "PRE_INC", "PRIMARY_EXPRESSION", "PRIVATE", "PROP_ACCESS", "PROP_OR_IDENT", "PROTECTED", "PUBLIC", "QUALIFIED_NAME", "QUESTION", "RBRACK", "RCURLY", "REGEX", "REGEX_BODY", "REGEX_LITERAL", "REGEX_POSTFIX", "REST", "RETURN", "RETURN_STATEMENT", "RPAREN", "SEMI", "SET", "SL", "SL_ASSIGN", "SL_COMMENT", "SR", "SR_ASSIGN", "STAR", "STAR_ASSIGN", "STATEMENT", "STATEMENT_BLOCK", "STATIC", "STRICT_EQUAL", "STRICT_NOT_EQUAL", "STRING_LITERAL_DOUBLE", "STRING_LITERAL_SINGLE", "SUPER", "SWITCH", "SWITCH_BLOCK", "SWITCH_STATEMENT", "SWITCH_STATEMENT_LIST", "THROW", "THROW_STATEMENT", "TRUE", "TRY_STATEMENT", "TYPE_BLOCK", "TYPE_SPEC", "UNARY_MINUS", "UNARY_PLUS", "UNICODE_ESC", "USE", "VAR", "VARIABLE_DECLARATOR", "VARIABLE_DEF", "VAR_DEC", "VAR_DECLARATION", "VAR_INIT", "VAR_INITIALIZER", "WHILE", "WHILE_LOOP", "WITH", "WS", "XML", "XML_AS3_EXPRESSION", "XML_ATTRIBUTE", "XML_BINDING", "XML_CDATA", "XML_COMMENT", "XML_LITERAL", "XML_SUBTREE", "XML_TEXTNODE", "XML_WS", "'and'", "'catch'", "'delete'", "'enumerable'", "'explicit'", "'final'", "'finally'", "'include'", "'instanceof'", "'intrinsic'", "'or'", "'override'", "'throw'", "'try'", "'typeof'", "'undefined'", "'void'"
	};
	public const int EOF=-1;
	public const int T__241=241;
	public const int T__242=242;
	public const int T__243=243;
	public const int T__244=244;
	public const int T__245=245;
	public const int T__246=246;
	public const int T__247=247;
	public const int T__248=248;
	public const int T__249=249;
	public const int T__250=250;
	public const int T__251=251;
	public const int T__252=252;
	public const int T__253=253;
	public const int T__254=254;
	public const int T__255=255;
	public const int T__256=256;
	public const int T__257=257;
	public const int ACCESSOR_ROLE=4;
	public const int ADDITIVE_EXP=5;
	public const int ANNOTATION=6;
	public const int ANNOTATIONS=7;
	public const int ANNOTATION_PARAMS=8;
	public const int ARGUMENT=9;
	public const int ARGUMENTS=10;
	public const int ARRAY_ACC=11;
	public const int ARRAY_ACCESS=12;
	public const int ARRAY_LITERAL=13;
	public const int ARRAY_SUBSCRIPT=14;
	public const int AS=15;
	public const int ASSIGN=16;
	public const int ASSIGNMENT_EXPR=17;
	public const int BAND=18;
	public const int BAND_ASSIGN=19;
	public const int BLOCK=20;
	public const int BNOT=21;
	public const int BOM=22;
	public const int BOR=23;
	public const int BOR_ASSIGN=24;
	public const int BREAK=25;
	public const int BREAK_STATEMENT=26;
	public const int BSLASH=27;
	public const int BSR=28;
	public const int BSR_ASSIGN=29;
	public const int BXOR=30;
	public const int BXOR_ASSIGN=31;
	public const int CASE=32;
	public const int CASE_DEFAULT=33;
	public const int CLASS=34;
	public const int CLASS_DEF=35;
	public const int CLASS_MEMBER=36;
	public const int CLASS_NAME=37;
	public const int COLON=38;
	public const int COMMA=39;
	public const int COMPILATION_UNIT=40;
	public const int CONDITION=41;
	public const int CONST=42;
	public const int CONSTANT=43;
	public const int CONTINUE=44;
	public const int CONTINUE_STATEMENT=45;
	public const int CTRLCHAR_ESC=46;
	public const int DBL_COLON=47;
	public const int DEC=48;
	public const int DECIMAL_LITERAL=49;
	public const int DECLARATION=50;
	public const int DECL_STMT=51;
	public const int DEFAULT=52;
	public const int DEFAULT_XML_NAMESPACE=53;
	public const int DIV=54;
	public const int DIV_ASSIGN=55;
	public const int DO=56;
	public const int DOT=57;
	public const int DO_WHILE=58;
	public const int DO_WHILE_LOOP=59;
	public const int DYNAMIC=60;
	public const int E4X_ATTRI=61;
	public const int E4X_DESC=62;
	public const int E4X_EXPRESSION=63;
	public const int EACH=64;
	public const int ELEMENT=65;
	public const int ELIST=66;
	public const int ELSE=67;
	public const int ELSE_CLAUSE=68;
	public const int ENCPS_EXPR=69;
	public const int EQUAL=70;
	public const int ESC=71;
	public const int EXPONENT=72;
	public const int EXPR=73;
	public const int EXPRESSION=74;
	public const int EXPR_LIST=75;
	public const int EXPR_STMNT=76;
	public const int EXTENDS=77;
	public const int EXTENDS_CLAUSE=78;
	public const int FALSE=79;
	public const int FLOAT_LITERAL=80;
	public const int FOR=81;
	public const int FOR_CLAUSE=82;
	public const int FOR_CONDITION=83;
	public const int FOR_EACH_LOOP=84;
	public const int FOR_INIT=85;
	public const int FOR_IN_CLAUSE=86;
	public const int FOR_IN_LOOP=87;
	public const int FOR_ITERATOR=88;
	public const int FOR_LOOP=89;
	public const int FUNCTION=90;
	public const int FUNCTION_CALL=91;
	public const int FUNC_DEF=92;
	public const int GE=93;
	public const int GET=94;
	public const int GT=95;
	public const int HEX_DIGIT=96;
	public const int HEX_LITERAL=97;
	public const int IDENT=98;
	public const int IDENTIFIER=99;
	public const int IDENTIFIER_STAR=100;
	public const int IF=101;
	public const int IF_STMT=102;
	public const int IMPLEMENTS=103;
	public const int IMPLEMENTS_CLAUSE=104;
	public const int IMPORT=105;
	public const int IMPORT_DEF=106;
	public const int IN=107;
	public const int INC=108;
	public const int INCLUDE_DIRECTIVE=109;
	public const int INTERFACE=110;
	public const int INTERFACE_DEF=111;
	public const int INTERNAL=112;
	public const int IS=113;
	public const int LAND=114;
	public const int LAND_ASSIGN=115;
	public const int LBRACK=116;
	public const int LCURLY=117;
	public const int LE=118;
	public const int LITERAL_DOUBLE_STRING=119;
	public const int LITERAL_NUMBER=120;
	public const int LITERAL_REGEX=121;
	public const int LITERAL_SINGLE_STRING=122;
	public const int LITERAL_STRING=123;
	public const int LITERAL_XML=124;
	public const int LNOT=125;
	public const int LOR=126;
	public const int LOR_ASSIGN=127;
	public const int LPAREN=128;
	public const int LT=129;
	public const int METADATA=130;
	public const int METADATA_ITEM=131;
	public const int METHOD=132;
	public const int METHOD_BLOCK=133;
	public const int METHOD_DEF=134;
	public const int METHOD_NAME=135;
	public const int MINUS=136;
	public const int MINUS_ASSIGN=137;
	public const int ML_COMMENT=138;
	public const int MOD=139;
	public const int MODIFIERS=140;
	public const int MODIFIER_LIST=141;
	public const int MOD_ASSIGN=142;
	public const int NAME=143;
	public const int NAMESPACE=144;
	public const int NAMESPACE_DEF=145;
	public const int NAMESPACE_USAGE=146;
	public const int NEW=147;
	public const int NEW_EXPR=148;
	public const int NEW_EXPRESSION=149;
	public const int NL=150;
	public const int NOT_EQUAL=151;
	public const int NULL=152;
	public const int OBJECT_FIELD=153;
	public const int OBJECT_LITERAL=154;
	public const int OCTAL_ESC=155;
	public const int OCTAL_LITERAL=156;
	public const int OCT_DIGIT=157;
	public const int PACKAGE=158;
	public const int PACKAGE_DECL=159;
	public const int PARAM=160;
	public const int PARAMS=161;
	public const int PARAM_DECL=162;
	public const int PARAM_LIST=163;
	public const int PARAM_REST_DECL=164;
	public const int PLUS=165;
	public const int PLUS_ASSIGN=166;
	public const int POST_DEC=167;
	public const int POST_INC=168;
	public const int PRE_DEC=169;
	public const int PRE_INC=170;
	public const int PRIMARY_EXPRESSION=171;
	public const int PRIVATE=172;
	public const int PROP_ACCESS=173;
	public const int PROP_OR_IDENT=174;
	public const int PROTECTED=175;
	public const int PUBLIC=176;
	public const int QUALIFIED_NAME=177;
	public const int QUESTION=178;
	public const int RBRACK=179;
	public const int RCURLY=180;
	public const int REGEX=181;
	public const int REGEX_BODY=182;
	public const int REGEX_LITERAL=183;
	public const int REGEX_POSTFIX=184;
	public const int REST=185;
	public const int RETURN=186;
	public const int RETURN_STATEMENT=187;
	public const int RPAREN=188;
	public const int SEMI=189;
	public const int SET=190;
	public const int SL=191;
	public const int SL_ASSIGN=192;
	public const int SL_COMMENT=193;
	public const int SR=194;
	public const int SR_ASSIGN=195;
	public const int STAR=196;
	public const int STAR_ASSIGN=197;
	public const int STATEMENT=198;
	public const int STATEMENT_BLOCK=199;
	public const int STATIC=200;
	public const int STRICT_EQUAL=201;
	public const int STRICT_NOT_EQUAL=202;
	public const int STRING_LITERAL_DOUBLE=203;
	public const int STRING_LITERAL_SINGLE=204;
	public const int SUPER=205;
	public const int SWITCH=206;
	public const int SWITCH_BLOCK=207;
	public const int SWITCH_STATEMENT=208;
	public const int SWITCH_STATEMENT_LIST=209;
	public const int THROW=210;
	public const int THROW_STATEMENT=211;
	public const int TRUE=212;
	public const int TRY_STATEMENT=213;
	public const int TYPE_BLOCK=214;
	public const int TYPE_SPEC=215;
	public const int UNARY_MINUS=216;
	public const int UNARY_PLUS=217;
	public const int UNICODE_ESC=218;
	public const int USE=219;
	public const int VAR=220;
	public const int VARIABLE_DECLARATOR=221;
	public const int VARIABLE_DEF=222;
	public const int VAR_DEC=223;
	public const int VAR_DECLARATION=224;
	public const int VAR_INIT=225;
	public const int VAR_INITIALIZER=226;
	public const int WHILE=227;
	public const int WHILE_LOOP=228;
	public const int WITH=229;
	public const int WS=230;
	public const int XML=231;
	public const int XML_AS3_EXPRESSION=232;
	public const int XML_ATTRIBUTE=233;
	public const int XML_BINDING=234;
	public const int XML_CDATA=235;
	public const int XML_COMMENT=236;
	public const int XML_LITERAL=237;
	public const int XML_SUBTREE=238;
	public const int XML_TEXTNODE=239;
	public const int XML_WS=240;

	public AS3Parser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public AS3Parser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return AS3Parser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g"; } }


	            private AS3Lexer lexer;
	            private CharStream cs;
	            
	            public void setInput(AS3Lexer lexer, CharStream cs) {
	                this.lexer = lexer;
	                this.cs = cs;
	            }

	            // Used in tree rewrite rules to insert semicolon tree IF it exists..
	            private FlyparseTree maybeSemi(ParserRuleReturnScope semi){
	                return (semi.start.getType() == SEMI ? (FlyparseTree)semi.getTree() : null);
	            }



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_compilationUnit();
	partial void LeaveRule_compilationUnit();

	// $ANTLR start "compilationUnit"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:109:1: compilationUnit : ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) ;
	[GrammarRule("compilationUnit")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> compilationUnit()
	{
		EnterRule_compilationUnit();
		EnterRule("compilationUnit", 1);
		TraceIn("compilationUnit", 1);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> as2CompilationUnit1 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> as3CompilationUnit2 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_as3CompilationUnit=new RewriteRuleSubtreeStream(adaptor,"rule as3CompilationUnit");
		RewriteRuleSubtreeStream stream_as2CompilationUnit=new RewriteRuleSubtreeStream(adaptor,"rule as2CompilationUnit");
		try { DebugEnterRule(GrammarFileName, "compilationUnit");
		DebugLocation(109, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:110:2: ( ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:110:4: ( as2CompilationUnit | as3CompilationUnit )
			{
			DebugLocation(110, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:110:4: ( as2CompilationUnit | as3CompilationUnit )
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==CLASS||LA1_0==DYNAMIC||LA1_0==IDENT||LA1_0==IMPORT||(LA1_0>=INCLUDE_DIRECTIVE && LA1_0<=INTERFACE)||LA1_0==INTERNAL||LA1_0==PRIVATE||(LA1_0>=PROTECTED && LA1_0<=PUBLIC)||LA1_0==STATIC||(LA1_0>=244 && LA1_0<=246)||LA1_0==250||LA1_0==252))
			{
				alt1 = 1;
			}
			else if ((LA1_0==PACKAGE))
			{
				alt1 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:110:6: as2CompilationUnit
				{
				DebugLocation(110, 6);
				PushFollow(Follow._as2CompilationUnit_in_compilationUnit465);
				as2CompilationUnit1=as2CompilationUnit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:111:5: as3CompilationUnit
				{
				DebugLocation(111, 5);
				PushFollow(Follow._as3CompilationUnit_in_compilationUnit471);
				as3CompilationUnit2=as3CompilationUnit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: as3CompilationUnit, as2CompilationUnit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 112:5: -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
			{
				DebugLocation(112, 8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:112:8: ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(112, 10);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);

				DebugLocation(112, 27);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:112:27: ( as2CompilationUnit )?
				if (stream_as2CompilationUnit.HasNext)
				{
					DebugLocation(112, 27);
					adaptor.AddChild(root_1, stream_as2CompilationUnit.NextTree());

				}
				stream_as2CompilationUnit.Reset();
				DebugLocation(112, 47);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:112:47: ( as3CompilationUnit )?
				if (stream_as3CompilationUnit.HasNext)
				{
					DebugLocation(112, 47);
					adaptor.AddChild(root_1, stream_as3CompilationUnit.NextTree());

				}
				stream_as3CompilationUnit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compilationUnit", 1);
			LeaveRule("compilationUnit", 1);
			LeaveRule_compilationUnit();
		}
		DebugLocation(113, 1);
		} finally { DebugExitRule(GrammarFileName, "compilationUnit"); }
		return retval;

	}
	// $ANTLR end "compilationUnit"

	partial void EnterRule_as2CompilationUnit();
	partial void LeaveRule_as2CompilationUnit();

	// $ANTLR start "as2CompilationUnit"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:115:1: as2CompilationUnit : ( importDefinition )* as2Type ;
	[GrammarRule("as2CompilationUnit")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as2CompilationUnit()
	{
		EnterRule_as2CompilationUnit();
		EnterRule("as2CompilationUnit", 2);
		TraceIn("as2CompilationUnit", 2);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> importDefinition3 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> as2Type4 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "as2CompilationUnit");
		DebugLocation(115, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:116:2: ( ( importDefinition )* as2Type )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:116:4: ( importDefinition )* as2Type
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(116, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:116:4: ( importDefinition )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==IMPORT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:116:4: importDefinition
					{
					DebugLocation(116, 4);
					PushFollow(Follow._importDefinition_in_as2CompilationUnit498);
					importDefinition3=importDefinition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition3.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(117, 3);
			PushFollow(Follow._as2Type_in_as2CompilationUnit503);
			as2Type4=as2Type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, as2Type4.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2CompilationUnit", 2);
			LeaveRule("as2CompilationUnit", 2);
			LeaveRule_as2CompilationUnit();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "as2CompilationUnit"); }
		return retval;

	}
	// $ANTLR end "as2CompilationUnit"

	partial void EnterRule_as2Type();
	partial void LeaveRule_as2Type();

	// $ANTLR start "as2Type"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:120:1: as2Type : ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition ) ;
	[GrammarRule("as2Type")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as2Type()
	{
		EnterRule_as2Type();
		EnterRule("as2Type", 3);
		TraceIn("as2Type", 3);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> as2IncludeDirective5 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> as2ClassDefinition6 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> as2InterfaceDefinition7 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "as2Type");
		DebugLocation(120, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:121:2: ( ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:122:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(122, 2);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:122:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )
			int alt3=3;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:122:4: as2IncludeDirective
				{
				DebugLocation(122, 4);
				PushFollow(Follow._as2IncludeDirective_in_as2Type518);
				as2IncludeDirective5=as2IncludeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2IncludeDirective5.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:123:4: ( modifiers CLASS )=> as2ClassDefinition
				{
				DebugLocation(123, 25);
				PushFollow(Follow._as2ClassDefinition_in_as2Type531);
				as2ClassDefinition6=as2ClassDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2ClassDefinition6.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:124:4: ( modifiers INTERFACE )=> as2InterfaceDefinition
				{
				DebugLocation(124, 29);
				PushFollow(Follow._as2InterfaceDefinition_in_as2Type544);
				as2InterfaceDefinition7=as2InterfaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2InterfaceDefinition7.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2Type", 3);
			LeaveRule("as2Type", 3);
			LeaveRule_as2Type();
		}
		DebugLocation(126, 1);
		} finally { DebugExitRule(GrammarFileName, "as2Type"); }
		return retval;

	}
	// $ANTLR end "as2Type"

	partial void EnterRule_as3CompilationUnit();
	partial void LeaveRule_as3CompilationUnit();

	// $ANTLR start "as3CompilationUnit"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:128:1: as3CompilationUnit : packageDecl ( packageBlockEntry )* EOF !;
	[GrammarRule("as3CompilationUnit")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as3CompilationUnit()
	{
		EnterRule_as3CompilationUnit();
		EnterRule("as3CompilationUnit", 4);
		TraceIn("as3CompilationUnit", 4);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken EOF10 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> packageDecl8 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> packageBlockEntry9 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree EOF10_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "as3CompilationUnit");
		DebugLocation(128, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:129:2: ( packageDecl ( packageBlockEntry )* EOF !)
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:129:4: packageDecl ( packageBlockEntry )* EOF !
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(129, 4);
			PushFollow(Follow._packageDecl_in_as3CompilationUnit558);
			packageDecl8=packageDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, packageDecl8.Tree);
			DebugLocation(130, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:130:3: ( packageBlockEntry )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==AS||LA4_0==BNOT||LA4_0==BREAK||LA4_0==CLASS||LA4_0==CONST||LA4_0==CONTINUE||(LA4_0>=DEC && LA4_0<=DECIMAL_LITERAL)||LA4_0==DEFAULT||LA4_0==DO||(LA4_0>=DYNAMIC && LA4_0<=E4X_ATTRI)||(LA4_0>=FALSE && LA4_0<=FOR)||LA4_0==FUNCTION||LA4_0==GET||(LA4_0>=HEX_LITERAL && LA4_0<=IDENT)||LA4_0==IF||LA4_0==IMPORT||LA4_0==INC||LA4_0==INTERFACE||(LA4_0>=INTERNAL && LA4_0<=IS)||(LA4_0>=LBRACK && LA4_0<=LCURLY)||LA4_0==LNOT||LA4_0==LPAREN||LA4_0==MINUS||LA4_0==NAMESPACE||LA4_0==NEW||LA4_0==NULL||LA4_0==OCTAL_LITERAL||LA4_0==PLUS||LA4_0==PRIVATE||(LA4_0>=PROTECTED && LA4_0<=PUBLIC)||LA4_0==REGEX_LITERAL||LA4_0==RETURN||(LA4_0>=SEMI && LA4_0<=SET)||LA4_0==STATIC||(LA4_0>=STRING_LITERAL_DOUBLE && LA4_0<=SWITCH)||LA4_0==TRUE||(LA4_0>=USE && LA4_0<=VAR)||LA4_0==WHILE||LA4_0==WITH||LA4_0==XML||LA4_0==XML_LITERAL||(LA4_0>=243 && LA4_0<=246)||LA4_0==248||LA4_0==250||(LA4_0>=252 && LA4_0<=257)))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:130:3: packageBlockEntry
					{
					DebugLocation(130, 3);
					PushFollow(Follow._packageBlockEntry_in_as3CompilationUnit562);
					packageBlockEntry9=packageBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, packageBlockEntry9.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(131, 6);
			EOF10=(IToken)Match(input,EOF,Follow._EOF_in_as3CompilationUnit567); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as3CompilationUnit", 4);
			LeaveRule("as3CompilationUnit", 4);
			LeaveRule_as3CompilationUnit();
		}
		DebugLocation(132, 1);
		} finally { DebugExitRule(GrammarFileName, "as3CompilationUnit"); }
		return retval;

	}
	// $ANTLR end "as3CompilationUnit"

	partial void EnterRule_packageDecl();
	partial void LeaveRule_packageDecl();

	// $ANTLR start "packageDecl"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:134:1: packageDecl : PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY ) ;
	[GrammarRule("packageDecl")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> packageDecl()
	{
		EnterRule_packageDecl();
		EnterRule("packageDecl", 5);
		TraceIn("packageDecl", 5);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken PACKAGE11 = default(IToken);
		IToken LCURLY13 = default(IToken);
		IToken RCURLY15 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifierStar12 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> packageBlockEntry14 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree PACKAGE11_tree = default(FlyparseTree);
		FlyparseTree LCURLY13_tree = default(FlyparseTree);
		FlyparseTree RCURLY15_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_PACKAGE=new RewriteRuleITokenStream(adaptor,"token PACKAGE");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifierStar=new RewriteRuleSubtreeStream(adaptor,"rule identifierStar");
		RewriteRuleSubtreeStream stream_packageBlockEntry=new RewriteRuleSubtreeStream(adaptor,"rule packageBlockEntry");
		try { DebugEnterRule(GrammarFileName, "packageDecl");
		DebugLocation(134, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:135:2: ( PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:135:4: PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY
			{
			DebugLocation(135, 4);
			PACKAGE11=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_packageDecl579); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE11);

			DebugLocation(135, 12);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:135:12: ( identifierStar )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==AS||LA5_0==DYNAMIC||LA5_0==GET||LA5_0==IDENT||LA5_0==IS||LA5_0==NAMESPACE||LA5_0==SET||LA5_0==SUPER||LA5_0==USE||LA5_0==XML))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:135:12: identifierStar
				{
				DebugLocation(135, 12);
				PushFollow(Follow._identifierStar_in_packageDecl581);
				identifierStar12=identifierStar();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifierStar.Add(identifierStar12.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(136, 3);
			LCURLY13=(IToken)Match(input,LCURLY,Follow._LCURLY_in_packageDecl586); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY13);

			DebugLocation(137, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:137:9: ( packageBlockEntry )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==AS||LA6_0==BNOT||LA6_0==BREAK||LA6_0==CLASS||LA6_0==CONST||LA6_0==CONTINUE||(LA6_0>=DEC && LA6_0<=DECIMAL_LITERAL)||LA6_0==DEFAULT||LA6_0==DO||(LA6_0>=DYNAMIC && LA6_0<=E4X_ATTRI)||(LA6_0>=FALSE && LA6_0<=FOR)||LA6_0==FUNCTION||LA6_0==GET||(LA6_0>=HEX_LITERAL && LA6_0<=IDENT)||LA6_0==IF||LA6_0==IMPORT||LA6_0==INC||LA6_0==INTERFACE||(LA6_0>=INTERNAL && LA6_0<=IS)||(LA6_0>=LBRACK && LA6_0<=LCURLY)||LA6_0==LNOT||LA6_0==LPAREN||LA6_0==MINUS||LA6_0==NAMESPACE||LA6_0==NEW||LA6_0==NULL||LA6_0==OCTAL_LITERAL||LA6_0==PLUS||LA6_0==PRIVATE||(LA6_0>=PROTECTED && LA6_0<=PUBLIC)||LA6_0==REGEX_LITERAL||LA6_0==RETURN||(LA6_0>=SEMI && LA6_0<=SET)||LA6_0==STATIC||(LA6_0>=STRING_LITERAL_DOUBLE && LA6_0<=SWITCH)||LA6_0==TRUE||(LA6_0>=USE && LA6_0<=VAR)||LA6_0==WHILE||LA6_0==WITH||LA6_0==XML||LA6_0==XML_LITERAL||(LA6_0>=243 && LA6_0<=246)||LA6_0==248||LA6_0==250||(LA6_0>=252 && LA6_0<=257)))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:137:9: packageBlockEntry
					{
					DebugLocation(137, 9);
					PushFollow(Follow._packageBlockEntry_in_packageDecl597);
					packageBlockEntry14=packageBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_packageBlockEntry.Add(packageBlockEntry14.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(138, 3);
			RCURLY15=(IToken)Match(input,RCURLY,Follow._RCURLY_in_packageDecl602); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY15);



			{
			// AST REWRITE
			// elements: RCURLY, identifierStar, PACKAGE, packageBlockEntry, LCURLY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 139:3: -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY )
			{
				DebugLocation(139, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:139:6: ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(139, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PACKAGE_DECL, "PACKAGE_DECL"), root_1);

				DebugLocation(139, 21);
				adaptor.AddChild(root_1, stream_PACKAGE.NextNode());
				DebugLocation(139, 29);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:139:29: ( identifierStar )?
				if (stream_identifierStar.HasNext)
				{
					DebugLocation(139, 29);
					adaptor.AddChild(root_1, stream_identifierStar.NextTree());

				}
				stream_identifierStar.Reset();
				DebugLocation(139, 45);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(139, 52);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:139:52: ( packageBlockEntry )*
				while ( stream_packageBlockEntry.HasNext )
				{
					DebugLocation(139, 52);
					adaptor.AddChild(root_1, stream_packageBlockEntry.NextTree());

				}
				stream_packageBlockEntry.Reset();
				DebugLocation(139, 71);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("packageDecl", 5);
			LeaveRule("packageDecl", 5);
			LeaveRule_packageDecl();
		}
		DebugLocation(140, 1);
		} finally { DebugExitRule(GrammarFileName, "packageDecl"); }
		return retval;

	}
	// $ANTLR end "packageDecl"

	partial void EnterRule_packageBlockEntry();
	partial void LeaveRule_packageBlockEntry();

	// $ANTLR start "packageBlockEntry"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:142:2: packageBlockEntry options {k=2; } : ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement );
	[GrammarRule("packageBlockEntry")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> packageBlockEntry()
	{
		EnterRule_packageBlockEntry();
		EnterRule("packageBlockEntry", 6);
		TraceIn("packageBlockEntry", 6);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> importDefinition16 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> includeDirective17 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> useNamespaceDirective18 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> annotation19 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> namespaceDefinition20 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> classDefinition21 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> interfaceDefinition22 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> methodDefinition23 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDefinition24 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement25 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "packageBlockEntry");
		DebugLocation(142, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:143:2: ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement )
			int alt7=10;
			try { DebugEnterDecision(7, false);
			try
			{
				alt7 = dfa7.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:143:8: importDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(143, 8);
				PushFollow(Follow._importDefinition_in_packageBlockEntry645);
				importDefinition16=importDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition16.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:144:7: includeDirective
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(144, 7);
				PushFollow(Follow._includeDirective_in_packageBlockEntry653);
				includeDirective17=includeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, includeDirective17.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:145:7: useNamespaceDirective
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(145, 7);
				PushFollow(Follow._useNamespaceDirective_in_packageBlockEntry661);
				useNamespaceDirective18=useNamespaceDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, useNamespaceDirective18.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:146:7: ( LBRACK IDENT )=> annotation
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(146, 25);
				PushFollow(Follow._annotation_in_packageBlockEntry677);
				annotation19=annotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, annotation19.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:147:7: ( modifiers NAMESPACE )=> namespaceDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(147, 32);
				PushFollow(Follow._namespaceDefinition_in_packageBlockEntry693);
				namespaceDefinition20=namespaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceDefinition20.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:148:13: ( modifiers CLASS )=> classDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(148, 34);
				PushFollow(Follow._classDefinition_in_packageBlockEntry715);
				classDefinition21=classDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classDefinition21.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:149:7: ( modifiers INTERFACE )=> interfaceDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(149, 32);
				PushFollow(Follow._interfaceDefinition_in_packageBlockEntry731);
				interfaceDefinition22=interfaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDefinition22.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:150:7: ( modifiers FUNCTION )=> methodDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(150, 31);
				PushFollow(Follow._methodDefinition_in_packageBlockEntry747);
				methodDefinition23=methodDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, methodDefinition23.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:151:7: ( modifiers varOrConst )=> variableDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(151, 33);
				PushFollow(Follow._variableDefinition_in_packageBlockEntry763);
				variableDefinition24=variableDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDefinition24.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:152:13: statement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(152, 13);
				PushFollow(Follow._statement_in_packageBlockEntry777);
				statement25=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement25.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("packageBlockEntry", 6);
			LeaveRule("packageBlockEntry", 6);
			LeaveRule_packageBlockEntry();
		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "packageBlockEntry"); }
		return retval;

	}
	// $ANTLR end "packageBlockEntry"

	partial void EnterRule_endOfFile();
	partial void LeaveRule_endOfFile();

	// $ANTLR start "endOfFile"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:157:1: endOfFile : EOF !;
	[GrammarRule("endOfFile")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> endOfFile()
	{
		EnterRule_endOfFile();
		EnterRule("endOfFile", 7);
		TraceIn("endOfFile", 7);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken EOF26 = default(IToken);

		FlyparseTree EOF26_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "endOfFile");
		DebugLocation(157, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:158:2: ( EOF !)
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:158:4: EOF !
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(158, 7);
			EOF26=(IToken)Match(input,EOF,Follow._EOF_in_endOfFile790); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endOfFile", 7);
			LeaveRule("endOfFile", 7);
			LeaveRule_endOfFile();
		}
		DebugLocation(159, 1);
		} finally { DebugExitRule(GrammarFileName, "endOfFile"); }
		return retval;

	}
	// $ANTLR end "endOfFile"

	partial void EnterRule_importDefinition();
	partial void LeaveRule_importDefinition();

	// $ANTLR start "importDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:161:1: importDefinition : IMPORT identifierStar s= semi -> ^( IMPORT_DEF IMPORT identifierStar ) ;
	[GrammarRule("importDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> importDefinition()
	{
		EnterRule_importDefinition();
		EnterRule("importDefinition", 8);
		TraceIn("importDefinition", 8);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IMPORT27 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifierStar28 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree IMPORT27_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_IMPORT=new RewriteRuleITokenStream(adaptor,"token IMPORT");
		RewriteRuleSubtreeStream stream_identifierStar=new RewriteRuleSubtreeStream(adaptor,"rule identifierStar");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "importDefinition");
		DebugLocation(161, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:162:2: ( IMPORT identifierStar s= semi -> ^( IMPORT_DEF IMPORT identifierStar ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:162:4: IMPORT identifierStar s= semi
			{
			DebugLocation(162, 4);
			IMPORT27=(IToken)Match(input,IMPORT,Follow._IMPORT_in_importDefinition802); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPORT.Add(IMPORT27);

			DebugLocation(162, 11);
			PushFollow(Follow._identifierStar_in_importDefinition804);
			identifierStar28=identifierStar();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifierStar.Add(identifierStar28.Tree);
			DebugLocation(162, 27);
			PushFollow(Follow._semi_in_importDefinition808);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: identifierStar, IMPORT
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 163:10: -> ^( IMPORT_DEF IMPORT identifierStar )
			{
				DebugLocation(163, 13);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:163:13: ^( IMPORT_DEF IMPORT identifierStar )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(163, 15);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(IMPORT_DEF, "IMPORT_DEF"), root_1);

				DebugLocation(163, 26);
				adaptor.AddChild(root_1, stream_IMPORT.NextNode());
				DebugLocation(163, 33);
				adaptor.AddChild(root_1, stream_identifierStar.NextTree());
				DebugLocation(163, 48);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("importDefinition", 8);
			LeaveRule("importDefinition", 8);
			LeaveRule_importDefinition();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "importDefinition"); }
		return retval;

	}
	// $ANTLR end "importDefinition"

	partial void EnterRule_semi();
	partial void LeaveRule_semi();

	// $ANTLR start "semi"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:166:1: semi : SEMI ;
	[GrammarRule("semi")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> semi()
	{
		EnterRule_semi();
		EnterRule("semi", 9);
		TraceIn("semi", 9);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken SEMI29 = default(IToken);

		FlyparseTree SEMI29_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "semi");
		DebugLocation(166, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:167:2: ( SEMI )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:167:4: SEMI
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(167, 4);
			SEMI29=(IToken)Match(input,SEMI,Follow._SEMI_in_semi841); if (state.failed) return retval;
			if (state.backtracking == 0) {
			SEMI29_tree = (FlyparseTree)adaptor.Create(SEMI29);
			adaptor.AddChild(root_0, SEMI29_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("semi", 9);
			LeaveRule("semi", 9);
			LeaveRule_semi();
		}
		DebugLocation(168, 1);
		} finally { DebugExitRule(GrammarFileName, "semi"); }
		return retval;

	}
	// $ANTLR end "semi"

	partial void EnterRule_classDefinition();
	partial void LeaveRule_classDefinition();

	// $ANTLR start "classDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:170:1: classDefinition : modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock ) ;
	[GrammarRule("classDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> classDefinition()
	{
		EnterRule_classDefinition();
		EnterRule("classDefinition", 10);
		TraceIn("classDefinition", 10);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken CLASS31 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers30 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident32 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> classExtendsClause33 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> implementsClause34 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeBlock35 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree CLASS31_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_classExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		RewriteRuleSubtreeStream stream_implementsClause=new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		try { DebugEnterRule(GrammarFileName, "classDefinition");
		DebugLocation(170, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:171:2: ( modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:171:4: modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock
			{
			DebugLocation(171, 4);
			PushFollow(Follow._modifiers_in_classDefinition853);
			modifiers30=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers30.Tree);
			DebugLocation(172, 3);
			CLASS31=(IToken)Match(input,CLASS,Follow._CLASS_in_classDefinition857); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS31);

			DebugLocation(173, 9);
			PushFollow(Follow._ident_in_classDefinition868);
			ident32=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident32.Tree);
			DebugLocation(174, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:174:3: ( classExtendsClause )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==EXTENDS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:174:3: classExtendsClause
				{
				DebugLocation(174, 3);
				PushFollow(Follow._classExtendsClause_in_classDefinition872);
				classExtendsClause33=classExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_classExtendsClause.Add(classExtendsClause33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(175, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:175:3: ( implementsClause )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==IMPLEMENTS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:175:3: implementsClause
				{
				DebugLocation(175, 3);
				PushFollow(Follow._implementsClause_in_classDefinition877);
				implementsClause34=implementsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_implementsClause.Add(implementsClause34.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(176, 3);
			PushFollow(Follow._typeBlock_in_classDefinition882);
			typeBlock35=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock35.Tree);


			{
			// AST REWRITE
			// elements: classExtendsClause, ident, modifiers, CLASS, typeBlock, implementsClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 177:3: -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock )
			{
				DebugLocation(177, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:177:6: ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(177, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

				DebugLocation(177, 18);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(177, 28);
				adaptor.AddChild(root_1, stream_CLASS.NextNode());
				DebugLocation(177, 34);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:177:34: ^( CLASS_NAME ident )
				{
				FlyparseTree root_2 = (FlyparseTree)adaptor.Nil();
				DebugLocation(177, 36);
				root_2 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CLASS_NAME, "CLASS_NAME"), root_2);

				DebugLocation(177, 47);
				adaptor.AddChild(root_2, stream_ident.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(177, 54);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:177:54: ( classExtendsClause )?
				if (stream_classExtendsClause.HasNext)
				{
					DebugLocation(177, 54);
					adaptor.AddChild(root_1, stream_classExtendsClause.NextTree());

				}
				stream_classExtendsClause.Reset();
				DebugLocation(177, 74);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:177:74: ( implementsClause )?
				if (stream_implementsClause.HasNext)
				{
					DebugLocation(177, 74);
					adaptor.AddChild(root_1, stream_implementsClause.NextTree());

				}
				stream_implementsClause.Reset();
				DebugLocation(177, 92);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classDefinition", 10);
			LeaveRule("classDefinition", 10);
			LeaveRule_classDefinition();
		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "classDefinition"); }
		return retval;

	}
	// $ANTLR end "classDefinition"

	partial void EnterRule_as2ClassDefinition();
	partial void LeaveRule_as2ClassDefinition();

	// $ANTLR start "as2ClassDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:180:1: as2ClassDefinition : modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock ) ;
	[GrammarRule("as2ClassDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as2ClassDefinition()
	{
		EnterRule_as2ClassDefinition();
		EnterRule("as2ClassDefinition", 11);
		TraceIn("as2ClassDefinition", 11);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken CLASS37 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers36 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier38 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> classExtendsClause39 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> implementsClause40 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeBlock41 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree CLASS37_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_classExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		RewriteRuleSubtreeStream stream_implementsClause=new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "as2ClassDefinition");
		DebugLocation(180, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:181:2: ( modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:181:4: modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock
			{
			DebugLocation(181, 4);
			PushFollow(Follow._modifiers_in_as2ClassDefinition919);
			modifiers36=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers36.Tree);
			DebugLocation(182, 3);
			CLASS37=(IToken)Match(input,CLASS,Follow._CLASS_in_as2ClassDefinition923); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS37);

			DebugLocation(182, 9);
			PushFollow(Follow._identifier_in_as2ClassDefinition925);
			identifier38=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier38.Tree);
			DebugLocation(183, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:183:3: ( classExtendsClause )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==EXTENDS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:183:3: classExtendsClause
				{
				DebugLocation(183, 3);
				PushFollow(Follow._classExtendsClause_in_as2ClassDefinition929);
				classExtendsClause39=classExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_classExtendsClause.Add(classExtendsClause39.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(184, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:184:3: ( implementsClause )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_0 = input.LA(1);

			if ((LA11_0==IMPLEMENTS))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:184:3: implementsClause
				{
				DebugLocation(184, 3);
				PushFollow(Follow._implementsClause_in_as2ClassDefinition934);
				implementsClause40=implementsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_implementsClause.Add(implementsClause40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(185, 3);
			PushFollow(Follow._typeBlock_in_as2ClassDefinition939);
			typeBlock41=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock41.Tree);


			{
			// AST REWRITE
			// elements: typeBlock, identifier, implementsClause, modifiers, classExtendsClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 186:3: -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock )
			{
				DebugLocation(186, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:186:6: ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(186, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

				DebugLocation(186, 18);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(186, 28);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(186, 39);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:186:39: ( classExtendsClause )?
				if (stream_classExtendsClause.HasNext)
				{
					DebugLocation(186, 39);
					adaptor.AddChild(root_1, stream_classExtendsClause.NextTree());

				}
				stream_classExtendsClause.Reset();
				DebugLocation(186, 59);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:186:59: ( implementsClause )?
				if (stream_implementsClause.HasNext)
				{
					DebugLocation(186, 59);
					adaptor.AddChild(root_1, stream_implementsClause.NextTree());

				}
				stream_implementsClause.Reset();
				DebugLocation(186, 77);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2ClassDefinition", 11);
			LeaveRule("as2ClassDefinition", 11);
			LeaveRule_as2ClassDefinition();
		}
		DebugLocation(187, 1);
		} finally { DebugExitRule(GrammarFileName, "as2ClassDefinition"); }
		return retval;

	}
	// $ANTLR end "as2ClassDefinition"

	partial void EnterRule_interfaceDefinition();
	partial void LeaveRule_interfaceDefinition();

	// $ANTLR start "interfaceDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:189:1: interfaceDefinition : modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock ) ;
	[GrammarRule("interfaceDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> interfaceDefinition()
	{
		EnterRule_interfaceDefinition();
		EnterRule("interfaceDefinition", 12);
		TraceIn("interfaceDefinition", 12);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken INTERFACE43 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers42 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident44 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> interfaceExtendsClause45 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeBlock46 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree INTERFACE43_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_INTERFACE=new RewriteRuleITokenStream(adaptor,"token INTERFACE");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		RewriteRuleSubtreeStream stream_interfaceExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		try { DebugEnterRule(GrammarFileName, "interfaceDefinition");
		DebugLocation(189, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:190:2: ( modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:190:4: modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock
			{
			DebugLocation(190, 4);
			PushFollow(Follow._modifiers_in_interfaceDefinition970);
			modifiers42=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers42.Tree);
			DebugLocation(191, 3);
			INTERFACE43=(IToken)Match(input,INTERFACE,Follow._INTERFACE_in_interfaceDefinition974); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INTERFACE.Add(INTERFACE43);

			DebugLocation(191, 13);
			PushFollow(Follow._ident_in_interfaceDefinition976);
			ident44=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident44.Tree);
			DebugLocation(192, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:192:3: ( interfaceExtendsClause )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_0 = input.LA(1);

			if ((LA12_0==EXTENDS))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:192:3: interfaceExtendsClause
				{
				DebugLocation(192, 3);
				PushFollow(Follow._interfaceExtendsClause_in_interfaceDefinition980);
				interfaceExtendsClause45=interfaceExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause45.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(193, 3);
			PushFollow(Follow._typeBlock_in_interfaceDefinition985);
			typeBlock46=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock46.Tree);


			{
			// AST REWRITE
			// elements: ident, modifiers, interfaceExtendsClause, typeBlock, INTERFACE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 194:3: -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock )
			{
				DebugLocation(194, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:194:6: ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(194, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

				DebugLocation(194, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(194, 32);
				adaptor.AddChild(root_1, stream_INTERFACE.NextNode());
				DebugLocation(194, 42);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(194, 48);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:194:48: ( interfaceExtendsClause )?
				if (stream_interfaceExtendsClause.HasNext)
				{
					DebugLocation(194, 48);
					adaptor.AddChild(root_1, stream_interfaceExtendsClause.NextTree());

				}
				stream_interfaceExtendsClause.Reset();
				DebugLocation(194, 72);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interfaceDefinition", 12);
			LeaveRule("interfaceDefinition", 12);
			LeaveRule_interfaceDefinition();
		}
		DebugLocation(195, 1);
		} finally { DebugExitRule(GrammarFileName, "interfaceDefinition"); }
		return retval;

	}
	// $ANTLR end "interfaceDefinition"

	partial void EnterRule_as2InterfaceDefinition();
	partial void LeaveRule_as2InterfaceDefinition();

	// $ANTLR start "as2InterfaceDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:197:1: as2InterfaceDefinition : modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock ) ;
	[GrammarRule("as2InterfaceDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as2InterfaceDefinition()
	{
		EnterRule_as2InterfaceDefinition();
		EnterRule("as2InterfaceDefinition", 13);
		TraceIn("as2InterfaceDefinition", 13);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken INTERFACE48 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers47 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier49 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> interfaceExtendsClause50 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeBlock51 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree INTERFACE48_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_INTERFACE=new RewriteRuleITokenStream(adaptor,"token INTERFACE");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		RewriteRuleSubtreeStream stream_interfaceExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "as2InterfaceDefinition");
		DebugLocation(197, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:198:2: ( modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:198:4: modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock
			{
			DebugLocation(198, 4);
			PushFollow(Follow._modifiers_in_as2InterfaceDefinition1015);
			modifiers47=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers47.Tree);
			DebugLocation(199, 3);
			INTERFACE48=(IToken)Match(input,INTERFACE,Follow._INTERFACE_in_as2InterfaceDefinition1019); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INTERFACE.Add(INTERFACE48);

			DebugLocation(199, 13);
			PushFollow(Follow._identifier_in_as2InterfaceDefinition1021);
			identifier49=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier49.Tree);
			DebugLocation(200, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:200:3: ( interfaceExtendsClause )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_0 = input.LA(1);

			if ((LA13_0==EXTENDS))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:200:3: interfaceExtendsClause
				{
				DebugLocation(200, 3);
				PushFollow(Follow._interfaceExtendsClause_in_as2InterfaceDefinition1025);
				interfaceExtendsClause50=interfaceExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause50.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(201, 3);
			PushFollow(Follow._typeBlock_in_as2InterfaceDefinition1030);
			typeBlock51=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock51.Tree);


			{
			// AST REWRITE
			// elements: interfaceExtendsClause, modifiers, identifier, typeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 202:3: -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock )
			{
				DebugLocation(202, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:202:6: ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(202, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

				DebugLocation(202, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(202, 32);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(202, 43);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:202:43: ( interfaceExtendsClause )?
				if (stream_interfaceExtendsClause.HasNext)
				{
					DebugLocation(202, 43);
					adaptor.AddChild(root_1, stream_interfaceExtendsClause.NextTree());

				}
				stream_interfaceExtendsClause.Reset();
				DebugLocation(202, 67);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2InterfaceDefinition", 13);
			LeaveRule("as2InterfaceDefinition", 13);
			LeaveRule_as2InterfaceDefinition();
		}
		DebugLocation(203, 1);
		} finally { DebugExitRule(GrammarFileName, "as2InterfaceDefinition"); }
		return retval;

	}
	// $ANTLR end "as2InterfaceDefinition"

	partial void EnterRule_classExtendsClause();
	partial void LeaveRule_classExtendsClause();

	// $ANTLR start "classExtendsClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:205:1: classExtendsClause : EXTENDS identifier -> ^( EXTENDS_CLAUSE EXTENDS identifier ) ;
	[GrammarRule("classExtendsClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> classExtendsClause()
	{
		EnterRule_classExtendsClause();
		EnterRule("classExtendsClause", 14);
		TraceIn("classExtendsClause", 14);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken EXTENDS52 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier53 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree EXTENDS52_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "classExtendsClause");
		DebugLocation(205, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:206:2: ( EXTENDS identifier -> ^( EXTENDS_CLAUSE EXTENDS identifier ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:206:4: EXTENDS identifier
			{
			DebugLocation(206, 4);
			EXTENDS52=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_classExtendsClause1058); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS52);

			DebugLocation(206, 12);
			PushFollow(Follow._identifier_in_classExtendsClause1060);
			identifier53=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier53.Tree);


			{
			// AST REWRITE
			// elements: EXTENDS, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 207:9: -> ^( EXTENDS_CLAUSE EXTENDS identifier )
			{
				DebugLocation(207, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:207:12: ^( EXTENDS_CLAUSE EXTENDS identifier )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(207, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(EXTENDS_CLAUSE, "EXTENDS_CLAUSE"), root_1);

				DebugLocation(207, 29);
				adaptor.AddChild(root_1, stream_EXTENDS.NextNode());
				DebugLocation(207, 37);
				adaptor.AddChild(root_1, stream_identifier.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classExtendsClause", 14);
			LeaveRule("classExtendsClause", 14);
			LeaveRule_classExtendsClause();
		}
		DebugLocation(208, 1);
		} finally { DebugExitRule(GrammarFileName, "classExtendsClause"); }
		return retval;

	}
	// $ANTLR end "classExtendsClause"

	partial void EnterRule_interfaceExtendsClause();
	partial void LeaveRule_interfaceExtendsClause();

	// $ANTLR start "interfaceExtendsClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:210:1: interfaceExtendsClause : EXTENDS identifier ( COMMA identifier )* -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ ) ;
	[GrammarRule("interfaceExtendsClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> interfaceExtendsClause()
	{
		EnterRule_interfaceExtendsClause();
		EnterRule("interfaceExtendsClause", 15);
		TraceIn("interfaceExtendsClause", 15);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken EXTENDS54 = default(IToken);
		IToken COMMA56 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier55 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier57 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree EXTENDS54_tree = default(FlyparseTree);
		FlyparseTree COMMA56_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "interfaceExtendsClause");
		DebugLocation(210, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:211:2: ( EXTENDS identifier ( COMMA identifier )* -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:211:4: EXTENDS identifier ( COMMA identifier )*
			{
			DebugLocation(211, 4);
			EXTENDS54=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_interfaceExtendsClause1089); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS54);

			DebugLocation(211, 12);
			PushFollow(Follow._identifier_in_interfaceExtendsClause1091);
			identifier55=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier55.Tree);
			DebugLocation(211, 23);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:211:23: ( COMMA identifier )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==COMMA))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:211:25: COMMA identifier
					{
					DebugLocation(211, 25);
					COMMA56=(IToken)Match(input,COMMA,Follow._COMMA_in_interfaceExtendsClause1095); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA56);

					DebugLocation(211, 31);
					PushFollow(Follow._identifier_in_interfaceExtendsClause1097);
					identifier57=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier57.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: identifier, EXTENDS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 212:9: -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ )
			{
				DebugLocation(212, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:212:12: ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(212, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(EXTENDS_CLAUSE, "EXTENDS_CLAUSE"), root_1);

				DebugLocation(212, 29);
				adaptor.AddChild(root_1, stream_EXTENDS.NextNode());
				DebugLocation(212, 37);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(212, 37);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interfaceExtendsClause", 15);
			LeaveRule("interfaceExtendsClause", 15);
			LeaveRule_interfaceExtendsClause();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "interfaceExtendsClause"); }
		return retval;

	}
	// $ANTLR end "interfaceExtendsClause"

	partial void EnterRule_implementsClause();
	partial void LeaveRule_implementsClause();

	// $ANTLR start "implementsClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:215:1: implementsClause : IMPLEMENTS identifier ( COMMA identifier )* -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ ) ;
	[GrammarRule("implementsClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> implementsClause()
	{
		EnterRule_implementsClause();
		EnterRule("implementsClause", 16);
		TraceIn("implementsClause", 16);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IMPLEMENTS58 = default(IToken);
		IToken COMMA60 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier59 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> identifier61 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree IMPLEMENTS58_tree = default(FlyparseTree);
		FlyparseTree COMMA60_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_IMPLEMENTS=new RewriteRuleITokenStream(adaptor,"token IMPLEMENTS");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "implementsClause");
		DebugLocation(215, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:216:2: ( IMPLEMENTS identifier ( COMMA identifier )* -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:216:4: IMPLEMENTS identifier ( COMMA identifier )*
			{
			DebugLocation(216, 4);
			IMPLEMENTS58=(IToken)Match(input,IMPLEMENTS,Follow._IMPLEMENTS_in_implementsClause1129); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPLEMENTS.Add(IMPLEMENTS58);

			DebugLocation(216, 15);
			PushFollow(Follow._identifier_in_implementsClause1131);
			identifier59=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier59.Tree);
			DebugLocation(216, 26);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:216:26: ( COMMA identifier )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==COMMA))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:216:28: COMMA identifier
					{
					DebugLocation(216, 28);
					COMMA60=(IToken)Match(input,COMMA,Follow._COMMA_in_implementsClause1135); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA60);

					DebugLocation(216, 34);
					PushFollow(Follow._identifier_in_implementsClause1137);
					identifier61=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier61.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }



			{
			// AST REWRITE
			// elements: identifier, IMPLEMENTS
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 217:9: -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ )
			{
				DebugLocation(217, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:217:12: ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(217, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(IMPLEMENTS_CLAUSE, "IMPLEMENTS_CLAUSE"), root_1);

				DebugLocation(217, 32);
				adaptor.AddChild(root_1, stream_IMPLEMENTS.NextNode());
				DebugLocation(217, 43);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(217, 43);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("implementsClause", 16);
			LeaveRule("implementsClause", 16);
			LeaveRule_implementsClause();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "implementsClause"); }
		return retval;

	}
	// $ANTLR end "implementsClause"

	partial void EnterRule_typeBlock();
	partial void LeaveRule_typeBlock();

	// $ANTLR start "typeBlock"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:220:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY ) ;
	[GrammarRule("typeBlock")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> typeBlock()
	{
		EnterRule_typeBlock();
		EnterRule("typeBlock", 17);
		TraceIn("typeBlock", 17);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LCURLY62 = default(IToken);
		IToken RCURLY64 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeBlockEntry63 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LCURLY62_tree = default(FlyparseTree);
		FlyparseTree RCURLY64_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeBlockEntry=new RewriteRuleSubtreeStream(adaptor,"rule typeBlockEntry");
		try { DebugEnterRule(GrammarFileName, "typeBlock");
		DebugLocation(220, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:221:2: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:221:4: LCURLY ( typeBlockEntry )* RCURLY
			{
			DebugLocation(221, 4);
			LCURLY62=(IToken)Match(input,LCURLY,Follow._LCURLY_in_typeBlock1169); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY62);

			DebugLocation(222, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:222:9: ( typeBlockEntry )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==AS||LA16_0==BNOT||LA16_0==BREAK||LA16_0==CONST||LA16_0==CONTINUE||(LA16_0>=DEC && LA16_0<=DECIMAL_LITERAL)||LA16_0==DEFAULT||LA16_0==DO||(LA16_0>=DYNAMIC && LA16_0<=E4X_ATTRI)||(LA16_0>=FALSE && LA16_0<=FOR)||LA16_0==FUNCTION||LA16_0==GET||(LA16_0>=HEX_LITERAL && LA16_0<=IDENT)||LA16_0==IF||LA16_0==IMPORT||LA16_0==INC||(LA16_0>=INTERNAL && LA16_0<=IS)||(LA16_0>=LBRACK && LA16_0<=LCURLY)||LA16_0==LNOT||LA16_0==LPAREN||LA16_0==MINUS||LA16_0==NAMESPACE||LA16_0==NEW||LA16_0==NULL||LA16_0==OCTAL_LITERAL||LA16_0==PLUS||LA16_0==PRIVATE||(LA16_0>=PROTECTED && LA16_0<=PUBLIC)||LA16_0==REGEX_LITERAL||LA16_0==RETURN||(LA16_0>=SEMI && LA16_0<=SET)||LA16_0==STATIC||(LA16_0>=STRING_LITERAL_DOUBLE && LA16_0<=SWITCH)||LA16_0==TRUE||(LA16_0>=USE && LA16_0<=VAR)||LA16_0==WHILE||LA16_0==WITH||LA16_0==XML||LA16_0==XML_LITERAL||(LA16_0>=243 && LA16_0<=246)||LA16_0==248||LA16_0==250||(LA16_0>=252 && LA16_0<=257)))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:222:9: typeBlockEntry
					{
					DebugLocation(222, 9);
					PushFollow(Follow._typeBlockEntry_in_typeBlock1179);
					typeBlockEntry63=typeBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeBlockEntry.Add(typeBlockEntry63.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(223, 3);
			RCURLY64=(IToken)Match(input,RCURLY,Follow._RCURLY_in_typeBlock1184); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY64);



			{
			// AST REWRITE
			// elements: typeBlockEntry, RCURLY, LCURLY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 224:3: -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY )
			{
				DebugLocation(224, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:224:6: ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(224, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);

				DebugLocation(224, 19);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(224, 26);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:224:26: ( typeBlockEntry )*
				while ( stream_typeBlockEntry.HasNext )
				{
					DebugLocation(224, 26);
					adaptor.AddChild(root_1, stream_typeBlockEntry.NextTree());

				}
				stream_typeBlockEntry.Reset();
				DebugLocation(224, 42);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeBlock", 17);
			LeaveRule("typeBlock", 17);
			LeaveRule_typeBlock();
		}
		DebugLocation(225, 1);
		} finally { DebugExitRule(GrammarFileName, "typeBlock"); }
		return retval;

	}
	// $ANTLR end "typeBlock"

	partial void EnterRule_typeBlockEntry();
	partial void LeaveRule_typeBlockEntry();

	// $ANTLR start "typeBlockEntry"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:227:1: typeBlockEntry options {k=2; } : ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement );
	[GrammarRule("typeBlockEntry")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> typeBlockEntry()
	{
		EnterRule_typeBlockEntry();
		EnterRule("typeBlockEntry", 18);
		TraceIn("typeBlockEntry", 18);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> includeDirective65 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> importDefinition66 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> annotation67 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDefinition68 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> methodDefinition69 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement70 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_variableDefinition=new RewriteRuleSubtreeStream(adaptor,"rule variableDefinition");
		RewriteRuleSubtreeStream stream_methodDefinition=new RewriteRuleSubtreeStream(adaptor,"rule methodDefinition");
		try { DebugEnterRule(GrammarFileName, "typeBlockEntry");
		DebugLocation(227, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:228:2: ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement )
			int alt17=6;
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:229:7: includeDirective
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(229, 7);
				PushFollow(Follow._includeDirective_in_typeBlockEntry1226);
				includeDirective65=includeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, includeDirective65.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:230:4: importDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(230, 4);
				PushFollow(Follow._importDefinition_in_typeBlockEntry1231);
				importDefinition66=importDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition66.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:231:4: ( LBRACK IDENT )=> annotation
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(231, 22);
				PushFollow(Follow._annotation_in_typeBlockEntry1244);
				annotation67=annotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, annotation67.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:232:4: ( modifiers varOrConst )=> variableDefinition
				{
				DebugLocation(232, 31);
				PushFollow(Follow._variableDefinition_in_typeBlockEntry1258);
				variableDefinition68=variableDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDefinition.Add(variableDefinition68.Tree);


				{
				// AST REWRITE
				// elements: variableDefinition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 232:50: -> ^( CLASS_MEMBER variableDefinition )
				{
					DebugLocation(232, 53);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:232:53: ^( CLASS_MEMBER variableDefinition )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(232, 55);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CLASS_MEMBER, "CLASS_MEMBER"), root_1);

					DebugLocation(232, 68);
					adaptor.AddChild(root_1, stream_variableDefinition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:233:4: ( modifiers FUNCTION )=> methodDefinition
				{
				DebugLocation(233, 28);
				PushFollow(Follow._methodDefinition_in_typeBlockEntry1279);
				methodDefinition69=methodDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodDefinition.Add(methodDefinition69.Tree);


				{
				// AST REWRITE
				// elements: methodDefinition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 233:45: -> ^( CLASS_MEMBER methodDefinition )
				{
					DebugLocation(233, 48);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:233:48: ^( CLASS_MEMBER methodDefinition )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(233, 50);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CLASS_MEMBER, "CLASS_MEMBER"), root_1);

					DebugLocation(233, 63);
					adaptor.AddChild(root_1, stream_methodDefinition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:234:4: statement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(234, 4);
				PushFollow(Follow._statement_in_typeBlockEntry1292);
				statement70=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement70.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeBlockEntry", 18);
			LeaveRule("typeBlockEntry", 18);
			LeaveRule_typeBlockEntry();
		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "typeBlockEntry"); }
		return retval;

	}
	// $ANTLR end "typeBlockEntry"

	partial void EnterRule_as2IncludeDirective();
	partial void LeaveRule_as2IncludeDirective();

	// $ANTLR start "as2IncludeDirective"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:237:1: as2IncludeDirective : INCLUDE_DIRECTIVE stringLiteral ;
	[GrammarRule("as2IncludeDirective")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> as2IncludeDirective()
	{
		EnterRule_as2IncludeDirective();
		EnterRule("as2IncludeDirective", 19);
		TraceIn("as2IncludeDirective", 19);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken INCLUDE_DIRECTIVE71 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteral72 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree INCLUDE_DIRECTIVE71_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "as2IncludeDirective");
		DebugLocation(237, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:238:2: ( INCLUDE_DIRECTIVE stringLiteral )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:238:4: INCLUDE_DIRECTIVE stringLiteral
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(238, 4);
			INCLUDE_DIRECTIVE71=(IToken)Match(input,INCLUDE_DIRECTIVE,Follow._INCLUDE_DIRECTIVE_in_as2IncludeDirective1303); if (state.failed) return retval;
			if (state.backtracking == 0) {
			INCLUDE_DIRECTIVE71_tree = (FlyparseTree)adaptor.Create(INCLUDE_DIRECTIVE71);
			adaptor.AddChild(root_0, INCLUDE_DIRECTIVE71_tree);
			}
			DebugLocation(239, 3);
			PushFollow(Follow._stringLiteral_in_as2IncludeDirective1307);
			stringLiteral72=stringLiteral();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral72.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2IncludeDirective", 19);
			LeaveRule("as2IncludeDirective", 19);
			LeaveRule_as2IncludeDirective();
		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "as2IncludeDirective"); }
		return retval;

	}
	// $ANTLR end "as2IncludeDirective"

	partial void EnterRule_includeDirective();
	partial void LeaveRule_includeDirective();

	// $ANTLR start "includeDirective"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:242:1: includeDirective : 'include' stringLiteral s= semi -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral ) ;
	[GrammarRule("includeDirective")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> includeDirective()
	{
		EnterRule_includeDirective();
		EnterRule("includeDirective", 20);
		TraceIn("includeDirective", 20);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal73 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteral74 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal73_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_248=new RewriteRuleITokenStream(adaptor,"token 248");
		RewriteRuleSubtreeStream stream_stringLiteral=new RewriteRuleSubtreeStream(adaptor,"rule stringLiteral");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "includeDirective");
		DebugLocation(242, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:243:2: ( 'include' stringLiteral s= semi -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:243:4: 'include' stringLiteral s= semi
			{
			DebugLocation(243, 4);
			string_literal73=(IToken)Match(input,248,Follow._248_in_includeDirective1318); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_248.Add(string_literal73);

			DebugLocation(243, 14);
			PushFollow(Follow._stringLiteral_in_includeDirective1320);
			stringLiteral74=stringLiteral();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_stringLiteral.Add(stringLiteral74.Tree);
			DebugLocation(243, 29);
			PushFollow(Follow._semi_in_includeDirective1324);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: stringLiteral, 248
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 244:9: -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral )
			{
				DebugLocation(244, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:244:12: ^( INCLUDE_DIRECTIVE 'include' stringLiteral )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(244, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(INCLUDE_DIRECTIVE, "INCLUDE_DIRECTIVE"), root_1);

				DebugLocation(244, 32);
				adaptor.AddChild(root_1, stream_248.NextNode());
				DebugLocation(244, 42);
				adaptor.AddChild(root_1, stream_stringLiteral.NextTree());
				DebugLocation(244, 56);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("includeDirective", 20);
			LeaveRule("includeDirective", 20);
			LeaveRule_includeDirective();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "includeDirective"); }
		return retval;

	}
	// $ANTLR end "includeDirective"

	partial void EnterRule_methodDefinition();
	partial void LeaveRule_methodDefinition();

	// $ANTLR start "methodDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:248:1: methodDefinition : modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock ) ;
	[GrammarRule("methodDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> methodDefinition()
	{
		EnterRule_methodDefinition();
		EnterRule("methodDefinition", 21);
		TraceIn("methodDefinition", 21);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken FUNCTION76 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers75 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> accessorRole77 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> methodName78 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclarationList79 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression80 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> maybeBlock81 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree FUNCTION76_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_accessorRole=new RewriteRuleSubtreeStream(adaptor,"rule accessorRole");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_methodName=new RewriteRuleSubtreeStream(adaptor,"rule methodName");
		RewriteRuleSubtreeStream stream_parameterDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
		RewriteRuleSubtreeStream stream_maybeBlock=new RewriteRuleSubtreeStream(adaptor,"rule maybeBlock");
		try { DebugEnterRule(GrammarFileName, "methodDefinition");
		DebugLocation(248, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:249:2: ( modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:250:3: modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock
			{
			DebugLocation(250, 3);
			PushFollow(Follow._modifiers_in_methodDefinition1358);
			modifiers75=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers75.Tree);
			DebugLocation(251, 3);
			FUNCTION76=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_methodDefinition1362); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION76);

			DebugLocation(252, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:252:9: ( accessorRole )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==GET))
			{
				int LA18_1 = input.LA(2);

				if ((LA18_1==AS||LA18_1==DYNAMIC||LA18_1==GET||LA18_1==IDENT||LA18_1==IS||LA18_1==NAMESPACE||LA18_1==SET||LA18_1==SUPER||LA18_1==USE||LA18_1==XML))
				{
					alt18 = 1;
				}
			}
			else if ((LA18_0==SET))
			{
				int LA18_3 = input.LA(2);

				if ((LA18_3==AS||LA18_3==DYNAMIC||LA18_3==GET||LA18_3==IDENT||LA18_3==IS||LA18_3==NAMESPACE||LA18_3==SET||LA18_3==SUPER||LA18_3==USE||LA18_3==XML))
				{
					alt18 = 1;
				}
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:252:9: accessorRole
				{
				DebugLocation(252, 9);
				PushFollow(Follow._accessorRole_in_methodDefinition1372);
				accessorRole77=accessorRole();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessorRole.Add(accessorRole77.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(253, 3);
			PushFollow(Follow._methodName_in_methodDefinition1377);
			methodName78=methodName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_methodName.Add(methodName78.Tree);
			DebugLocation(254, 3);
			PushFollow(Follow._parameterDeclarationList_in_methodDefinition1381);
			parameterDeclarationList79=parameterDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList79.Tree);
			DebugLocation(255, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:255:3: ( typeExpression )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_0 = input.LA(1);

			if ((LA19_0==COLON))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:255:3: typeExpression
				{
				DebugLocation(255, 3);
				PushFollow(Follow._typeExpression_in_methodDefinition1385);
				typeExpression80=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression80.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(256, 9);
			PushFollow(Follow._maybeBlock_in_methodDefinition1396);
			maybeBlock81=maybeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_maybeBlock.Add(maybeBlock81.Tree);


			{
			// AST REWRITE
			// elements: FUNCTION, parameterDeclarationList, maybeBlock, typeExpression, methodName, accessorRole, modifiers
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 257:3: -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock )
			{
				DebugLocation(257, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:257:6: ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(257, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);

				DebugLocation(257, 19);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(257, 29);
				adaptor.AddChild(root_1, stream_FUNCTION.NextNode());
				DebugLocation(257, 38);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:257:38: ( accessorRole )?
				if (stream_accessorRole.HasNext)
				{
					DebugLocation(257, 38);
					adaptor.AddChild(root_1, stream_accessorRole.NextTree());

				}
				stream_accessorRole.Reset();
				DebugLocation(258, 17);
				adaptor.AddChild(root_1, stream_methodName.NextTree());
				DebugLocation(259, 5);
				adaptor.AddChild(root_1, stream_parameterDeclarationList.NextTree());
				DebugLocation(260, 5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:260:5: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(260, 5);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(261, 5);
				adaptor.AddChild(root_1, stream_maybeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodDefinition", 21);
			LeaveRule("methodDefinition", 21);
			LeaveRule_methodDefinition();
		}
		DebugLocation(263, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDefinition"); }
		return retval;

	}
	// $ANTLR end "methodDefinition"

	partial void EnterRule_maybeBlock();
	partial void LeaveRule_maybeBlock();

	// $ANTLR start "maybeBlock"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:265:1: maybeBlock options {k=1; } : ( ( LCURLY )=> block |);
	[GrammarRule("maybeBlock")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> maybeBlock()
	{
		EnterRule_maybeBlock();
		EnterRule("maybeBlock", 22);
		TraceIn("maybeBlock", 22);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> block82 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "maybeBlock");
		DebugLocation(265, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:266:5: ( ( LCURLY )=> block |)
			int alt20=2;
			try { DebugEnterDecision(20, false);
			try
			{
				alt20 = dfa20.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:267:5: ( LCURLY )=> block
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(267, 17);
				PushFollow(Follow._block_in_maybeBlock1490);
				block82=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block82.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:269:5: 
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("maybeBlock", 22);
			LeaveRule("maybeBlock", 22);
			LeaveRule_maybeBlock();
		}
		DebugLocation(269, 4);
		} finally { DebugExitRule(GrammarFileName, "maybeBlock"); }
		return retval;

	}
	// $ANTLR end "maybeBlock"

	partial void EnterRule_methodName();
	partial void LeaveRule_methodName();

	// $ANTLR start "methodName"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:271:1: methodName : ident -> ^( METHOD_NAME ident ) ;
	[GrammarRule("methodName")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> methodName()
	{
		EnterRule_methodName();
		EnterRule("methodName", 23);
		TraceIn("methodName", 23);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> ident83 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "methodName");
		DebugLocation(271, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:272:5: ( ident -> ^( METHOD_NAME ident ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:272:7: ident
			{
			DebugLocation(272, 7);
			PushFollow(Follow._ident_in_methodName1516);
			ident83=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident83.Tree);


			{
			// AST REWRITE
			// elements: ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 273:9: -> ^( METHOD_NAME ident )
			{
				DebugLocation(273, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:273:12: ^( METHOD_NAME ident )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(273, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(METHOD_NAME, "METHOD_NAME"), root_1);

				DebugLocation(273, 26);
				adaptor.AddChild(root_1, stream_ident.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodName", 23);
			LeaveRule("methodName", 23);
			LeaveRule_methodName();
		}
		DebugLocation(274, 4);
		} finally { DebugExitRule(GrammarFileName, "methodName"); }
		return retval;

	}
	// $ANTLR end "methodName"

	partial void EnterRule_accessorRole();
	partial void LeaveRule_accessorRole();

	// $ANTLR start "accessorRole"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:277:1: accessorRole : ( GET | SET );
	[GrammarRule("accessorRole")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> accessorRole()
	{
		EnterRule_accessorRole();
		EnterRule("accessorRole", 24);
		TraceIn("accessorRole", 24);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set84 = default(IToken);

		FlyparseTree set84_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "accessorRole");
		DebugLocation(277, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:278:2: ( GET | SET )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(278, 2);

			set84=(IToken)input.LT(1);
			if (input.LA(1)==GET||input.LA(1)==SET)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set84));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessorRole", 24);
			LeaveRule("accessorRole", 24);
			LeaveRule_accessorRole();
		}
		DebugLocation(279, 1);
		} finally { DebugExitRule(GrammarFileName, "accessorRole"); }
		return retval;

	}
	// $ANTLR end "accessorRole"

	partial void EnterRule_namespaceDefinition();
	partial void LeaveRule_namespaceDefinition();

	// $ANTLR start "namespaceDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:281:1: namespaceDefinition : modifiers NAMESPACE namespaceName -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName ) ;
	[GrammarRule("namespaceDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> namespaceDefinition()
	{
		EnterRule_namespaceDefinition();
		EnterRule("namespaceDefinition", 25);
		TraceIn("namespaceDefinition", 25);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken NAMESPACE86 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers85 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> namespaceName87 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree NAMESPACE86_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_NAMESPACE=new RewriteRuleITokenStream(adaptor,"token NAMESPACE");
		RewriteRuleSubtreeStream stream_namespaceName=new RewriteRuleSubtreeStream(adaptor,"rule namespaceName");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		try { DebugEnterRule(GrammarFileName, "namespaceDefinition");
		DebugLocation(281, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:282:2: ( modifiers NAMESPACE namespaceName -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:282:4: modifiers NAMESPACE namespaceName
			{
			DebugLocation(282, 4);
			PushFollow(Follow._modifiers_in_namespaceDefinition1562);
			modifiers85=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers85.Tree);
			DebugLocation(282, 14);
			NAMESPACE86=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_namespaceDefinition1564); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NAMESPACE.Add(NAMESPACE86);

			DebugLocation(282, 24);
			PushFollow(Follow._namespaceName_in_namespaceDefinition1566);
			namespaceName87=namespaceName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_namespaceName.Add(namespaceName87.Tree);


			{
			// AST REWRITE
			// elements: modifiers, NAMESPACE, namespaceName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 283:3: -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName )
			{
				DebugLocation(283, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:283:6: ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(283, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);

				DebugLocation(283, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(283, 32);
				adaptor.AddChild(root_1, stream_NAMESPACE.NextNode());
				DebugLocation(283, 42);
				adaptor.AddChild(root_1, stream_namespaceName.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespaceDefinition", 25);
			LeaveRule("namespaceDefinition", 25);
			LeaveRule_namespaceDefinition();
		}
		DebugLocation(284, 1);
		} finally { DebugExitRule(GrammarFileName, "namespaceDefinition"); }
		return retval;

	}
	// $ANTLR end "namespaceDefinition"

	partial void EnterRule_useNamespaceDirective();
	partial void LeaveRule_useNamespaceDirective();

	// $ANTLR start "useNamespaceDirective"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:286:1: useNamespaceDirective : USE NAMESPACE namespaceName semi ;
	[GrammarRule("useNamespaceDirective")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> useNamespaceDirective()
	{
		EnterRule_useNamespaceDirective();
		EnterRule("useNamespaceDirective", 26);
		TraceIn("useNamespaceDirective", 26);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken USE88 = default(IToken);
		IToken NAMESPACE89 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> namespaceName90 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi91 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree USE88_tree = default(FlyparseTree);
		FlyparseTree NAMESPACE89_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "useNamespaceDirective");
		DebugLocation(286, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:287:2: ( USE NAMESPACE namespaceName semi )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:287:4: USE NAMESPACE namespaceName semi
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(287, 4);
			USE88=(IToken)Match(input,USE,Follow._USE_in_useNamespaceDirective1591); if (state.failed) return retval;
			if (state.backtracking == 0) {
			USE88_tree = (FlyparseTree)adaptor.Create(USE88);
			adaptor.AddChild(root_0, USE88_tree);
			}
			DebugLocation(287, 8);
			NAMESPACE89=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_useNamespaceDirective1593); if (state.failed) return retval;
			if (state.backtracking == 0) {
			NAMESPACE89_tree = (FlyparseTree)adaptor.Create(NAMESPACE89);
			adaptor.AddChild(root_0, NAMESPACE89_tree);
			}
			DebugLocation(287, 18);
			PushFollow(Follow._namespaceName_in_useNamespaceDirective1595);
			namespaceName90=namespaceName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceName90.Tree);
			DebugLocation(287, 32);
			PushFollow(Follow._semi_in_useNamespaceDirective1597);
			semi91=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi91.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("useNamespaceDirective", 26);
			LeaveRule("useNamespaceDirective", 26);
			LeaveRule_useNamespaceDirective();
		}
		DebugLocation(288, 1);
		} finally { DebugExitRule(GrammarFileName, "useNamespaceDirective"); }
		return retval;

	}
	// $ANTLR end "useNamespaceDirective"

	partial void EnterRule_variableDefinition();
	partial void LeaveRule_variableDefinition();

	// $ANTLR start "variableDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:290:1: variableDefinition : modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ ) ;
	[GrammarRule("variableDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> variableDefinition()
	{
		EnterRule_variableDefinition();
		EnterRule("variableDefinition", 27);
		TraceIn("variableDefinition", 27);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA94 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> decl = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifiers92 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDeclarator93 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDeclarator95 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA94_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_variableDeclarator=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_varOrConst=new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
		try { DebugEnterRule(GrammarFileName, "variableDefinition");
		DebugLocation(290, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:291:2: ( modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:291:4: modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi
			{
			DebugLocation(291, 4);
			PushFollow(Follow._modifiers_in_variableDefinition1608);
			modifiers92=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers92.Tree);
			DebugLocation(292, 7);
			PushFollow(Follow._varOrConst_in_variableDefinition1614);
			decl=varOrConst();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varOrConst.Add(decl.Tree);
			DebugLocation(292, 19);
			PushFollow(Follow._variableDeclarator_in_variableDefinition1616);
			variableDeclarator93=variableDeclarator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator93.Tree);
			DebugLocation(293, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:293:3: ( COMMA variableDeclarator )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if ((LA21_0==COMMA))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:293:4: COMMA variableDeclarator
					{
					DebugLocation(293, 4);
					COMMA94=(IToken)Match(input,COMMA,Follow._COMMA_in_variableDefinition1621); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA94);

					DebugLocation(293, 10);
					PushFollow(Follow._variableDeclarator_in_variableDefinition1623);
					variableDeclarator95=variableDeclarator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator95.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(294, 4);
			PushFollow(Follow._semi_in_variableDefinition1631);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: variableDeclarator, decl, modifiers
			// token labels: 
			// rule labels: retval, decl
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);
			RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl",decl!=null?decl.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 295:3: -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ )
			{
				DebugLocation(295, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:295:6: ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(295, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(VARIABLE_DEF, "VARIABLE_DEF"), root_1);

				DebugLocation(295, 21);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(295, 32);
				adaptor.AddChild(root_1, stream_decl.NextTree());
				DebugLocation(295, 37);
				if (!(stream_variableDeclarator.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclarator.HasNext )
				{
					DebugLocation(295, 37);
					adaptor.AddChild(root_1, stream_variableDeclarator.NextTree());

				}
				stream_variableDeclarator.Reset();
				DebugLocation(295, 57);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDefinition", 27);
			LeaveRule("variableDefinition", 27);
			LeaveRule_variableDefinition();
		}
		DebugLocation(296, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDefinition"); }
		return retval;

	}
	// $ANTLR end "variableDefinition"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();

	// $ANTLR start "declaration"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:298:1: declaration : varOrConst variableDeclarator declarationTail -> ^( DECLARATION varOrConst variableDeclarator declarationTail ) ;
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 28);
		TraceIn("declaration", 28);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> varOrConst96 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDeclarator97 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> declarationTail98 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_variableDeclarator=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
		RewriteRuleSubtreeStream stream_declarationTail=new RewriteRuleSubtreeStream(adaptor,"rule declarationTail");
		RewriteRuleSubtreeStream stream_varOrConst=new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(298, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:299:2: ( varOrConst variableDeclarator declarationTail -> ^( DECLARATION varOrConst variableDeclarator declarationTail ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:299:4: varOrConst variableDeclarator declarationTail
			{
			DebugLocation(299, 4);
			PushFollow(Follow._varOrConst_in_declaration1660);
			varOrConst96=varOrConst();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varOrConst.Add(varOrConst96.Tree);
			DebugLocation(299, 15);
			PushFollow(Follow._variableDeclarator_in_declaration1662);
			variableDeclarator97=variableDeclarator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator97.Tree);
			DebugLocation(299, 34);
			PushFollow(Follow._declarationTail_in_declaration1664);
			declarationTail98=declarationTail();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declarationTail.Add(declarationTail98.Tree);


			{
			// AST REWRITE
			// elements: declarationTail, varOrConst, variableDeclarator
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 300:9: -> ^( DECLARATION varOrConst variableDeclarator declarationTail )
			{
				DebugLocation(300, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:300:12: ^( DECLARATION varOrConst variableDeclarator declarationTail )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(300, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(DECLARATION, "DECLARATION"), root_1);

				DebugLocation(300, 26);
				adaptor.AddChild(root_1, stream_varOrConst.NextTree());
				DebugLocation(300, 37);
				adaptor.AddChild(root_1, stream_variableDeclarator.NextTree());
				DebugLocation(300, 56);
				adaptor.AddChild(root_1, stream_declarationTail.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 28);
			LeaveRule("declaration", 28);
			LeaveRule_declaration();
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_varOrConst();
	partial void LeaveRule_varOrConst();

	// $ANTLR start "varOrConst"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:303:1: varOrConst : ( VAR | CONST );
	[GrammarRule("varOrConst")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> varOrConst()
	{
		EnterRule_varOrConst();
		EnterRule("varOrConst", 29);
		TraceIn("varOrConst", 29);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set99 = default(IToken);

		FlyparseTree set99_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "varOrConst");
		DebugLocation(303, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:304:2: ( VAR | CONST )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(304, 2);

			set99=(IToken)input.LT(1);
			if (input.LA(1)==CONST||input.LA(1)==VAR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set99));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varOrConst", 29);
			LeaveRule("varOrConst", 29);
			LeaveRule_varOrConst();
		}
		DebugLocation(305, 1);
		} finally { DebugExitRule(GrammarFileName, "varOrConst"); }
		return retval;

	}
	// $ANTLR end "varOrConst"

	partial void EnterRule_declarationTail();
	partial void LeaveRule_declarationTail();

	// $ANTLR start "declarationTail"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:307:1: declarationTail : ( COMMA variableDeclarator )* ;
	[GrammarRule("declarationTail")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> declarationTail()
	{
		EnterRule_declarationTail();
		EnterRule("declarationTail", 30);
		TraceIn("declarationTail", 30);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA100 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableDeclarator101 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA100_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "declarationTail");
		DebugLocation(307, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:308:2: ( ( COMMA variableDeclarator )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:308:4: ( COMMA variableDeclarator )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(308, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:308:4: ( COMMA variableDeclarator )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==COMMA))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:308:5: COMMA variableDeclarator
					{
					DebugLocation(308, 5);
					COMMA100=(IToken)Match(input,COMMA,Follow._COMMA_in_declarationTail1711); if (state.failed) return retval;
					if (state.backtracking == 0) {
					COMMA100_tree = (FlyparseTree)adaptor.Create(COMMA100);
					adaptor.AddChild(root_0, COMMA100_tree);
					}
					DebugLocation(308, 11);
					PushFollow(Follow._variableDeclarator_in_declarationTail1713);
					variableDeclarator101=variableDeclarator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarator101.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarationTail", 30);
			LeaveRule("declarationTail", 30);
			LeaveRule_declarationTail();
		}
		DebugLocation(309, 1);
		} finally { DebugExitRule(GrammarFileName, "declarationTail"); }
		return retval;

	}
	// $ANTLR end "declarationTail"

	partial void EnterRule_variableInitializer();
	partial void LeaveRule_variableInitializer();

	// $ANTLR start "variableInitializer"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:311:1: variableInitializer : ASSIGN expression -> ^( VAR_INITIALIZER ASSIGN expression ) ;
	[GrammarRule("variableInitializer")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> variableInitializer()
	{
		EnterRule_variableInitializer();
		EnterRule("variableInitializer", 31);
		TraceIn("variableInitializer", 31);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken ASSIGN102 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression103 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree ASSIGN102_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "variableInitializer");
		DebugLocation(311, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:312:2: ( ASSIGN expression -> ^( VAR_INITIALIZER ASSIGN expression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:312:4: ASSIGN expression
			{
			DebugLocation(312, 4);
			ASSIGN102=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableInitializer1726); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN102);

			DebugLocation(312, 11);
			PushFollow(Follow._expression_in_variableInitializer1728);
			expression103=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression103.Tree);


			{
			// AST REWRITE
			// elements: expression, ASSIGN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 313:9: -> ^( VAR_INITIALIZER ASSIGN expression )
			{
				DebugLocation(313, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:313:12: ^( VAR_INITIALIZER ASSIGN expression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(313, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(VAR_INITIALIZER, "VAR_INITIALIZER"), root_1);

				DebugLocation(313, 30);
				adaptor.AddChild(root_1, stream_ASSIGN.NextNode());
				DebugLocation(313, 37);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableInitializer", 31);
			LeaveRule("variableInitializer", 31);
			LeaveRule_variableInitializer();
		}
		DebugLocation(314, 1);
		} finally { DebugExitRule(GrammarFileName, "variableInitializer"); }
		return retval;

	}
	// $ANTLR end "variableInitializer"

	partial void EnterRule_variableDeclarator();
	partial void LeaveRule_variableDeclarator();

	// $ANTLR start "variableDeclarator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:316:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? ) ;
	[GrammarRule("variableDeclarator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> variableDeclarator()
	{
		EnterRule_variableDeclarator();
		EnterRule("variableDeclarator", 32);
		TraceIn("variableDeclarator", 32);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> ident104 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression105 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> variableInitializer106 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_variableInitializer=new RewriteRuleSubtreeStream(adaptor,"rule variableInitializer");
		try { DebugEnterRule(GrammarFileName, "variableDeclarator");
		DebugLocation(316, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:2: ( ident ( typeExpression )? ( variableInitializer )? -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:4: ident ( typeExpression )? ( variableInitializer )?
			{
			DebugLocation(317, 4);
			PushFollow(Follow._ident_in_variableDeclarator1757);
			ident104=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident104.Tree);
			DebugLocation(317, 10);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:10: ( typeExpression )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==COLON))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:10: typeExpression
				{
				DebugLocation(317, 10);
				PushFollow(Follow._typeExpression_in_variableDeclarator1759);
				typeExpression105=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression105.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(317, 26);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:26: ( variableInitializer )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_0 = input.LA(1);

			if ((LA24_0==ASSIGN))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:317:26: variableInitializer
				{
				DebugLocation(317, 26);
				PushFollow(Follow._variableInitializer_in_variableDeclarator1762);
				variableInitializer106=variableInitializer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableInitializer.Add(variableInitializer106.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: typeExpression, variableInitializer, ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 318:9: -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? )
			{
				DebugLocation(318, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:318:12: ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(318, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(VAR_DECLARATION, "VAR_DECLARATION"), root_1);

				DebugLocation(318, 30);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(318, 36);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:318:36: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(318, 36);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(318, 52);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:318:52: ( variableInitializer )?
				if (stream_variableInitializer.HasNext)
				{
					DebugLocation(318, 52);
					adaptor.AddChild(root_1, stream_variableInitializer.NextTree());

				}
				stream_variableInitializer.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarator", 32);
			LeaveRule("variableDeclarator", 32);
			LeaveRule_variableDeclarator();
		}
		DebugLocation(319, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarator"); }
		return retval;

	}
	// $ANTLR end "variableDeclarator"

	partial void EnterRule_parameterDeclarationList();
	partial void LeaveRule_parameterDeclarationList();

	// $ANTLR start "parameterDeclarationList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:324:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN ) ;
	[GrammarRule("parameterDeclarationList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclarationList()
	{
		EnterRule_parameterDeclarationList();
		EnterRule("parameterDeclarationList", 33);
		TraceIn("parameterDeclarationList", 33);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN107 = default(IToken);
		IToken COMMA109 = default(IToken);
		IToken RPAREN111 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclaration108 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclaration110 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN107_tree = default(FlyparseTree);
		FlyparseTree COMMA109_tree = default(FlyparseTree);
		FlyparseTree RPAREN111_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_parameterDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclaration");
		try { DebugEnterRule(GrammarFileName, "parameterDeclarationList");
		DebugLocation(324, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:325:2: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:325:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
			{
			DebugLocation(325, 4);
			LPAREN107=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parameterDeclarationList1799); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN107);

			DebugLocation(326, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:326:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==AS||LA26_0==CONST||LA26_0==DYNAMIC||LA26_0==GET||LA26_0==IDENT||LA26_0==IS||LA26_0==NAMESPACE||LA26_0==REST||LA26_0==SET||LA26_0==SUPER||LA26_0==USE||LA26_0==XML))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:326:5: parameterDeclaration ( COMMA parameterDeclaration )*
				{
				DebugLocation(326, 5);
				PushFollow(Follow._parameterDeclaration_in_parameterDeclarationList1805);
				parameterDeclaration108=parameterDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration108.Tree);
				DebugLocation(327, 4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:327:4: ( COMMA parameterDeclaration )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_0 = input.LA(1);

					if ((LA25_0==COMMA))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:327:5: COMMA parameterDeclaration
						{
						DebugLocation(327, 5);
						COMMA109=(IToken)Match(input,COMMA,Follow._COMMA_in_parameterDeclarationList1811); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA109);

						DebugLocation(327, 11);
						PushFollow(Follow._parameterDeclaration_in_parameterDeclarationList1813);
						parameterDeclaration110=parameterDeclaration();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration110.Tree);

						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }


				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(329, 3);
			RPAREN111=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parameterDeclarationList1824); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN111);



			{
			// AST REWRITE
			// elements: RPAREN, LPAREN, parameterDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 330:3: -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN )
			{
				DebugLocation(330, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:330:6: ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(330, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PARAMS, "PARAMS"), root_1);

				DebugLocation(330, 15);
				adaptor.AddChild(root_1, stream_LPAREN.NextNode());
				DebugLocation(330, 22);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:330:22: ( parameterDeclaration )*
				while ( stream_parameterDeclaration.HasNext )
				{
					DebugLocation(330, 22);
					adaptor.AddChild(root_1, stream_parameterDeclaration.NextTree());

				}
				stream_parameterDeclaration.Reset();
				DebugLocation(330, 44);
				adaptor.AddChild(root_1, stream_RPAREN.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDeclarationList", 33);
			LeaveRule("parameterDeclarationList", 33);
			LeaveRule_parameterDeclarationList();
		}
		DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDeclarationList"); }
		return retval;

	}
	// $ANTLR end "parameterDeclarationList"

	partial void EnterRule_parameterDeclaration();
	partial void LeaveRule_parameterDeclaration();

	// $ANTLR start "parameterDeclaration"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:334:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
	[GrammarRule("parameterDeclaration")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclaration()
	{
		EnterRule_parameterDeclaration();
		EnterRule("parameterDeclaration", 34);
		TraceIn("parameterDeclaration", 34);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> basicParameterDeclaration112 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterRestDeclaration113 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "parameterDeclaration");
		DebugLocation(334, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:335:2: ( basicParameterDeclaration | parameterRestDeclaration )
			int alt27=2;
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==AS||LA27_0==CONST||LA27_0==DYNAMIC||LA27_0==GET||LA27_0==IDENT||LA27_0==IS||LA27_0==NAMESPACE||LA27_0==SET||LA27_0==SUPER||LA27_0==USE||LA27_0==XML))
			{
				alt27 = 1;
			}
			else if ((LA27_0==REST))
			{
				alt27 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 27, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:335:4: basicParameterDeclaration
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(335, 4);
				PushFollow(Follow._basicParameterDeclaration_in_parameterDeclaration1851);
				basicParameterDeclaration112=basicParameterDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicParameterDeclaration112.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:335:32: parameterRestDeclaration
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(335, 32);
				PushFollow(Follow._parameterRestDeclaration_in_parameterDeclaration1855);
				parameterRestDeclaration113=parameterRestDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parameterRestDeclaration113.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDeclaration", 34);
			LeaveRule("parameterDeclaration", 34);
			LeaveRule_parameterDeclaration();
		}
		DebugLocation(336, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDeclaration"); }
		return retval;

	}
	// $ANTLR end "parameterDeclaration"

	partial void EnterRule_basicParameterDeclaration();
	partial void LeaveRule_basicParameterDeclaration();

	// $ANTLR start "basicParameterDeclaration"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:338:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
	[GrammarRule("basicParameterDeclaration")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> basicParameterDeclaration()
	{
		EnterRule_basicParameterDeclaration();
		EnterRule("basicParameterDeclaration", 35);
		TraceIn("basicParameterDeclaration", 35);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken CONST114 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident115 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression116 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterDefault117 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree CONST114_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_CONST=new RewriteRuleITokenStream(adaptor,"token CONST");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_parameterDefault=new RewriteRuleSubtreeStream(adaptor,"rule parameterDefault");
		try { DebugEnterRule(GrammarFileName, "basicParameterDeclaration");
		DebugLocation(338, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:2: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
			{
			DebugLocation(339, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:4: ( CONST )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_0 = input.LA(1);

			if ((LA28_0==CONST))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:4: CONST
				{
				DebugLocation(339, 4);
				CONST114=(IToken)Match(input,CONST,Follow._CONST_in_basicParameterDeclaration1866); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONST.Add(CONST114);


				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(339, 11);
			PushFollow(Follow._ident_in_basicParameterDeclaration1869);
			ident115=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident115.Tree);
			DebugLocation(339, 17);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:17: ( typeExpression )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==COLON))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:17: typeExpression
				{
				DebugLocation(339, 17);
				PushFollow(Follow._typeExpression_in_basicParameterDeclaration1871);
				typeExpression116=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression116.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(339, 33);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:33: ( parameterDefault )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_0 = input.LA(1);

			if ((LA30_0==ASSIGN))
			{
				alt30 = 1;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:339:33: parameterDefault
				{
				DebugLocation(339, 33);
				PushFollow(Follow._parameterDefault_in_basicParameterDeclaration1874);
				parameterDefault117=parameterDefault();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterDefault.Add(parameterDefault117.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(30); }



			{
			// AST REWRITE
			// elements: parameterDefault, typeExpression, CONST, ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 340:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
			{
				DebugLocation(340, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:340:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(340, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(340, 14);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:340:14: ( CONST )?
				if (stream_CONST.HasNext)
				{
					DebugLocation(340, 14);
					adaptor.AddChild(root_1, stream_CONST.NextNode());

				}
				stream_CONST.Reset();
				DebugLocation(340, 21);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(340, 27);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:340:27: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(340, 27);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(340, 43);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:340:43: ( parameterDefault )?
				if (stream_parameterDefault.HasNext)
				{
					DebugLocation(340, 43);
					adaptor.AddChild(root_1, stream_parameterDefault.NextTree());

				}
				stream_parameterDefault.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("basicParameterDeclaration", 35);
			LeaveRule("basicParameterDeclaration", 35);
			LeaveRule_basicParameterDeclaration();
		}
		DebugLocation(341, 1);
		} finally { DebugExitRule(GrammarFileName, "basicParameterDeclaration"); }
		return retval;

	}
	// $ANTLR end "basicParameterDeclaration"

	partial void EnterRule_parameterDefault();
	partial void LeaveRule_parameterDefault();

	// $ANTLR start "parameterDefault"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:343:1: parameterDefault : ASSIGN assignmentExpression ;
	[GrammarRule("parameterDefault")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> parameterDefault()
	{
		EnterRule_parameterDefault();
		EnterRule("parameterDefault", 36);
		TraceIn("parameterDefault", 36);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken ASSIGN118 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression119 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree ASSIGN118_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "parameterDefault");
		DebugLocation(343, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:345:2: ( ASSIGN assignmentExpression )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:345:4: ASSIGN assignmentExpression
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(345, 4);
			ASSIGN118=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parameterDefault1908); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN118_tree = (FlyparseTree)adaptor.Create(ASSIGN118);
			adaptor.AddChild(root_0, ASSIGN118_tree);
			}
			DebugLocation(345, 11);
			PushFollow(Follow._assignmentExpression_in_parameterDefault1910);
			assignmentExpression119=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression119.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDefault", 36);
			LeaveRule("parameterDefault", 36);
			LeaveRule_parameterDefault();
		}
		DebugLocation(346, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDefault"); }
		return retval;

	}
	// $ANTLR end "parameterDefault"

	partial void EnterRule_parameterRestDeclaration();
	partial void LeaveRule_parameterRestDeclaration();

	// $ANTLR start "parameterRestDeclaration"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:348:1: parameterRestDeclaration : REST ( ident )? ( typeExpression )? -> ^( PARAM REST ( ident )? ( typeExpression )? ) ;
	[GrammarRule("parameterRestDeclaration")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> parameterRestDeclaration()
	{
		EnterRule_parameterRestDeclaration();
		EnterRule("parameterRestDeclaration", 37);
		TraceIn("parameterRestDeclaration", 37);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken REST120 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident121 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression122 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree REST120_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_REST=new RewriteRuleITokenStream(adaptor,"token REST");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		try { DebugEnterRule(GrammarFileName, "parameterRestDeclaration");
		DebugLocation(348, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:2: ( REST ( ident )? ( typeExpression )? -> ^( PARAM REST ( ident )? ( typeExpression )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:4: REST ( ident )? ( typeExpression )?
			{
			DebugLocation(349, 4);
			REST120=(IToken)Match(input,REST,Follow._REST_in_parameterRestDeclaration1921); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REST.Add(REST120);

			DebugLocation(349, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:9: ( ident )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_0 = input.LA(1);

			if ((LA31_0==AS||LA31_0==DYNAMIC||LA31_0==GET||LA31_0==IDENT||LA31_0==IS||LA31_0==NAMESPACE||LA31_0==SET||LA31_0==SUPER||LA31_0==USE||LA31_0==XML))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:9: ident
				{
				DebugLocation(349, 9);
				PushFollow(Follow._ident_in_parameterRestDeclaration1923);
				ident121=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident121.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(349, 16);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:16: ( typeExpression )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_0 = input.LA(1);

			if ((LA32_0==COLON))
			{
				alt32 = 1;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:349:16: typeExpression
				{
				DebugLocation(349, 16);
				PushFollow(Follow._typeExpression_in_parameterRestDeclaration1926);
				typeExpression122=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression122.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(32); }



			{
			// AST REWRITE
			// elements: ident, REST, typeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 350:3: -> ^( PARAM REST ( ident )? ( typeExpression )? )
			{
				DebugLocation(350, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:350:6: ^( PARAM REST ( ident )? ( typeExpression )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(350, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(350, 14);
				adaptor.AddChild(root_1, stream_REST.NextNode());
				DebugLocation(350, 19);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:350:19: ( ident )?
				if (stream_ident.HasNext)
				{
					DebugLocation(350, 19);
					adaptor.AddChild(root_1, stream_ident.NextTree());

				}
				stream_ident.Reset();
				DebugLocation(350, 26);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:350:26: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(350, 26);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterRestDeclaration", 37);
			LeaveRule("parameterRestDeclaration", 37);
			LeaveRule_parameterRestDeclaration();
		}
		DebugLocation(351, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterRestDeclaration"); }
		return retval;

	}
	// $ANTLR end "parameterRestDeclaration"

	partial void EnterRule_block();
	partial void LeaveRule_block();

	// $ANTLR start "block"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:352:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK LCURLY ( blockEntry )* RCURLY ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 38);
		TraceIn("block", 38);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LCURLY123 = default(IToken);
		IToken RCURLY125 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> blockEntry124 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LCURLY123_tree = default(FlyparseTree);
		FlyparseTree RCURLY125_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_blockEntry=new RewriteRuleSubtreeStream(adaptor,"rule blockEntry");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(352, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:353:2: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK LCURLY ( blockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:353:4: LCURLY ( blockEntry )* RCURLY
			{
			DebugLocation(353, 4);
			LCURLY123=(IToken)Match(input,LCURLY,Follow._LCURLY_in_block1953); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY123);

			DebugLocation(353, 11);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:353:11: ( blockEntry )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_0 = input.LA(1);

				if ((LA33_0==AS||LA33_0==BNOT||LA33_0==BREAK||LA33_0==CONST||LA33_0==CONTINUE||(LA33_0>=DEC && LA33_0<=DECIMAL_LITERAL)||LA33_0==DEFAULT||LA33_0==DO||(LA33_0>=DYNAMIC && LA33_0<=E4X_ATTRI)||(LA33_0>=FALSE && LA33_0<=FOR)||LA33_0==FUNCTION||LA33_0==GET||(LA33_0>=HEX_LITERAL && LA33_0<=IDENT)||LA33_0==IF||LA33_0==INC||(LA33_0>=INTERNAL && LA33_0<=IS)||(LA33_0>=LBRACK && LA33_0<=LCURLY)||LA33_0==LNOT||LA33_0==LPAREN||LA33_0==MINUS||LA33_0==NAMESPACE||LA33_0==NEW||LA33_0==NULL||LA33_0==OCTAL_LITERAL||LA33_0==PLUS||LA33_0==PRIVATE||(LA33_0>=PROTECTED && LA33_0<=PUBLIC)||LA33_0==REGEX_LITERAL||LA33_0==RETURN||(LA33_0>=SEMI && LA33_0<=SET)||(LA33_0>=STRING_LITERAL_DOUBLE && LA33_0<=SWITCH)||LA33_0==TRUE||(LA33_0>=USE && LA33_0<=VAR)||LA33_0==WHILE||LA33_0==WITH||LA33_0==XML||LA33_0==XML_LITERAL||LA33_0==243||(LA33_0>=253 && LA33_0<=257)))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:353:11: blockEntry
					{
					DebugLocation(353, 11);
					PushFollow(Follow._blockEntry_in_block1955);
					blockEntry124=blockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_blockEntry.Add(blockEntry124.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }

			DebugLocation(353, 23);
			RCURLY125=(IToken)Match(input,RCURLY,Follow._RCURLY_in_block1958); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY125);



			{
			// AST REWRITE
			// elements: LCURLY, RCURLY, blockEntry
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 354:3: -> ^( BLOCK LCURLY ( blockEntry )* RCURLY )
			{
				DebugLocation(354, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:354:6: ^( BLOCK LCURLY ( blockEntry )* RCURLY )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(354, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(354, 14);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(354, 21);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:354:21: ( blockEntry )*
				while ( stream_blockEntry.HasNext )
				{
					DebugLocation(354, 21);
					adaptor.AddChild(root_1, stream_blockEntry.NextTree());

				}
				stream_blockEntry.Reset();
				DebugLocation(354, 33);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 38);
			LeaveRule("block", 38);
			LeaveRule_block();
		}
		DebugLocation(355, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_blockEntry();
	partial void LeaveRule_blockEntry();

	// $ANTLR start "blockEntry"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:357:1: blockEntry : statement ;
	[GrammarRule("blockEntry")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> blockEntry()
	{
		EnterRule_blockEntry();
		EnterRule("blockEntry", 39);
		TraceIn("blockEntry", 39);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> statement126 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "blockEntry");
		DebugLocation(357, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:358:2: ( statement )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:358:4: statement
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(358, 4);
			PushFollow(Follow._statement_in_blockEntry1984);
			statement126=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement126.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockEntry", 39);
			LeaveRule("blockEntry", 39);
			LeaveRule_blockEntry();
		}
		DebugLocation(359, 1);
		} finally { DebugExitRule(GrammarFileName, "blockEntry"); }
		return retval;

	}
	// $ANTLR end "blockEntry"

	partial void EnterRule_condition();
	partial void LeaveRule_condition();

	// $ANTLR start "condition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:361:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
	[GrammarRule("condition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> condition()
	{
		EnterRule_condition();
		EnterRule("condition", 40);
		TraceIn("condition", 40);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN127 = default(IToken);
		IToken RPAREN129 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression128 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN127_tree = default(FlyparseTree);
		FlyparseTree RPAREN129_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "condition");
		DebugLocation(361, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:362:2: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:362:4: LPAREN expression RPAREN
			{
			DebugLocation(362, 4);
			LPAREN127=(IToken)Match(input,LPAREN,Follow._LPAREN_in_condition1995); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN127);

			DebugLocation(362, 11);
			PushFollow(Follow._expression_in_condition1997);
			expression128=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression128.Tree);
			DebugLocation(362, 22);
			RPAREN129=(IToken)Match(input,RPAREN,Follow._RPAREN_in_condition1999); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN129);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 363:3: -> ^( CONDITION expression )
			{
				DebugLocation(363, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:363:6: ^( CONDITION expression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(363, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CONDITION, "CONDITION"), root_1);

				DebugLocation(363, 18);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condition", 40);
			LeaveRule("condition", 40);
			LeaveRule_condition();
		}
		DebugLocation(364, 1);
		} finally { DebugExitRule(GrammarFileName, "condition"); }
		return retval;

	}
	// $ANTLR end "condition"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();

	// $ANTLR start "statement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:366:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | semi );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 41);
		TraceIn("statement", 41);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> block130 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> declarationStatement131 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expressionStatement132 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ifStatement133 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> forEachStatement134 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> whileStatement135 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> doWhileStatement136 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> withStatement137 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> switchStatement138 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> breakStatement139 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> continueStatement140 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> returnStatement141 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> throwStatement142 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> tryStatement143 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> defaultXMLNamespaceStatement144 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi145 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(366, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:367:2: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | semi )
			int alt34=16;
			try { DebugEnterDecision(34, false);
			switch (input.LA(1))
			{
			case LCURLY:
				{
				int LA34_1 = input.LA(2);

				if ((EvaluatePredicate(synpred13_AS3_fragment)))
				{
					alt34 = 1;
				}
				else if ((true))
				{
					alt34 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CONST:
			case VAR:
				{
				alt34 = 2;
				}
				break;
			case AS:
			case BNOT:
			case DEC:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INC:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LNOT:
			case LPAREN:
			case MINUS:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PLUS:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 243:
			case 255:
			case 256:
			case 257:
				{
				alt34 = 3;
				}
				break;
			case IF:
				{
				alt34 = 4;
				}
				break;
			case FOR:
				{
				alt34 = 5;
				}
				break;
			case WHILE:
				{
				alt34 = 6;
				}
				break;
			case DO:
				{
				alt34 = 7;
				}
				break;
			case WITH:
				{
				alt34 = 8;
				}
				break;
			case SWITCH:
				{
				alt34 = 9;
				}
				break;
			case BREAK:
				{
				alt34 = 10;
				}
				break;
			case CONTINUE:
				{
				alt34 = 11;
				}
				break;
			case RETURN:
				{
				alt34 = 12;
				}
				break;
			case 253:
				{
				alt34 = 13;
				}
				break;
			case 254:
				{
				alt34 = 14;
				}
				break;
			case DEFAULT:
				{
				alt34 = 15;
				}
				break;
			case SEMI:
				{
				alt34 = 16;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:367:4: ( LCURLY )=> block
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(367, 16);
				PushFollow(Follow._block_in_statement2026);
				block130=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block130.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:369:4: declarationStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(369, 4);
				PushFollow(Follow._declarationStatement_in_statement2032);
				declarationStatement131=declarationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declarationStatement131.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:371:4: expressionStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(371, 4);
				PushFollow(Follow._expressionStatement_in_statement2039);
				expressionStatement132=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement132.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:373:4: ifStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(373, 4);
				PushFollow(Follow._ifStatement_in_statement2045);
				ifStatement133=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement133.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:375:4: forEachStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(375, 4);
				PushFollow(Follow._forEachStatement_in_statement2051);
				forEachStatement134=forEachStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forEachStatement134.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:377:4: whileStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(377, 4);
				PushFollow(Follow._whileStatement_in_statement2057);
				whileStatement135=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement135.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:379:4: doWhileStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(379, 4);
				PushFollow(Follow._doWhileStatement_in_statement2063);
				doWhileStatement136=doWhileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement136.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:381:4: withStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(381, 4);
				PushFollow(Follow._withStatement_in_statement2070);
				withStatement137=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement137.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:383:4: switchStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(383, 4);
				PushFollow(Follow._switchStatement_in_statement2077);
				switchStatement138=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement138.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:385:4: breakStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(385, 4);
				PushFollow(Follow._breakStatement_in_statement2084);
				breakStatement139=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement139.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:387:4: continueStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(387, 4);
				PushFollow(Follow._continueStatement_in_statement2090);
				continueStatement140=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement140.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:389:4: returnStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(389, 4);
				PushFollow(Follow._returnStatement_in_statement2096);
				returnStatement141=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement141.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:391:4: throwStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(391, 4);
				PushFollow(Follow._throwStatement_in_statement2102);
				throwStatement142=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement142.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:393:4: tryStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(393, 4);
				PushFollow(Follow._tryStatement_in_statement2109);
				tryStatement143=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement143.Tree);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:395:4: defaultXMLNamespaceStatement
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(395, 4);
				PushFollow(Follow._defaultXMLNamespaceStatement_in_statement2116);
				defaultXMLNamespaceStatement144=defaultXMLNamespaceStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultXMLNamespaceStatement144.Tree);

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:397:9: semi
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(397, 9);
				PushFollow(Follow._semi_in_statement2131);
				semi145=semi();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, semi145.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 41);
			LeaveRule("statement", 41);
			LeaveRule_statement();
		}
		DebugLocation(399, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_declarationStatement();
	partial void LeaveRule_declarationStatement();

	// $ANTLR start "declarationStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:401:1: declarationStatement : declaration s= semi -> ^( DECL_STMT declaration ) ;
	[GrammarRule("declarationStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> declarationStatement()
	{
		EnterRule_declarationStatement();
		EnterRule("declarationStatement", 42);
		TraceIn("declarationStatement", 42);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> declaration146 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "declarationStatement");
		DebugLocation(401, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:402:2: ( declaration s= semi -> ^( DECL_STMT declaration ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:402:4: declaration s= semi
			{
			DebugLocation(402, 4);
			PushFollow(Follow._declaration_in_declarationStatement2147);
			declaration146=declaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration.Add(declaration146.Tree);
			DebugLocation(402, 17);
			PushFollow(Follow._semi_in_declarationStatement2151);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 403:7: -> ^( DECL_STMT declaration )
			{
				DebugLocation(403, 10);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:403:10: ^( DECL_STMT declaration )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(403, 12);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(DECL_STMT, "DECL_STMT"), root_1);

				DebugLocation(403, 22);
				adaptor.AddChild(root_1, stream_declaration.NextTree());
				DebugLocation(403, 34);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarationStatement", 42);
			LeaveRule("declarationStatement", 42);
			LeaveRule_declarationStatement();
		}
		DebugLocation(404, 1);
		} finally { DebugExitRule(GrammarFileName, "declarationStatement"); }
		return retval;

	}
	// $ANTLR end "declarationStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();

	// $ANTLR start "expressionStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:406:1: expressionStatement : expressionList s= semi -> ^( EXPR_STMNT expressionList ) ;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 43);
		TraceIn("expressionStatement", 43);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList147 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(406, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:407:2: ( expressionList s= semi -> ^( EXPR_STMNT expressionList ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:407:4: expressionList s= semi
			{
			DebugLocation(407, 4);
			PushFollow(Follow._expressionList_in_expressionStatement2178);
			expressionList147=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expressionList.Add(expressionList147.Tree);
			DebugLocation(407, 20);
			PushFollow(Follow._semi_in_expressionStatement2182);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 408:3: -> ^( EXPR_STMNT expressionList )
			{
				DebugLocation(408, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:408:6: ^( EXPR_STMNT expressionList )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(408, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);

				DebugLocation(408, 19);
				adaptor.AddChild(root_1, stream_expressionList.NextTree());
				DebugLocation(408, 34);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 43);
			LeaveRule("expressionStatement", 43);
			LeaveRule_expressionStatement();
		}
		DebugLocation(409, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();

	// $ANTLR start "ifStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:412:1: ifStatement : IF condition statement ( ( ELSE )=> elseClause )? -> ^( IF_STMT IF condition statement ( elseClause )? ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 44);
		TraceIn("ifStatement", 44);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IF148 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> condition149 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement150 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> elseClause151 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree IF148_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_elseClause=new RewriteRuleSubtreeStream(adaptor,"rule elseClause");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(412, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:413:2: ( IF condition statement ( ( ELSE )=> elseClause )? -> ^( IF_STMT IF condition statement ( elseClause )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:413:4: IF condition statement ( ( ELSE )=> elseClause )?
			{
			DebugLocation(413, 4);
			IF148=(IToken)Match(input,IF,Follow._IF_in_ifStatement2206); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF148);

			DebugLocation(413, 7);
			PushFollow(Follow._condition_in_ifStatement2208);
			condition149=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition149.Tree);
			DebugLocation(413, 17);
			PushFollow(Follow._statement_in_ifStatement2210);
			statement150=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement150.Tree);
			DebugLocation(414, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:414:3: ( ( ELSE )=> elseClause )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_0 = input.LA(1);

			if ((LA35_0==ELSE))
			{
				int LA35_1 = input.LA(2);

				if ((EvaluatePredicate(synpred14_AS3_fragment)))
				{
					alt35 = 1;
				}
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:414:4: ( ELSE )=> elseClause
				{
				DebugLocation(414, 12);
				PushFollow(Follow._elseClause_in_ifStatement2219);
				elseClause151=elseClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_elseClause.Add(elseClause151.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: elseClause, IF, statement, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 415:9: -> ^( IF_STMT IF condition statement ( elseClause )? )
			{
				DebugLocation(415, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:415:12: ^( IF_STMT IF condition statement ( elseClause )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(415, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(IF_STMT, "IF_STMT"), root_1);

				DebugLocation(415, 22);
				adaptor.AddChild(root_1, stream_IF.NextNode());
				DebugLocation(415, 25);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(415, 35);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(415, 45);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:415:45: ( elseClause )?
				if (stream_elseClause.HasNext)
				{
					DebugLocation(415, 45);
					adaptor.AddChild(root_1, stream_elseClause.NextTree());

				}
				stream_elseClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 44);
			LeaveRule("ifStatement", 44);
			LeaveRule_ifStatement();
		}
		DebugLocation(416, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_elseClause();
	partial void LeaveRule_elseClause();

	// $ANTLR start "elseClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:418:1: elseClause : ELSE statement -> ^( ELSE_CLAUSE ELSE statement ) ;
	[GrammarRule("elseClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> elseClause()
	{
		EnterRule_elseClause();
		EnterRule("elseClause", 45);
		TraceIn("elseClause", 45);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken ELSE152 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement153 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree ELSE152_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "elseClause");
		DebugLocation(418, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:419:2: ( ELSE statement -> ^( ELSE_CLAUSE ELSE statement ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:419:4: ELSE statement
			{
			DebugLocation(419, 4);
			ELSE152=(IToken)Match(input,ELSE,Follow._ELSE_in_elseClause2255); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSE.Add(ELSE152);

			DebugLocation(419, 9);
			PushFollow(Follow._statement_in_elseClause2257);
			statement153=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement153.Tree);


			{
			// AST REWRITE
			// elements: ELSE, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 420:9: -> ^( ELSE_CLAUSE ELSE statement )
			{
				DebugLocation(420, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:420:12: ^( ELSE_CLAUSE ELSE statement )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(420, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ELSE_CLAUSE, "ELSE_CLAUSE"), root_1);

				DebugLocation(420, 26);
				adaptor.AddChild(root_1, stream_ELSE.NextNode());
				DebugLocation(420, 31);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseClause", 45);
			LeaveRule("elseClause", 45);
			LeaveRule_elseClause();
		}
		DebugLocation(421, 1);
		} finally { DebugExitRule(GrammarFileName, "elseClause"); }
		return retval;

	}
	// $ANTLR end "elseClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();

	// $ANTLR start "throwStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:423:1: throwStatement : 'throw' expression s= semi -> ^( THROW_STATEMENT 'throw' expression ) ;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 46);
		TraceIn("throwStatement", 46);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal154 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression155 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal154_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_253=new RewriteRuleITokenStream(adaptor,"token 253");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(423, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:424:2: ( 'throw' expression s= semi -> ^( THROW_STATEMENT 'throw' expression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:424:4: 'throw' expression s= semi
			{
			DebugLocation(424, 4);
			string_literal154=(IToken)Match(input,253,Follow._253_in_throwStatement2287); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_253.Add(string_literal154);

			DebugLocation(424, 12);
			PushFollow(Follow._expression_in_throwStatement2289);
			expression155=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression155.Tree);
			DebugLocation(424, 24);
			PushFollow(Follow._semi_in_throwStatement2293);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: expression, 253
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 425:9: -> ^( THROW_STATEMENT 'throw' expression )
			{
				DebugLocation(425, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:425:12: ^( THROW_STATEMENT 'throw' expression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(425, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(THROW_STATEMENT, "THROW_STATEMENT"), root_1);

				DebugLocation(425, 30);
				adaptor.AddChild(root_1, stream_253.NextNode());
				DebugLocation(425, 38);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(425, 49);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 46);
			LeaveRule("throwStatement", 46);
			LeaveRule_throwStatement();
		}
		DebugLocation(426, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();

	// $ANTLR start "tryStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:428:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 47);
		TraceIn("tryStatement", 47);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal156 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> block157 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> catchBlock158 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> finallyBlock159 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal156_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_254=new RewriteRuleITokenStream(adaptor,"token 254");
		RewriteRuleSubtreeStream stream_catchBlock=new RewriteRuleSubtreeStream(adaptor,"rule catchBlock");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_finallyBlock=new RewriteRuleSubtreeStream(adaptor,"rule finallyBlock");
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(428, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:429:2: ( 'try' block ( catchBlock )* ( finallyBlock )? -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:429:4: 'try' block ( catchBlock )* ( finallyBlock )?
			{
			DebugLocation(429, 4);
			string_literal156=(IToken)Match(input,254,Follow._254_in_tryStatement2324); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_254.Add(string_literal156);

			DebugLocation(430, 3);
			PushFollow(Follow._block_in_tryStatement2328);
			block157=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(block157.Tree);
			DebugLocation(431, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:431:3: ( catchBlock )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_0 = input.LA(1);

				if ((LA36_0==242))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:431:3: catchBlock
					{
					DebugLocation(431, 3);
					PushFollow(Follow._catchBlock_in_tryStatement2332);
					catchBlock158=catchBlock();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_catchBlock.Add(catchBlock158.Tree);

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(432, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:432:3: ( finallyBlock )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_0 = input.LA(1);

			if ((LA37_0==247))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:432:3: finallyBlock
				{
				DebugLocation(432, 3);
				PushFollow(Follow._finallyBlock_in_tryStatement2337);
				finallyBlock159=finallyBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_finallyBlock.Add(finallyBlock159.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }



			{
			// AST REWRITE
			// elements: catchBlock, block, finallyBlock, 254
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 433:9: -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? )
			{
				DebugLocation(433, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:433:12: ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(433, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(TRY_STATEMENT, "TRY_STATEMENT"), root_1);

				DebugLocation(433, 28);
				adaptor.AddChild(root_1, stream_254.NextNode());
				DebugLocation(433, 34);
				adaptor.AddChild(root_1, stream_block.NextTree());
				DebugLocation(433, 40);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:433:40: ( catchBlock )*
				while ( stream_catchBlock.HasNext )
				{
					DebugLocation(433, 40);
					adaptor.AddChild(root_1, stream_catchBlock.NextTree());

				}
				stream_catchBlock.Reset();
				DebugLocation(433, 52);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:433:52: ( finallyBlock )?
				if (stream_finallyBlock.HasNext)
				{
					DebugLocation(433, 52);
					adaptor.AddChild(root_1, stream_finallyBlock.NextTree());

				}
				stream_finallyBlock.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 47);
			LeaveRule("tryStatement", 47);
			LeaveRule_tryStatement();
		}
		DebugLocation(434, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchBlock();
	partial void LeaveRule_catchBlock();

	// $ANTLR start "catchBlock"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:436:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
	[GrammarRule("catchBlock")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> catchBlock()
	{
		EnterRule_catchBlock();
		EnterRule("catchBlock", 48);
		TraceIn("catchBlock", 48);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal160 = default(IToken);
		IToken LPAREN161 = default(IToken);
		IToken RPAREN164 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident162 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression163 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> block165 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal160_tree = default(FlyparseTree);
		FlyparseTree LPAREN161_tree = default(FlyparseTree);
		FlyparseTree RPAREN164_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "catchBlock");
		DebugLocation(436, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:437:2: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:437:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(437, 4);
			string_literal160=(IToken)Match(input,242,Follow._242_in_catchBlock2373); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal160_tree = (FlyparseTree)adaptor.Create(string_literal160);
			adaptor.AddChild(root_0, string_literal160_tree);
			}
			DebugLocation(437, 12);
			LPAREN161=(IToken)Match(input,LPAREN,Follow._LPAREN_in_catchBlock2375); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN161_tree = (FlyparseTree)adaptor.Create(LPAREN161);
			adaptor.AddChild(root_0, LPAREN161_tree);
			}
			DebugLocation(437, 19);
			PushFollow(Follow._ident_in_catchBlock2377);
			ident162=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident162.Tree);
			DebugLocation(437, 25);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:437:25: ( typeExpression )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_0 = input.LA(1);

			if ((LA38_0==COLON))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:437:25: typeExpression
				{
				DebugLocation(437, 25);
				PushFollow(Follow._typeExpression_in_catchBlock2379);
				typeExpression163=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeExpression163.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(437, 41);
			RPAREN164=(IToken)Match(input,RPAREN,Follow._RPAREN_in_catchBlock2382); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RPAREN164_tree = (FlyparseTree)adaptor.Create(RPAREN164);
			adaptor.AddChild(root_0, RPAREN164_tree);
			}
			DebugLocation(438, 3);
			PushFollow(Follow._block_in_catchBlock2386);
			block165=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block165.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchBlock", 48);
			LeaveRule("catchBlock", 48);
			LeaveRule_catchBlock();
		}
		DebugLocation(439, 1);
		} finally { DebugExitRule(GrammarFileName, "catchBlock"); }
		return retval;

	}
	// $ANTLR end "catchBlock"

	partial void EnterRule_finallyBlock();
	partial void LeaveRule_finallyBlock();

	// $ANTLR start "finallyBlock"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:441:1: finallyBlock : 'finally' block ;
	[GrammarRule("finallyBlock")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> finallyBlock()
	{
		EnterRule_finallyBlock();
		EnterRule("finallyBlock", 49);
		TraceIn("finallyBlock", 49);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal166 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> block167 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal166_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "finallyBlock");
		DebugLocation(441, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:442:2: ( 'finally' block )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:442:4: 'finally' block
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(442, 4);
			string_literal166=(IToken)Match(input,247,Follow._247_in_finallyBlock2397); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal166_tree = (FlyparseTree)adaptor.Create(string_literal166);
			adaptor.AddChild(root_0, string_literal166_tree);
			}
			DebugLocation(442, 14);
			PushFollow(Follow._block_in_finallyBlock2399);
			block167=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block167.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyBlock", 49);
			LeaveRule("finallyBlock", 49);
			LeaveRule_finallyBlock();
		}
		DebugLocation(443, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyBlock"); }
		return retval;

	}
	// $ANTLR end "finallyBlock"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();

	// $ANTLR start "returnStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:445:1: returnStatement : RETURN ( expression )? s= semi -> ^( RETURN_STATEMENT RETURN ( expression )? ) ;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 50);
		TraceIn("returnStatement", 50);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken RETURN168 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression169 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree RETURN168_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(445, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:446:2: ( RETURN ( expression )? s= semi -> ^( RETURN_STATEMENT RETURN ( expression )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:446:4: RETURN ( expression )? s= semi
			{
			DebugLocation(446, 4);
			RETURN168=(IToken)Match(input,RETURN,Follow._RETURN_in_returnStatement2410); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RETURN.Add(RETURN168);

			DebugLocation(446, 11);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:446:11: ( expression )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_0 = input.LA(1);

			if ((LA39_0==AS||LA39_0==BNOT||(LA39_0>=DEC && LA39_0<=DECIMAL_LITERAL)||(LA39_0>=DYNAMIC && LA39_0<=E4X_ATTRI)||(LA39_0>=FALSE && LA39_0<=FLOAT_LITERAL)||LA39_0==FUNCTION||LA39_0==GET||(LA39_0>=HEX_LITERAL && LA39_0<=IDENT)||LA39_0==INC||(LA39_0>=INTERNAL && LA39_0<=IS)||(LA39_0>=LBRACK && LA39_0<=LCURLY)||LA39_0==LNOT||LA39_0==LPAREN||LA39_0==MINUS||LA39_0==NAMESPACE||LA39_0==NEW||LA39_0==NULL||LA39_0==OCTAL_LITERAL||LA39_0==PLUS||LA39_0==PRIVATE||(LA39_0>=PROTECTED && LA39_0<=PUBLIC)||LA39_0==REGEX_LITERAL||LA39_0==SET||(LA39_0>=STRING_LITERAL_DOUBLE && LA39_0<=SUPER)||LA39_0==TRUE||LA39_0==USE||LA39_0==XML||LA39_0==XML_LITERAL||LA39_0==243||(LA39_0>=255 && LA39_0<=257)))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:446:11: expression
				{
				DebugLocation(446, 11);
				PushFollow(Follow._expression_in_returnStatement2412);
				expression169=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression169.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }

			DebugLocation(446, 24);
			PushFollow(Follow._semi_in_returnStatement2417);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: expression, RETURN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 447:9: -> ^( RETURN_STATEMENT RETURN ( expression )? )
			{
				DebugLocation(447, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:447:12: ^( RETURN_STATEMENT RETURN ( expression )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(447, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(RETURN_STATEMENT, "RETURN_STATEMENT"), root_1);

				DebugLocation(447, 31);
				adaptor.AddChild(root_1, stream_RETURN.NextNode());
				DebugLocation(447, 38);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:447:38: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(447, 38);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();
				DebugLocation(447, 50);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 50);
			LeaveRule("returnStatement", 50);
			LeaveRule_returnStatement();
		}
		DebugLocation(448, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();

	// $ANTLR start "continueStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:450:1: continueStatement : CONTINUE s= semi -> ^( CONTINUE_STATEMENT CONTINUE ) ;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 51);
		TraceIn("continueStatement", 51);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken CONTINUE170 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree CONTINUE170_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_CONTINUE=new RewriteRuleITokenStream(adaptor,"token CONTINUE");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(450, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:451:2: ( CONTINUE s= semi -> ^( CONTINUE_STATEMENT CONTINUE ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:451:4: CONTINUE s= semi
			{
			DebugLocation(451, 4);
			CONTINUE170=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement2451); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONTINUE.Add(CONTINUE170);

			DebugLocation(451, 14);
			PushFollow(Follow._semi_in_continueStatement2455);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: CONTINUE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 452:9: -> ^( CONTINUE_STATEMENT CONTINUE )
			{
				DebugLocation(452, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:452:12: ^( CONTINUE_STATEMENT CONTINUE )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(452, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CONTINUE_STATEMENT, "CONTINUE_STATEMENT"), root_1);

				DebugLocation(452, 33);
				adaptor.AddChild(root_1, stream_CONTINUE.NextNode());
				DebugLocation(452, 42);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 51);
			LeaveRule("continueStatement", 51);
			LeaveRule_continueStatement();
		}
		DebugLocation(453, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();

	// $ANTLR start "breakStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:455:1: breakStatement : BREAK s= semi -> ^( BREAK_STATEMENT BREAK ) ;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 52);
		TraceIn("breakStatement", 52);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken BREAK171 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> s = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree BREAK171_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_BREAK=new RewriteRuleITokenStream(adaptor,"token BREAK");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(455, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:456:2: ( BREAK s= semi -> ^( BREAK_STATEMENT BREAK ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:456:4: BREAK s= semi
			{
			DebugLocation(456, 4);
			BREAK171=(IToken)Match(input,BREAK,Follow._BREAK_in_breakStatement2484); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BREAK.Add(BREAK171);

			DebugLocation(456, 11);
			PushFollow(Follow._semi_in_breakStatement2488);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: BREAK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 457:9: -> ^( BREAK_STATEMENT BREAK )
			{
				DebugLocation(457, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:457:12: ^( BREAK_STATEMENT BREAK )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(457, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(BREAK_STATEMENT, "BREAK_STATEMENT"), root_1);

				DebugLocation(457, 30);
				adaptor.AddChild(root_1, stream_BREAK.NextNode());
				DebugLocation(457, 36);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 52);
			LeaveRule("breakStatement", 52);
			LeaveRule_breakStatement();
		}
		DebugLocation(458, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();

	// $ANTLR start "switchStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:460:1: switchStatement : SWITCH condition switchBlock -> ^( SWITCH_STATEMENT SWITCH condition switchBlock ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 53);
		TraceIn("switchStatement", 53);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken SWITCH172 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> condition173 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> switchBlock174 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree SWITCH172_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_switchBlock=new RewriteRuleSubtreeStream(adaptor,"rule switchBlock");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(460, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:461:2: ( SWITCH condition switchBlock -> ^( SWITCH_STATEMENT SWITCH condition switchBlock ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:461:4: SWITCH condition switchBlock
			{
			DebugLocation(461, 4);
			SWITCH172=(IToken)Match(input,SWITCH,Follow._SWITCH_in_switchStatement2517); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SWITCH.Add(SWITCH172);

			DebugLocation(461, 11);
			PushFollow(Follow._condition_in_switchStatement2519);
			condition173=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition173.Tree);
			DebugLocation(462, 3);
			PushFollow(Follow._switchBlock_in_switchStatement2523);
			switchBlock174=switchBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_switchBlock.Add(switchBlock174.Tree);


			{
			// AST REWRITE
			// elements: switchBlock, condition, SWITCH
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 463:9: -> ^( SWITCH_STATEMENT SWITCH condition switchBlock )
			{
				DebugLocation(463, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:463:12: ^( SWITCH_STATEMENT SWITCH condition switchBlock )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(463, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(SWITCH_STATEMENT, "SWITCH_STATEMENT"), root_1);

				DebugLocation(463, 31);
				adaptor.AddChild(root_1, stream_SWITCH.NextNode());
				DebugLocation(463, 38);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(463, 48);
				adaptor.AddChild(root_1, stream_switchBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 53);
			LeaveRule("switchStatement", 53);
			LeaveRule_switchStatement();
		}
		DebugLocation(464, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_switchBlock();
	partial void LeaveRule_switchBlock();

	// $ANTLR start "switchBlock"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:466:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
	[GrammarRule("switchBlock")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> switchBlock()
	{
		EnterRule_switchBlock();
		EnterRule("switchBlock", 54);
		TraceIn("switchBlock", 54);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LCURLY175 = default(IToken);
		IToken RCURLY178 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> caseStatement176 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> defaultStatement177 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LCURLY175_tree = default(FlyparseTree);
		FlyparseTree RCURLY178_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_caseStatement=new RewriteRuleSubtreeStream(adaptor,"rule caseStatement");
		RewriteRuleSubtreeStream stream_defaultStatement=new RewriteRuleSubtreeStream(adaptor,"rule defaultStatement");
		try { DebugEnterRule(GrammarFileName, "switchBlock");
		DebugLocation(466, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:467:2: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:467:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
			{
			DebugLocation(467, 4);
			LCURLY175=(IToken)Match(input,LCURLY,Follow._LCURLY_in_switchBlock2554); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY175);

			DebugLocation(468, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:468:3: ( caseStatement )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_0 = input.LA(1);

				if ((LA40_0==CASE))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:468:4: caseStatement
					{
					DebugLocation(468, 4);
					PushFollow(Follow._caseStatement_in_switchBlock2559);
					caseStatement176=caseStatement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_caseStatement.Add(caseStatement176.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(469, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:469:3: ( defaultStatement )?
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_0 = input.LA(1);

			if ((LA41_0==DEFAULT))
			{
				alt41 = 1;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:469:4: defaultStatement
				{
				DebugLocation(469, 4);
				PushFollow(Follow._defaultStatement_in_switchBlock2566);
				defaultStatement177=defaultStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_defaultStatement.Add(defaultStatement177.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(41); }

			DebugLocation(470, 3);
			RCURLY178=(IToken)Match(input,RCURLY,Follow._RCURLY_in_switchBlock2572); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY178);



			{
			// AST REWRITE
			// elements: defaultStatement, caseStatement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 471:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
			{
				DebugLocation(471, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:471:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(471, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(471, 14);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:471:14: ( caseStatement )*
				while ( stream_caseStatement.HasNext )
				{
					DebugLocation(471, 14);
					adaptor.AddChild(root_1, stream_caseStatement.NextTree());

				}
				stream_caseStatement.Reset();
				DebugLocation(471, 29);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:471:29: ( defaultStatement )?
				if (stream_defaultStatement.HasNext)
				{
					DebugLocation(471, 29);
					adaptor.AddChild(root_1, stream_defaultStatement.NextTree());

				}
				stream_defaultStatement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchBlock", 54);
			LeaveRule("switchBlock", 54);
			LeaveRule_switchBlock();
		}
		DebugLocation(472, 1);
		} finally { DebugExitRule(GrammarFileName, "switchBlock"); }
		return retval;

	}
	// $ANTLR end "switchBlock"

	partial void EnterRule_caseStatement();
	partial void LeaveRule_caseStatement();

	// $ANTLR start "caseStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:474:1: caseStatement : CASE expression COLON !l= switchStatementList ;
	[GrammarRule("caseStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> caseStatement()
	{
		EnterRule_caseStatement();
		EnterRule("caseStatement", 55);
		TraceIn("caseStatement", 55);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken CASE179 = default(IToken);
		IToken COLON181 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> l = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression180 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree CASE179_tree = default(FlyparseTree);
		FlyparseTree COLON181_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "caseStatement");
		DebugLocation(474, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:475:2: ( CASE expression COLON !l= switchStatementList )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:475:4: CASE expression COLON !l= switchStatementList
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(475, 4);
			CASE179=(IToken)Match(input,CASE,Follow._CASE_in_caseStatement2597); if (state.failed) return retval;
			if (state.backtracking == 0) {
			CASE179_tree = (FlyparseTree)adaptor.Create(CASE179);
			adaptor.AddChild(root_0, CASE179_tree);
			}
			DebugLocation(475, 9);
			PushFollow(Follow._expression_in_caseStatement2599);
			expression180=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression180.Tree);
			DebugLocation(475, 25);
			COLON181=(IToken)Match(input,COLON,Follow._COLON_in_caseStatement2601); if (state.failed) return retval;
			DebugLocation(475, 28);
			PushFollow(Follow._switchStatementList_in_caseStatement2606);
			l=switchStatementList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, l.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseStatement", 55);
			LeaveRule("caseStatement", 55);
			LeaveRule_caseStatement();
		}
		DebugLocation(476, 1);
		} finally { DebugExitRule(GrammarFileName, "caseStatement"); }
		return retval;

	}
	// $ANTLR end "caseStatement"

	partial void EnterRule_defaultStatement();
	partial void LeaveRule_defaultStatement();

	// $ANTLR start "defaultStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:478:1: defaultStatement : DEFAULT COLON !l= switchStatementList ;
	[GrammarRule("defaultStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> defaultStatement()
	{
		EnterRule_defaultStatement();
		EnterRule("defaultStatement", 56);
		TraceIn("defaultStatement", 56);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DEFAULT182 = default(IToken);
		IToken COLON183 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> l = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DEFAULT182_tree = default(FlyparseTree);
		FlyparseTree COLON183_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "defaultStatement");
		DebugLocation(478, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:479:2: ( DEFAULT COLON !l= switchStatementList )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:479:4: DEFAULT COLON !l= switchStatementList
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(479, 4);
			DEFAULT182=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultStatement2619); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DEFAULT182_tree = (FlyparseTree)adaptor.Create(DEFAULT182);
			adaptor.AddChild(root_0, DEFAULT182_tree);
			}
			DebugLocation(479, 17);
			COLON183=(IToken)Match(input,COLON,Follow._COLON_in_defaultStatement2621); if (state.failed) return retval;
			DebugLocation(479, 20);
			PushFollow(Follow._switchStatementList_in_defaultStatement2626);
			l=switchStatementList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, l.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultStatement", 56);
			LeaveRule("defaultStatement", 56);
			LeaveRule_defaultStatement();
		}
		DebugLocation(480, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultStatement"); }
		return retval;

	}
	// $ANTLR end "defaultStatement"

	partial void EnterRule_switchStatementList();
	partial void LeaveRule_switchStatementList();

	// $ANTLR start "switchStatementList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:482:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
	[GrammarRule("switchStatementList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> switchStatementList()
	{
		EnterRule_switchStatementList();
		EnterRule("switchStatementList", 57);
		TraceIn("switchStatementList", 57);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> statement184 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "switchStatementList");
		DebugLocation(482, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:2: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:4: ( statement )*
			{
			DebugLocation(483, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:4: ( statement )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_0 = input.LA(1);

				if ((LA42_0==DEFAULT))
				{
					int LA42_1 = input.LA(2);

					if ((LA42_1==XML))
					{
						alt42 = 1;
					}


				}
				else if ((LA42_0==AS||LA42_0==BNOT||LA42_0==BREAK||LA42_0==CONST||LA42_0==CONTINUE||(LA42_0>=DEC && LA42_0<=DECIMAL_LITERAL)||LA42_0==DO||(LA42_0>=DYNAMIC && LA42_0<=E4X_ATTRI)||(LA42_0>=FALSE && LA42_0<=FOR)||LA42_0==FUNCTION||LA42_0==GET||(LA42_0>=HEX_LITERAL && LA42_0<=IDENT)||LA42_0==IF||LA42_0==INC||(LA42_0>=INTERNAL && LA42_0<=IS)||(LA42_0>=LBRACK && LA42_0<=LCURLY)||LA42_0==LNOT||LA42_0==LPAREN||LA42_0==MINUS||LA42_0==NAMESPACE||LA42_0==NEW||LA42_0==NULL||LA42_0==OCTAL_LITERAL||LA42_0==PLUS||LA42_0==PRIVATE||(LA42_0>=PROTECTED && LA42_0<=PUBLIC)||LA42_0==REGEX_LITERAL||LA42_0==RETURN||(LA42_0>=SEMI && LA42_0<=SET)||(LA42_0>=STRING_LITERAL_DOUBLE && LA42_0<=SWITCH)||LA42_0==TRUE||(LA42_0>=USE && LA42_0<=VAR)||LA42_0==WHILE||LA42_0==WITH||LA42_0==XML||LA42_0==XML_LITERAL||LA42_0==243||(LA42_0>=253 && LA42_0<=257)))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:4: statement
					{
					DebugLocation(483, 4);
					PushFollow(Follow._statement_in_switchStatementList2638);
					statement184=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement184.Tree);

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 483:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
			{
				DebugLocation(483, 18);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(483, 20);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);

				DebugLocation(483, 42);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:483:42: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(483, 42);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatementList", 57);
			LeaveRule("switchStatementList", 57);
			LeaveRule_switchStatementList();
		}
		DebugLocation(484, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatementList"); }
		return retval;

	}
	// $ANTLR end "switchStatementList"

	partial void EnterRule_forEachStatement();
	partial void LeaveRule_forEachStatement();

	// $ANTLR start "forEachStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:486:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH_LOOP $f forInClause statement ) ;
	[GrammarRule("forEachStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forEachStatement()
	{
		EnterRule_forEachStatement();
		EnterRule("forEachStatement", 58);
		TraceIn("forEachStatement", 58);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken f = default(IToken);
		IToken EACH185 = default(IToken);
		IToken LPAREN186 = default(IToken);
		IToken RPAREN188 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> forInClause187 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement189 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree f_tree = default(FlyparseTree);
		FlyparseTree EACH185_tree = default(FlyparseTree);
		FlyparseTree LPAREN186_tree = default(FlyparseTree);
		FlyparseTree RPAREN188_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_EACH=new RewriteRuleITokenStream(adaptor,"token EACH");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_forInClause=new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
		try { DebugEnterRule(GrammarFileName, "forEachStatement");
		DebugLocation(486, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:487:2: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH_LOOP $f forInClause statement ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:487:4: f= FOR EACH LPAREN forInClause RPAREN statement
			{
			DebugLocation(487, 5);
			f=(IToken)Match(input,FOR,Follow._FOR_in_forEachStatement2661); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(f);

			DebugLocation(487, 10);
			EACH185=(IToken)Match(input,EACH,Follow._EACH_in_forEachStatement2663); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EACH.Add(EACH185);

			DebugLocation(488, 3);
			LPAREN186=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forEachStatement2667); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN186);

			DebugLocation(489, 3);
			PushFollow(Follow._forInClause_in_forEachStatement2671);
			forInClause187=forInClause();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_forInClause.Add(forInClause187.Tree);
			DebugLocation(490, 3);
			RPAREN188=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forEachStatement2675); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN188);

			DebugLocation(491, 3);
			PushFollow(Follow._statement_in_forEachStatement2679);
			statement189=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement189.Tree);


			{
			// AST REWRITE
			// elements: forInClause, f, statement
			// token labels: f
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_f=new RewriteRuleITokenStream(adaptor,"token f",f);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 492:3: -> ^( FOR_EACH_LOOP $f forInClause statement )
			{
				DebugLocation(492, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:492:6: ^( FOR_EACH_LOOP $f forInClause statement )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(492, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_EACH_LOOP, "FOR_EACH_LOOP"), root_1);

				DebugLocation(492, 23);
				adaptor.AddChild(root_1, stream_f.NextNode());
				DebugLocation(492, 25);
				adaptor.AddChild(root_1, stream_forInClause.NextTree());
				DebugLocation(492, 37);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forEachStatement", 58);
			LeaveRule("forEachStatement", 58);
			LeaveRule_forEachStatement();
		}
		DebugLocation(493, 1);
		} finally { DebugExitRule(GrammarFileName, "forEachStatement"); }
		return retval;

	}
	// $ANTLR end "forEachStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();

	// $ANTLR start "forStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:495:1: forStatement : FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) ) ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 59);
		TraceIn("forStatement", 59);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken FOR190 = default(IToken);
		IToken LPAREN191 = default(IToken);
		IToken RPAREN193 = default(IToken);
		IToken RPAREN196 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> forInClause192 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement194 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> traditionalForClause195 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement197 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree FOR190_tree = default(FlyparseTree);
		FlyparseTree LPAREN191_tree = default(FlyparseTree);
		FlyparseTree RPAREN193_tree = default(FlyparseTree);
		FlyparseTree RPAREN196_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_traditionalForClause=new RewriteRuleSubtreeStream(adaptor,"rule traditionalForClause");
		RewriteRuleSubtreeStream stream_forInClause=new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(495, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:497:2: ( FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:497:4: FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )
			{
			DebugLocation(497, 4);
			FOR190=(IToken)Match(input,FOR,Follow._FOR_in_forStatement2706); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR190);

			DebugLocation(498, 3);
			LPAREN191=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forStatement2710); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN191);

			DebugLocation(499, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:499:3: ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )
			int alt43=2;
			try { DebugEnterSubRule(43);
			try { DebugEnterDecision(43, false);
			try
			{
				alt43 = dfa43.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:499:5: forInClause RPAREN statement
				{
				DebugLocation(499, 5);
				PushFollow(Follow._forInClause_in_forStatement2716);
				forInClause192=forInClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_forInClause.Add(forInClause192.Tree);
				DebugLocation(499, 17);
				RPAREN193=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement2718); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN193);

				DebugLocation(499, 24);
				PushFollow(Follow._statement_in_forStatement2720);
				statement194=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement194.Tree);


				{
				// AST REWRITE
				// elements: FOR, forInClause, statement, LPAREN, RPAREN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 500:4: -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement )
				{
					DebugLocation(500, 7);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:500:7: ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(500, 9);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_IN_LOOP, "FOR_IN_LOOP"), root_1);

					DebugLocation(500, 21);
					adaptor.AddChild(root_1, stream_FOR.NextNode());
					DebugLocation(500, 25);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(500, 32);
					adaptor.AddChild(root_1, stream_forInClause.NextTree());
					DebugLocation(500, 44);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());
					DebugLocation(500, 51);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:502:5: traditionalForClause RPAREN statement
				{
				DebugLocation(502, 5);
				PushFollow(Follow._traditionalForClause_in_forStatement2746);
				traditionalForClause195=traditionalForClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_traditionalForClause.Add(traditionalForClause195.Tree);
				DebugLocation(502, 26);
				RPAREN196=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement2748); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN196);

				DebugLocation(502, 33);
				PushFollow(Follow._statement_in_forStatement2750);
				statement197=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement197.Tree);


				{
				// AST REWRITE
				// elements: statement, RPAREN, LPAREN, FOR, traditionalForClause
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 503:4: -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement )
				{
					DebugLocation(503, 7);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:503:7: ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(503, 9);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_LOOP, "FOR_LOOP"), root_1);

					DebugLocation(503, 18);
					adaptor.AddChild(root_1, stream_FOR.NextNode());
					DebugLocation(503, 22);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(503, 29);
					adaptor.AddChild(root_1, stream_traditionalForClause.NextTree());
					DebugLocation(503, 50);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());
					DebugLocation(503, 57);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(43); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 59);
			LeaveRule("forStatement", 59);
			LeaveRule_forStatement();
		}
		DebugLocation(505, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_traditionalForClause();
	partial void LeaveRule_traditionalForClause();

	// $ANTLR start "traditionalForClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:507:1: traditionalForClause : forInit semi forCond semi forIter ;
	[GrammarRule("traditionalForClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> traditionalForClause()
	{
		EnterRule_traditionalForClause();
		EnterRule("traditionalForClause", 60);
		TraceIn("traditionalForClause", 60);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> forInit198 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi199 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> forCond200 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi201 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> forIter202 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "traditionalForClause");
		DebugLocation(507, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:508:2: ( forInit semi forCond semi forIter )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:508:4: forInit semi forCond semi forIter
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(508, 4);
			PushFollow(Follow._forInit_in_traditionalForClause2784);
			forInit198=forInit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInit198.Tree);
			DebugLocation(508, 13);
			PushFollow(Follow._semi_in_traditionalForClause2787);
			semi199=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi199.Tree);
			DebugLocation(509, 3);
			PushFollow(Follow._forCond_in_traditionalForClause2792);
			forCond200=forCond();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forCond200.Tree);
			DebugLocation(509, 12);
			PushFollow(Follow._semi_in_traditionalForClause2795);
			semi201=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi201.Tree);
			DebugLocation(510, 3);
			PushFollow(Follow._forIter_in_traditionalForClause2800);
			forIter202=forIter();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forIter202.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("traditionalForClause", 60);
			LeaveRule("traditionalForClause", 60);
			LeaveRule_traditionalForClause();
		}
		DebugLocation(511, 1);
		} finally { DebugExitRule(GrammarFileName, "traditionalForClause"); }
		return retval;

	}
	// $ANTLR end "traditionalForClause"

	partial void EnterRule_forInClause();
	partial void LeaveRule_forInClause();

	// $ANTLR start "forInClause"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:513:1: forInClause : forInClauseDecl IN forInClauseTail ;
	[GrammarRule("forInClause")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forInClause()
	{
		EnterRule_forInClause();
		EnterRule("forInClause", 61);
		TraceIn("forInClause", 61);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IN204 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> forInClauseDecl203 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> forInClauseTail205 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree IN204_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "forInClause");
		DebugLocation(513, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:514:2: ( forInClauseDecl IN forInClauseTail )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:514:4: forInClauseDecl IN forInClauseTail
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(514, 4);
			PushFollow(Follow._forInClauseDecl_in_forInClause2814);
			forInClauseDecl203=forInClauseDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInClauseDecl203.Tree);
			DebugLocation(514, 20);
			IN204=(IToken)Match(input,IN,Follow._IN_in_forInClause2816); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IN204_tree = (FlyparseTree)adaptor.Create(IN204);
			adaptor.AddChild(root_0, IN204_tree);
			}
			DebugLocation(514, 23);
			PushFollow(Follow._forInClauseTail_in_forInClause2818);
			forInClauseTail205=forInClauseTail();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInClauseTail205.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClause", 61);
			LeaveRule("forInClause", 61);
			LeaveRule_forInClause();
		}
		DebugLocation(515, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClause"); }
		return retval;

	}
	// $ANTLR end "forInClause"

	partial void EnterRule_forInClauseDecl();
	partial void LeaveRule_forInClauseDecl();

	// $ANTLR start "forInClauseDecl"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:517:1: forInClauseDecl : ( varOrConst ident ( typeExpression )? | ident );
	[GrammarRule("forInClauseDecl")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forInClauseDecl()
	{
		EnterRule_forInClauseDecl();
		EnterRule("forInClauseDecl", 62);
		TraceIn("forInClauseDecl", 62);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> varOrConst206 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident207 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression208 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident209 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "forInClauseDecl");
		DebugLocation(517, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:518:2: ( varOrConst ident ( typeExpression )? | ident )
			int alt45=2;
			try { DebugEnterDecision(45, false);
			int LA45_0 = input.LA(1);

			if ((LA45_0==CONST||LA45_0==VAR))
			{
				alt45 = 1;
			}
			else if ((LA45_0==AS||LA45_0==DYNAMIC||LA45_0==GET||LA45_0==IDENT||LA45_0==IS||LA45_0==NAMESPACE||LA45_0==SET||LA45_0==SUPER||LA45_0==USE||LA45_0==XML))
			{
				alt45 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 45, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:518:4: varOrConst ident ( typeExpression )?
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(518, 4);
				PushFollow(Follow._varOrConst_in_forInClauseDecl2829);
				varOrConst206=varOrConst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varOrConst206.Tree);
				DebugLocation(518, 15);
				PushFollow(Follow._ident_in_forInClauseDecl2831);
				ident207=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident207.Tree);
				DebugLocation(518, 21);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:518:21: ( typeExpression )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_0 = input.LA(1);

				if ((LA44_0==COLON))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:518:21: typeExpression
					{
					DebugLocation(518, 21);
					PushFollow(Follow._typeExpression_in_forInClauseDecl2833);
					typeExpression208=typeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, typeExpression208.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(44); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:519:11: ident
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(519, 11);
				PushFollow(Follow._ident_in_forInClauseDecl2847);
				ident209=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident209.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClauseDecl", 62);
			LeaveRule("forInClauseDecl", 62);
			LeaveRule_forInClauseDecl();
		}
		DebugLocation(520, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClauseDecl"); }
		return retval;

	}
	// $ANTLR end "forInClauseDecl"

	partial void EnterRule_forInClauseTail();
	partial void LeaveRule_forInClauseTail();

	// $ANTLR start "forInClauseTail"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:523:1: forInClauseTail : expressionList ;
	[GrammarRule("forInClauseTail")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forInClauseTail()
	{
		EnterRule_forInClauseTail();
		EnterRule("forInClauseTail", 63);
		TraceIn("forInClauseTail", 63);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList210 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "forInClauseTail");
		DebugLocation(523, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:524:2: ( expressionList )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:524:4: expressionList
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(524, 4);
			PushFollow(Follow._expressionList_in_forInClauseTail2859);
			expressionList210=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expressionList210.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClauseTail", 63);
			LeaveRule("forInClauseTail", 63);
			LeaveRule_forInClauseTail();
		}
		DebugLocation(525, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClauseTail"); }
		return retval;

	}
	// $ANTLR end "forInClauseTail"

	partial void EnterRule_forInit();
	partial void LeaveRule_forInit();

	// $ANTLR start "forInit"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:528:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
	[GrammarRule("forInit")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forInit()
	{
		EnterRule_forInit();
		EnterRule("forInit", 64);
		TraceIn("forInit", 64);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> declaration211 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList212 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forInit");
		DebugLocation(528, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:529:2: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:529:4: ( declaration | expressionList )?
			{
			DebugLocation(529, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:529:4: ( declaration | expressionList )?
			int alt46=3;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_0 = input.LA(1);

			if ((LA46_0==CONST||LA46_0==VAR))
			{
				alt46 = 1;
			}
			else if ((LA46_0==AS||LA46_0==BNOT||(LA46_0>=DEC && LA46_0<=DECIMAL_LITERAL)||(LA46_0>=DYNAMIC && LA46_0<=E4X_ATTRI)||(LA46_0>=FALSE && LA46_0<=FLOAT_LITERAL)||LA46_0==FUNCTION||LA46_0==GET||(LA46_0>=HEX_LITERAL && LA46_0<=IDENT)||LA46_0==INC||(LA46_0>=INTERNAL && LA46_0<=IS)||(LA46_0>=LBRACK && LA46_0<=LCURLY)||LA46_0==LNOT||LA46_0==LPAREN||LA46_0==MINUS||LA46_0==NAMESPACE||LA46_0==NEW||LA46_0==NULL||LA46_0==OCTAL_LITERAL||LA46_0==PLUS||LA46_0==PRIVATE||(LA46_0>=PROTECTED && LA46_0<=PUBLIC)||LA46_0==REGEX_LITERAL||LA46_0==SET||(LA46_0>=STRING_LITERAL_DOUBLE && LA46_0<=SUPER)||LA46_0==TRUE||LA46_0==USE||LA46_0==XML||LA46_0==XML_LITERAL||LA46_0==243||(LA46_0>=255 && LA46_0<=257)))
			{
				alt46 = 2;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:529:5: declaration
				{
				DebugLocation(529, 5);
				PushFollow(Follow._declaration_in_forInit2873);
				declaration211=declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declaration.Add(declaration211.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:529:19: expressionList
				{
				DebugLocation(529, 19);
				PushFollow(Follow._expressionList_in_forInit2877);
				expressionList212=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList212.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(46); }



			{
			// AST REWRITE
			// elements: expressionList, declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 530:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
			{
				DebugLocation(530, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:530:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(530, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);

				DebugLocation(530, 17);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:530:17: ( declaration )?
				if (stream_declaration.HasNext)
				{
					DebugLocation(530, 17);
					adaptor.AddChild(root_1, stream_declaration.NextTree());

				}
				stream_declaration.Reset();
				DebugLocation(530, 30);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:530:30: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(530, 30);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInit", 64);
			LeaveRule("forInit", 64);
			LeaveRule_forInit();
		}
		DebugLocation(531, 1);
		} finally { DebugExitRule(GrammarFileName, "forInit"); }
		return retval;

	}
	// $ANTLR end "forInit"

	partial void EnterRule_forCond();
	partial void LeaveRule_forCond();

	// $ANTLR start "forCond"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:533:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
	[GrammarRule("forCond")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forCond()
	{
		EnterRule_forCond();
		EnterRule("forCond", 65);
		TraceIn("forCond", 65);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList213 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forCond");
		DebugLocation(533, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:534:2: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:534:4: ( expressionList )?
			{
			DebugLocation(534, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:534:4: ( expressionList )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_0 = input.LA(1);

			if ((LA47_0==AS||LA47_0==BNOT||(LA47_0>=DEC && LA47_0<=DECIMAL_LITERAL)||(LA47_0>=DYNAMIC && LA47_0<=E4X_ATTRI)||(LA47_0>=FALSE && LA47_0<=FLOAT_LITERAL)||LA47_0==FUNCTION||LA47_0==GET||(LA47_0>=HEX_LITERAL && LA47_0<=IDENT)||LA47_0==INC||(LA47_0>=INTERNAL && LA47_0<=IS)||(LA47_0>=LBRACK && LA47_0<=LCURLY)||LA47_0==LNOT||LA47_0==LPAREN||LA47_0==MINUS||LA47_0==NAMESPACE||LA47_0==NEW||LA47_0==NULL||LA47_0==OCTAL_LITERAL||LA47_0==PLUS||LA47_0==PRIVATE||(LA47_0>=PROTECTED && LA47_0<=PUBLIC)||LA47_0==REGEX_LITERAL||LA47_0==SET||(LA47_0>=STRING_LITERAL_DOUBLE && LA47_0<=SUPER)||LA47_0==TRUE||LA47_0==USE||LA47_0==XML||LA47_0==XML_LITERAL||LA47_0==243||(LA47_0>=255 && LA47_0<=257)))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:534:4: expressionList
				{
				DebugLocation(534, 4);
				PushFollow(Follow._expressionList_in_forCond2905);
				expressionList213=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList213.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(47); }



			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 535:3: -> ^( FOR_CONDITION ( expressionList )? )
			{
				DebugLocation(535, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:535:6: ^( FOR_CONDITION ( expressionList )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(535, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);

				DebugLocation(535, 22);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:535:22: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(535, 22);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forCond", 65);
			LeaveRule("forCond", 65);
			LeaveRule_forCond();
		}
		DebugLocation(536, 1);
		} finally { DebugExitRule(GrammarFileName, "forCond"); }
		return retval;

	}
	// $ANTLR end "forCond"

	partial void EnterRule_forIter();
	partial void LeaveRule_forIter();

	// $ANTLR start "forIter"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:538:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
	[GrammarRule("forIter")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> forIter()
	{
		EnterRule_forIter();
		EnterRule("forIter", 66);
		TraceIn("forIter", 66);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList214 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forIter");
		DebugLocation(538, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:539:2: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:539:4: ( expressionList )?
			{
			DebugLocation(539, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:539:4: ( expressionList )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_0 = input.LA(1);

			if ((LA48_0==AS||LA48_0==BNOT||(LA48_0>=DEC && LA48_0<=DECIMAL_LITERAL)||(LA48_0>=DYNAMIC && LA48_0<=E4X_ATTRI)||(LA48_0>=FALSE && LA48_0<=FLOAT_LITERAL)||LA48_0==FUNCTION||LA48_0==GET||(LA48_0>=HEX_LITERAL && LA48_0<=IDENT)||LA48_0==INC||(LA48_0>=INTERNAL && LA48_0<=IS)||(LA48_0>=LBRACK && LA48_0<=LCURLY)||LA48_0==LNOT||LA48_0==LPAREN||LA48_0==MINUS||LA48_0==NAMESPACE||LA48_0==NEW||LA48_0==NULL||LA48_0==OCTAL_LITERAL||LA48_0==PLUS||LA48_0==PRIVATE||(LA48_0>=PROTECTED && LA48_0<=PUBLIC)||LA48_0==REGEX_LITERAL||LA48_0==SET||(LA48_0>=STRING_LITERAL_DOUBLE && LA48_0<=SUPER)||LA48_0==TRUE||LA48_0==USE||LA48_0==XML||LA48_0==XML_LITERAL||LA48_0==243||(LA48_0>=255 && LA48_0<=257)))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:539:4: expressionList
				{
				DebugLocation(539, 4);
				PushFollow(Follow._expressionList_in_forIter2928);
				expressionList214=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList214.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }



			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 540:3: -> ^( FOR_ITERATOR ( expressionList )? )
			{
				DebugLocation(540, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:540:6: ^( FOR_ITERATOR ( expressionList )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(540, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);

				DebugLocation(540, 21);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:540:21: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(540, 21);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forIter", 66);
			LeaveRule("forIter", 66);
			LeaveRule_forIter();
		}
		DebugLocation(541, 1);
		} finally { DebugExitRule(GrammarFileName, "forIter"); }
		return retval;

	}
	// $ANTLR end "forIter"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();

	// $ANTLR start "whileStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:543:1: whileStatement : WHILE condition statement -> ^( WHILE_LOOP condition statement ) ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 67);
		TraceIn("whileStatement", 67);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken WHILE215 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> condition216 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement217 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree WHILE215_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(543, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:544:2: ( WHILE condition statement -> ^( WHILE_LOOP condition statement ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:544:4: WHILE condition statement
			{
			DebugLocation(544, 4);
			WHILE215=(IToken)Match(input,WHILE,Follow._WHILE_in_whileStatement2951); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE215);

			DebugLocation(544, 10);
			PushFollow(Follow._condition_in_whileStatement2953);
			condition216=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition216.Tree);
			DebugLocation(544, 20);
			PushFollow(Follow._statement_in_whileStatement2955);
			statement217=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement217.Tree);


			{
			// AST REWRITE
			// elements: condition, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 545:3: -> ^( WHILE_LOOP condition statement )
			{
				DebugLocation(545, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:545:6: ^( WHILE_LOOP condition statement )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(545, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(WHILE_LOOP, "WHILE_LOOP"), root_1);

				DebugLocation(545, 19);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(545, 29);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 67);
			LeaveRule("whileStatement", 67);
			LeaveRule_whileStatement();
		}
		DebugLocation(546, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_doWhileStatement();
	partial void LeaveRule_doWhileStatement();

	// $ANTLR start "doWhileStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:548:1: doWhileStatement : DO statement WHILE condition semi -> ^( DO_WHILE_LOOP DO statement WHILE condition ) ;
	[GrammarRule("doWhileStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> doWhileStatement()
	{
		EnterRule_doWhileStatement();
		EnterRule("doWhileStatement", 68);
		TraceIn("doWhileStatement", 68);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DO218 = default(IToken);
		IToken WHILE220 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement219 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> condition221 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi222 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DO218_tree = default(FlyparseTree);
		FlyparseTree WHILE220_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "doWhileStatement");
		DebugLocation(548, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:549:2: ( DO statement WHILE condition semi -> ^( DO_WHILE_LOOP DO statement WHILE condition ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:549:4: DO statement WHILE condition semi
			{
			DebugLocation(549, 4);
			DO218=(IToken)Match(input,DO,Follow._DO_in_doWhileStatement2978); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DO.Add(DO218);

			DebugLocation(549, 7);
			PushFollow(Follow._statement_in_doWhileStatement2980);
			statement219=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement219.Tree);
			DebugLocation(549, 17);
			WHILE220=(IToken)Match(input,WHILE,Follow._WHILE_in_doWhileStatement2982); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE220);

			DebugLocation(549, 23);
			PushFollow(Follow._condition_in_doWhileStatement2984);
			condition221=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition221.Tree);
			DebugLocation(549, 33);
			PushFollow(Follow._semi_in_doWhileStatement2986);
			semi222=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(semi222.Tree);


			{
			// AST REWRITE
			// elements: condition, DO, WHILE, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 550:3: -> ^( DO_WHILE_LOOP DO statement WHILE condition )
			{
				DebugLocation(550, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:550:6: ^( DO_WHILE_LOOP DO statement WHILE condition )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(550, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(DO_WHILE_LOOP, "DO_WHILE_LOOP"), root_1);

				DebugLocation(550, 22);
				adaptor.AddChild(root_1, stream_DO.NextNode());
				DebugLocation(550, 25);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(550, 35);
				adaptor.AddChild(root_1, stream_WHILE.NextNode());
				DebugLocation(550, 41);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doWhileStatement", 68);
			LeaveRule("doWhileStatement", 68);
			LeaveRule_doWhileStatement();
		}
		DebugLocation(551, 1);
		} finally { DebugExitRule(GrammarFileName, "doWhileStatement"); }
		return retval;

	}
	// $ANTLR end "doWhileStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();

	// $ANTLR start "withStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:553:1: withStatement : WITH condition statement ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 69);
		TraceIn("withStatement", 69);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken WITH223 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> condition224 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> statement225 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree WITH223_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(553, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:554:2: ( WITH condition statement )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:554:4: WITH condition statement
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(554, 4);
			WITH223=(IToken)Match(input,WITH,Follow._WITH_in_withStatement3014); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WITH223_tree = (FlyparseTree)adaptor.Create(WITH223);
			adaptor.AddChild(root_0, WITH223_tree);
			}
			DebugLocation(554, 9);
			PushFollow(Follow._condition_in_withStatement3016);
			condition224=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, condition224.Tree);
			DebugLocation(554, 19);
			PushFollow(Follow._statement_in_withStatement3018);
			statement225=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement225.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 69);
			LeaveRule("withStatement", 69);
			LeaveRule_withStatement();
		}
		DebugLocation(555, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_defaultXMLNamespaceStatement();
	partial void LeaveRule_defaultXMLNamespaceStatement();

	// $ANTLR start "defaultXMLNamespaceStatement"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:557:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
	[GrammarRule("defaultXMLNamespaceStatement")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> defaultXMLNamespaceStatement()
	{
		EnterRule_defaultXMLNamespaceStatement();
		EnterRule("defaultXMLNamespaceStatement", 70);
		TraceIn("defaultXMLNamespaceStatement", 70);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DEFAULT226 = default(IToken);
		IToken XML227 = default(IToken);
		IToken NAMESPACE228 = default(IToken);
		IToken ASSIGN229 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression230 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> semi231 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DEFAULT226_tree = default(FlyparseTree);
		FlyparseTree XML227_tree = default(FlyparseTree);
		FlyparseTree NAMESPACE228_tree = default(FlyparseTree);
		FlyparseTree ASSIGN229_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_XML=new RewriteRuleITokenStream(adaptor,"token XML");
		RewriteRuleITokenStream stream_NAMESPACE=new RewriteRuleITokenStream(adaptor,"token NAMESPACE");
		RewriteRuleITokenStream stream_DEFAULT=new RewriteRuleITokenStream(adaptor,"token DEFAULT");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "defaultXMLNamespaceStatement");
		DebugLocation(557, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:558:2: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:558:4: DEFAULT XML NAMESPACE ASSIGN expression semi
			{
			DebugLocation(558, 4);
			DEFAULT226=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultXMLNamespaceStatement3029); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DEFAULT.Add(DEFAULT226);

			DebugLocation(558, 12);
			XML227=(IToken)Match(input,XML,Follow._XML_in_defaultXMLNamespaceStatement3031); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_XML.Add(XML227);

			DebugLocation(558, 16);
			NAMESPACE228=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_defaultXMLNamespaceStatement3033); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NAMESPACE.Add(NAMESPACE228);

			DebugLocation(558, 26);
			ASSIGN229=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_defaultXMLNamespaceStatement3035); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN229);

			DebugLocation(558, 33);
			PushFollow(Follow._expression_in_defaultXMLNamespaceStatement3037);
			expression230=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression230.Tree);
			DebugLocation(558, 44);
			PushFollow(Follow._semi_in_defaultXMLNamespaceStatement3039);
			semi231=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(semi231.Tree);


			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 559:3: -> ^( DEFAULT_XML_NAMESPACE expression )
			{
				DebugLocation(559, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:559:6: ^( DEFAULT_XML_NAMESPACE expression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(559, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);

				DebugLocation(559, 30);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultXMLNamespaceStatement", 70);
			LeaveRule("defaultXMLNamespaceStatement", 70);
			LeaveRule_defaultXMLNamespaceStatement();
		}
		DebugLocation(560, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultXMLNamespaceStatement"); }
		return retval;

	}
	// $ANTLR end "defaultXMLNamespaceStatement"

	partial void EnterRule_typeExpression();
	partial void LeaveRule_typeExpression();

	// $ANTLR start "typeExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:562:1: typeExpression : COLON ( typeIdentifier | 'void' | STAR ) -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? ) ;
	[GrammarRule("typeExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression()
	{
		EnterRule_typeExpression();
		EnterRule("typeExpression", 71);
		TraceIn("typeExpression", 71);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COLON232 = default(IToken);
		IToken string_literal234 = default(IToken);
		IToken STAR235 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeIdentifier233 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COLON232_tree = default(FlyparseTree);
		FlyparseTree string_literal234_tree = default(FlyparseTree);
		FlyparseTree STAR235_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_257=new RewriteRuleITokenStream(adaptor,"token 257");
		RewriteRuleSubtreeStream stream_typeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule typeIdentifier");
		try { DebugEnterRule(GrammarFileName, "typeExpression");
		DebugLocation(562, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:563:2: ( COLON ( typeIdentifier | 'void' | STAR ) -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:564:3: COLON ( typeIdentifier | 'void' | STAR )
			{
			DebugLocation(564, 3);
			COLON232=(IToken)Match(input,COLON,Follow._COLON_in_typeExpression3064); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON232);

			DebugLocation(564, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:564:9: ( typeIdentifier | 'void' | STAR )
			int alt49=3;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case IS:
			case NAMESPACE:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt49 = 1;
				}
				break;
			case 257:
				{
				alt49 = 2;
				}
				break;
			case STAR:
				{
				alt49 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:564:10: typeIdentifier
				{
				DebugLocation(564, 10);
				PushFollow(Follow._typeIdentifier_in_typeExpression3067);
				typeIdentifier233=typeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeIdentifier.Add(typeIdentifier233.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:564:27: 'void'
				{
				DebugLocation(564, 27);
				string_literal234=(IToken)Match(input,257,Follow._257_in_typeExpression3071); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_257.Add(string_literal234);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:564:36: STAR
				{
				DebugLocation(564, 36);
				STAR235=(IToken)Match(input,STAR,Follow._STAR_in_typeExpression3075); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR235);


				}
				break;

			}
			} finally { DebugExitSubRule(49); }



			{
			// AST REWRITE
			// elements: typeIdentifier, STAR, COLON, 257
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 565:3: -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? )
			{
				DebugLocation(565, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:565:6: ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(565, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(TYPE_SPEC, "TYPE_SPEC"), root_1);

				DebugLocation(565, 18);
				adaptor.AddChild(root_1, stream_COLON.NextNode());
				DebugLocation(565, 24);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:565:24: ( typeIdentifier )?
				if (stream_typeIdentifier.HasNext)
				{
					DebugLocation(565, 24);
					adaptor.AddChild(root_1, stream_typeIdentifier.NextTree());

				}
				stream_typeIdentifier.Reset();
				DebugLocation(565, 40);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:565:40: ( 'void' )?
				if (stream_257.HasNext)
				{
					DebugLocation(565, 40);
					adaptor.AddChild(root_1, stream_257.NextNode());

				}
				stream_257.Reset();
				DebugLocation(565, 48);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:565:48: ( STAR )?
				if (stream_STAR.HasNext)
				{
					DebugLocation(565, 48);
					adaptor.AddChild(root_1, stream_STAR.NextNode());

				}
				stream_STAR.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeExpression", 71);
			LeaveRule("typeExpression", 71);
			LeaveRule_typeExpression();
		}
		DebugLocation(566, 4);
		} finally { DebugExitRule(GrammarFileName, "typeExpression"); }
		return retval;

	}
	// $ANTLR end "typeExpression"

	partial void EnterRule_typeIdentifier();
	partial void LeaveRule_typeIdentifier();

	// $ANTLR start "typeIdentifier"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:568:1: typeIdentifier : ident ( propOrIdent )* ;
	[GrammarRule("typeIdentifier")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> typeIdentifier()
	{
		EnterRule_typeIdentifier();
		EnterRule("typeIdentifier", 72);
		TraceIn("typeIdentifier", 72);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> ident236 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> propOrIdent237 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "typeIdentifier");
		DebugLocation(568, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:569:5: ( ident ( propOrIdent )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:570:5: ident ( propOrIdent )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(570, 5);
			PushFollow(Follow._ident_in_typeIdentifier3116);
			ident236=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident236.Tree);
			DebugLocation(570, 11);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:570:11: ( propOrIdent )*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_0 = input.LA(1);

				if ((LA50_0==DOT))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:570:12: propOrIdent
					{
					DebugLocation(570, 12);
					PushFollow(Follow._propOrIdent_in_typeIdentifier3119);
					propOrIdent237=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, propOrIdent237.Tree);

					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeIdentifier", 72);
			LeaveRule("typeIdentifier", 72);
			LeaveRule_typeIdentifier();
		}
		DebugLocation(571, 4);
		} finally { DebugExitRule(GrammarFileName, "typeIdentifier"); }
		return retval;

	}
	// $ANTLR end "typeIdentifier"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:573:1: identifier : ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )* ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 73);
		TraceIn("identifier", 73);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent238 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> propOrIdent239 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_propOrIdent=new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(573, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:2: ( ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:4: ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )*
			{
			DebugLocation(574, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:4: ( qualifiedIdent -> qualifiedIdent )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:5: qualifiedIdent
			{
			DebugLocation(574, 5);
			PushFollow(Follow._qualifiedIdent_in_identifier3137);
			qualifiedIdent238=qualifiedIdent();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent238.Tree);


			{
			// AST REWRITE
			// elements: qualifiedIdent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 574:20: -> qualifiedIdent
			{
				DebugLocation(574, 23);
				adaptor.AddChild(root_0, stream_qualifiedIdent.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(574, 39);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:39: ( propOrIdent -> propOrIdent )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_0 = input.LA(1);

				if ((LA51_0==DOT))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:574:40: propOrIdent
					{
					DebugLocation(574, 40);
					PushFollow(Follow._propOrIdent_in_identifier3145);
					propOrIdent239=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propOrIdent.Add(propOrIdent239.Tree);


					{
					// AST REWRITE
					// elements: propOrIdent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 574:52: -> propOrIdent
					{
						DebugLocation(574, 55);
						adaptor.AddChild(root_0, stream_propOrIdent.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 73);
			LeaveRule("identifier", 73);
			LeaveRule_identifier();
		}
		DebugLocation(575, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_qualifiedIdent();
	partial void LeaveRule_qualifiedIdent();

	// $ANTLR start "qualifiedIdent"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:577:1: qualifiedIdent options {k=1; } : ( ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident ) | ident );
	[GrammarRule("qualifiedIdent")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent()
	{
		EnterRule_qualifiedIdent();
		EnterRule("qualifiedIdent", 74);
		TraceIn("qualifiedIdent", 74);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DBL_COLON241 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> namespaceName240 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident242 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident243 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DBL_COLON241_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_DBL_COLON=new RewriteRuleITokenStream(adaptor,"token DBL_COLON");
		RewriteRuleSubtreeStream stream_namespaceName=new RewriteRuleSubtreeStream(adaptor,"rule namespaceName");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "qualifiedIdent");
		DebugLocation(577, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:579:5: ( ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident ) | ident )
			int alt52=2;
			try { DebugEnterDecision(52, false);
			int LA52_0 = input.LA(1);

			if ((LA52_0==IDENT))
			{
				int LA52_1 = input.LA(2);

				if ((EvaluatePredicate(synpred15_AS3_fragment)))
				{
					alt52 = 1;
				}
				else if ((true))
				{
					alt52 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 52, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA52_0==INTERNAL||LA52_0==PRIVATE||(LA52_0>=PROTECTED && LA52_0<=PUBLIC)) && (EvaluatePredicate(synpred15_AS3_fragment)))
			{
				alt52 = 1;
			}
			else if ((LA52_0==AS||LA52_0==DYNAMIC||LA52_0==GET||LA52_0==IS||LA52_0==NAMESPACE||LA52_0==SET||LA52_0==SUPER||LA52_0==USE||LA52_0==XML))
			{
				alt52 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:579:10: ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident
				{
				DebugLocation(579, 39);
				PushFollow(Follow._namespaceName_in_qualifiedIdent3185);
				namespaceName240=namespaceName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_namespaceName.Add(namespaceName240.Tree);
				DebugLocation(579, 53);
				DBL_COLON241=(IToken)Match(input,DBL_COLON,Follow._DBL_COLON_in_qualifiedIdent3187); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DBL_COLON.Add(DBL_COLON241);

				DebugLocation(579, 63);
				PushFollow(Follow._ident_in_qualifiedIdent3189);
				ident242=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident242.Tree);


				{
				// AST REWRITE
				// elements: DBL_COLON, namespaceName, ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 580:9: -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident )
				{
					DebugLocation(580, 12);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:580:12: ^( QUALIFIED_NAME namespaceName DBL_COLON ident )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(580, 14);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(QUALIFIED_NAME, "QUALIFIED_NAME"), root_1);

					DebugLocation(580, 29);
					adaptor.AddChild(root_1, stream_namespaceName.NextTree());
					DebugLocation(580, 43);
					adaptor.AddChild(root_1, stream_DBL_COLON.NextNode());
					DebugLocation(580, 53);
					adaptor.AddChild(root_1, stream_ident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:581:11: ident
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(581, 11);
				PushFollow(Follow._ident_in_qualifiedIdent3221);
				ident243=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident243.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qualifiedIdent", 74);
			LeaveRule("qualifiedIdent", 74);
			LeaveRule_qualifiedIdent();
		}
		DebugLocation(582, 4);
		} finally { DebugExitRule(GrammarFileName, "qualifiedIdent"); }
		return retval;

	}
	// $ANTLR end "qualifiedIdent"

	partial void EnterRule_namespaceName();
	partial void LeaveRule_namespaceName();

	// $ANTLR start "namespaceName"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:584:1: namespaceName : ( IDENT | reservedNamespace );
	[GrammarRule("namespaceName")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> namespaceName()
	{
		EnterRule_namespaceName();
		EnterRule("namespaceName", 75);
		TraceIn("namespaceName", 75);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IDENT244 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> reservedNamespace245 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree IDENT244_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "namespaceName");
		DebugLocation(584, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:585:2: ( IDENT | reservedNamespace )
			int alt53=2;
			try { DebugEnterDecision(53, false);
			int LA53_0 = input.LA(1);

			if ((LA53_0==IDENT))
			{
				alt53 = 1;
			}
			else if ((LA53_0==INTERNAL||LA53_0==PRIVATE||(LA53_0>=PROTECTED && LA53_0<=PUBLIC)))
			{
				alt53 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:585:4: IDENT
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(585, 4);
				IDENT244=(IToken)Match(input,IDENT,Follow._IDENT_in_namespaceName3235); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IDENT244_tree = (FlyparseTree)adaptor.Create(IDENT244);
				adaptor.AddChild(root_0, IDENT244_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:585:12: reservedNamespace
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(585, 12);
				PushFollow(Follow._reservedNamespace_in_namespaceName3239);
				reservedNamespace245=reservedNamespace();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, reservedNamespace245.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespaceName", 75);
			LeaveRule("namespaceName", 75);
			LeaveRule_namespaceName();
		}
		DebugLocation(586, 1);
		} finally { DebugExitRule(GrammarFileName, "namespaceName"); }
		return retval;

	}
	// $ANTLR end "namespaceName"

	partial void EnterRule_reservedNamespace();
	partial void LeaveRule_reservedNamespace();

	// $ANTLR start "reservedNamespace"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:588:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
	[GrammarRule("reservedNamespace")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> reservedNamespace()
	{
		EnterRule_reservedNamespace();
		EnterRule("reservedNamespace", 76);
		TraceIn("reservedNamespace", 76);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set246 = default(IToken);

		FlyparseTree set246_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "reservedNamespace");
		DebugLocation(588, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:589:2: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(589, 2);

			set246=(IToken)input.LT(1);
			if (input.LA(1)==INTERNAL||input.LA(1)==PRIVATE||(input.LA(1)>=PROTECTED && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set246));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("reservedNamespace", 76);
			LeaveRule("reservedNamespace", 76);
			LeaveRule_reservedNamespace();
		}
		DebugLocation(593, 1);
		} finally { DebugExitRule(GrammarFileName, "reservedNamespace"); }
		return retval;

	}
	// $ANTLR end "reservedNamespace"

	partial void EnterRule_identifierStar();
	partial void LeaveRule_identifierStar();

	// $ANTLR start "identifierStar"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:595:1: identifierStar : ident ( dotIdent )* ( DOT STAR )? -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? ) ;
	[GrammarRule("identifierStar")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> identifierStar()
	{
		EnterRule_identifierStar();
		EnterRule("identifierStar", 77);
		TraceIn("identifierStar", 77);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DOT249 = default(IToken);
		IToken STAR250 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident247 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> dotIdent248 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DOT249_tree = default(FlyparseTree);
		FlyparseTree STAR250_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_dotIdent=new RewriteRuleSubtreeStream(adaptor,"rule dotIdent");
		try { DebugEnterRule(GrammarFileName, "identifierStar");
		DebugLocation(595, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:596:2: ( ident ( dotIdent )* ( DOT STAR )? -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:596:4: ident ( dotIdent )* ( DOT STAR )?
			{
			DebugLocation(596, 4);
			PushFollow(Follow._ident_in_identifierStar3276);
			ident247=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident247.Tree);
			DebugLocation(597, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:597:3: ( dotIdent )*
			try { DebugEnterSubRule(54);
			while (true)
			{
				int alt54=2;
				try { DebugEnterDecision(54, false);
				int LA54_0 = input.LA(1);

				if ((LA54_0==DOT))
				{
					int LA54_1 = input.LA(2);

					if ((LA54_1==AS||LA54_1==DYNAMIC||LA54_1==GET||LA54_1==IDENT||LA54_1==IS||LA54_1==NAMESPACE||LA54_1==SET||LA54_1==SUPER||LA54_1==USE||LA54_1==XML))
					{
						alt54 = 1;
					}


				}


				} finally { DebugExitDecision(54); }
				switch ( alt54 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:597:3: dotIdent
					{
					DebugLocation(597, 3);
					PushFollow(Follow._dotIdent_in_identifierStar3280);
					dotIdent248=dotIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_dotIdent.Add(dotIdent248.Tree);

					}
					break;

				default:
					goto loop54;
				}
			}

			loop54:
				;

			} finally { DebugExitSubRule(54); }

			DebugLocation(598, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:598:3: ( DOT STAR )?
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_0 = input.LA(1);

			if ((LA55_0==DOT))
			{
				alt55 = 1;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:598:4: DOT STAR
				{
				DebugLocation(598, 4);
				DOT249=(IToken)Match(input,DOT,Follow._DOT_in_identifierStar3286); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOT.Add(DOT249);

				DebugLocation(598, 8);
				STAR250=(IToken)Match(input,STAR,Follow._STAR_in_identifierStar3288); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR250);


				}
				break;

			}
			} finally { DebugExitSubRule(55); }



			{
			// AST REWRITE
			// elements: DOT, dotIdent, ident, STAR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 599:3: -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? )
			{
				DebugLocation(599, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:599:6: ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(599, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(IDENTIFIER_STAR, "IDENTIFIER_STAR"), root_1);

				DebugLocation(599, 24);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(599, 30);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:599:30: ( dotIdent )*
				while ( stream_dotIdent.HasNext )
				{
					DebugLocation(599, 30);
					adaptor.AddChild(root_1, stream_dotIdent.NextTree());

				}
				stream_dotIdent.Reset();
				DebugLocation(599, 40);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:599:40: ( DOT )?
				if (stream_DOT.HasNext)
				{
					DebugLocation(599, 40);
					adaptor.AddChild(root_1, stream_DOT.NextNode());

				}
				stream_DOT.Reset();
				DebugLocation(599, 45);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:599:45: ( STAR )?
				if (stream_STAR.HasNext)
				{
					DebugLocation(599, 45);
					adaptor.AddChild(root_1, stream_STAR.NextNode());

				}
				stream_STAR.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifierStar", 77);
			LeaveRule("identifierStar", 77);
			LeaveRule_identifierStar();
		}
		DebugLocation(600, 1);
		} finally { DebugExitRule(GrammarFileName, "identifierStar"); }
		return retval;

	}
	// $ANTLR end "identifierStar"

	partial void EnterRule_dotIdent();
	partial void LeaveRule_dotIdent();

	// $ANTLR start "dotIdent"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:602:1: dotIdent : DOT ident ;
	[GrammarRule("dotIdent")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> dotIdent()
	{
		EnterRule_dotIdent();
		EnterRule("dotIdent", 78);
		TraceIn("dotIdent", 78);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DOT251 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident252 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DOT251_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "dotIdent");
		DebugLocation(602, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:603:5: ( DOT ident )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:603:7: DOT ident
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(603, 7);
			DOT251=(IToken)Match(input,DOT,Follow._DOT_in_dotIdent3323); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DOT251_tree = (FlyparseTree)adaptor.Create(DOT251);
			adaptor.AddChild(root_0, DOT251_tree);
			}
			DebugLocation(603, 11);
			PushFollow(Follow._ident_in_dotIdent3325);
			ident252=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident252.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dotIdent", 78);
			LeaveRule("dotIdent", 78);
			LeaveRule_dotIdent();
		}
		DebugLocation(604, 4);
		} finally { DebugExitRule(GrammarFileName, "dotIdent"); }
		return retval;

	}
	// $ANTLR end "dotIdent"

	partial void EnterRule_ident();
	partial void LeaveRule_ident();

	// $ANTLR start "ident"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:606:1: ident : ( IDENT -> ^( NAME IDENT ) | USE | XML | DYNAMIC | NAMESPACE | IS | AS | GET | SET | SUPER );
	[GrammarRule("ident")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> ident()
	{
		EnterRule_ident();
		EnterRule("ident", 79);
		TraceIn("ident", 79);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken IDENT253 = default(IToken);
		IToken USE254 = default(IToken);
		IToken XML255 = default(IToken);
		IToken DYNAMIC256 = default(IToken);
		IToken NAMESPACE257 = default(IToken);
		IToken IS258 = default(IToken);
		IToken AS259 = default(IToken);
		IToken GET260 = default(IToken);
		IToken SET261 = default(IToken);
		IToken SUPER262 = default(IToken);

		FlyparseTree IDENT253_tree = default(FlyparseTree);
		FlyparseTree USE254_tree = default(FlyparseTree);
		FlyparseTree XML255_tree = default(FlyparseTree);
		FlyparseTree DYNAMIC256_tree = default(FlyparseTree);
		FlyparseTree NAMESPACE257_tree = default(FlyparseTree);
		FlyparseTree IS258_tree = default(FlyparseTree);
		FlyparseTree AS259_tree = default(FlyparseTree);
		FlyparseTree GET260_tree = default(FlyparseTree);
		FlyparseTree SET261_tree = default(FlyparseTree);
		FlyparseTree SUPER262_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		try { DebugEnterRule(GrammarFileName, "ident");
		DebugLocation(606, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:607:2: ( IDENT -> ^( NAME IDENT ) | USE | XML | DYNAMIC | NAMESPACE | IS | AS | GET | SET | SUPER )
			int alt56=10;
			try { DebugEnterDecision(56, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt56 = 1;
				}
				break;
			case USE:
				{
				alt56 = 2;
				}
				break;
			case XML:
				{
				alt56 = 3;
				}
				break;
			case DYNAMIC:
				{
				alt56 = 4;
				}
				break;
			case NAMESPACE:
				{
				alt56 = 5;
				}
				break;
			case IS:
				{
				alt56 = 6;
				}
				break;
			case AS:
				{
				alt56 = 7;
				}
				break;
			case GET:
				{
				alt56 = 8;
				}
				break;
			case SET:
				{
				alt56 = 9;
				}
				break;
			case SUPER:
				{
				alt56 = 10;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 56, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:607:4: IDENT
				{
				DebugLocation(607, 4);
				IDENT253=(IToken)Match(input,IDENT,Follow._IDENT_in_ident3340); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENT.Add(IDENT253);



				{
				// AST REWRITE
				// elements: IDENT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 607:10: -> ^( NAME IDENT )
				{
					DebugLocation(607, 13);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:607:13: ^( NAME IDENT )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(607, 15);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(NAME, "NAME"), root_1);

					DebugLocation(607, 20);
					adaptor.AddChild(root_1, stream_IDENT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:608:4: USE
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(608, 4);
				USE254=(IToken)Match(input,USE,Follow._USE_in_ident3353); if (state.failed) return retval;
				if (state.backtracking == 0) {
				USE254_tree = (FlyparseTree)adaptor.Create(USE254);
				adaptor.AddChild(root_0, USE254_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:609:4: XML
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(609, 4);
				XML255=(IToken)Match(input,XML,Follow._XML_in_ident3358); if (state.failed) return retval;
				if (state.backtracking == 0) {
				XML255_tree = (FlyparseTree)adaptor.Create(XML255);
				adaptor.AddChild(root_0, XML255_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:610:4: DYNAMIC
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(610, 4);
				DYNAMIC256=(IToken)Match(input,DYNAMIC,Follow._DYNAMIC_in_ident3363); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DYNAMIC256_tree = (FlyparseTree)adaptor.Create(DYNAMIC256);
				adaptor.AddChild(root_0, DYNAMIC256_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:611:4: NAMESPACE
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(611, 4);
				NAMESPACE257=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_ident3368); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NAMESPACE257_tree = (FlyparseTree)adaptor.Create(NAMESPACE257);
				adaptor.AddChild(root_0, NAMESPACE257_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:612:4: IS
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(612, 4);
				IS258=(IToken)Match(input,IS,Follow._IS_in_ident3373); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IS258_tree = (FlyparseTree)adaptor.Create(IS258);
				adaptor.AddChild(root_0, IS258_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:613:4: AS
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(613, 4);
				AS259=(IToken)Match(input,AS,Follow._AS_in_ident3378); if (state.failed) return retval;
				if (state.backtracking == 0) {
				AS259_tree = (FlyparseTree)adaptor.Create(AS259);
				adaptor.AddChild(root_0, AS259_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:614:4: GET
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(614, 4);
				GET260=(IToken)Match(input,GET,Follow._GET_in_ident3383); if (state.failed) return retval;
				if (state.backtracking == 0) {
				GET260_tree = (FlyparseTree)adaptor.Create(GET260);
				adaptor.AddChild(root_0, GET260_tree);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:615:4: SET
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(615, 4);
				SET261=(IToken)Match(input,SET,Follow._SET_in_ident3388); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SET261_tree = (FlyparseTree)adaptor.Create(SET261);
				adaptor.AddChild(root_0, SET261_tree);
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:616:4: SUPER
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(616, 4);
				SUPER262=(IToken)Match(input,SUPER,Follow._SUPER_in_ident3393); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SUPER262_tree = (FlyparseTree)adaptor.Create(SUPER262);
				adaptor.AddChild(root_0, SUPER262_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ident", 79);
			LeaveRule("ident", 79);
			LeaveRule_ident();
		}
		DebugLocation(617, 1);
		} finally { DebugExitRule(GrammarFileName, "ident"); }
		return retval;

	}
	// $ANTLR end "ident"

	partial void EnterRule_annotation();
	partial void LeaveRule_annotation();

	// $ANTLR start "annotation"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:619:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
	[GrammarRule("annotation")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> annotation()
	{
		EnterRule_annotation();
		EnterRule("annotation", 80);
		TraceIn("annotation", 80);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LBRACK263 = default(IToken);
		IToken RBRACK266 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident264 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> annotationParamList265 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LBRACK263_tree = default(FlyparseTree);
		FlyparseTree RBRACK266_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleSubtreeStream stream_annotationParamList=new RewriteRuleSubtreeStream(adaptor,"rule annotationParamList");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "annotation");
		DebugLocation(619, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:620:2: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:620:4: LBRACK ident ( annotationParamList )? RBRACK
			{
			DebugLocation(620, 4);
			LBRACK263=(IToken)Match(input,LBRACK,Follow._LBRACK_in_annotation3404); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK263);

			DebugLocation(621, 3);
			PushFollow(Follow._ident_in_annotation3408);
			ident264=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident264.Tree);
			DebugLocation(622, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:622:3: ( annotationParamList )?
			int alt57=2;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			int LA57_0 = input.LA(1);

			if ((LA57_0==LPAREN))
			{
				alt57 = 1;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:622:3: annotationParamList
				{
				DebugLocation(622, 3);
				PushFollow(Follow._annotationParamList_in_annotation3412);
				annotationParamList265=annotationParamList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationParamList.Add(annotationParamList265.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(57); }

			DebugLocation(623, 3);
			RBRACK266=(IToken)Match(input,RBRACK,Follow._RBRACK_in_annotation3417); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK266);



			{
			// AST REWRITE
			// elements: annotationParamList, ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 624:3: -> ^( ANNOTATION ident ( annotationParamList )? )
			{
				DebugLocation(624, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:624:6: ^( ANNOTATION ident ( annotationParamList )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(624, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);

				DebugLocation(624, 19);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(624, 25);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:624:25: ( annotationParamList )?
				if (stream_annotationParamList.HasNext)
				{
					DebugLocation(624, 25);
					adaptor.AddChild(root_1, stream_annotationParamList.NextTree());

				}
				stream_annotationParamList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotation", 80);
			LeaveRule("annotation", 80);
			LeaveRule_annotation();
		}
		DebugLocation(625, 1);
		} finally { DebugExitRule(GrammarFileName, "annotation"); }
		return retval;

	}
	// $ANTLR end "annotation"

	partial void EnterRule_annotationParamList();
	partial void LeaveRule_annotationParamList();

	// $ANTLR start "annotationParamList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:627:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
	[GrammarRule("annotationParamList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> annotationParamList()
	{
		EnterRule_annotationParamList();
		EnterRule("annotationParamList", 81);
		TraceIn("annotationParamList", 81);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN267 = default(IToken);
		IToken COMMA269 = default(IToken);
		IToken RPAREN271 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> annotationParam268 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> annotationParam270 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN267_tree = default(FlyparseTree);
		FlyparseTree COMMA269_tree = default(FlyparseTree);
		FlyparseTree RPAREN271_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_annotationParam=new RewriteRuleSubtreeStream(adaptor,"rule annotationParam");
		try { DebugEnterRule(GrammarFileName, "annotationParamList");
		DebugLocation(627, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:628:2: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:629:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
			{
			DebugLocation(629, 3);
			LPAREN267=(IToken)Match(input,LPAREN,Follow._LPAREN_in_annotationParamList3443); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN267);

			DebugLocation(630, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:630:3: ( annotationParam ( COMMA annotationParam )* )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_0 = input.LA(1);

			if ((LA59_0==AS||LA59_0==DECIMAL_LITERAL||LA59_0==DYNAMIC||(LA59_0>=FALSE && LA59_0<=FLOAT_LITERAL)||LA59_0==GET||(LA59_0>=HEX_LITERAL && LA59_0<=IDENT)||LA59_0==IS||LA59_0==NAMESPACE||LA59_0==NULL||LA59_0==OCTAL_LITERAL||LA59_0==REGEX_LITERAL||LA59_0==SET||(LA59_0>=STRING_LITERAL_DOUBLE && LA59_0<=SUPER)||LA59_0==TRUE||LA59_0==USE||LA59_0==XML||LA59_0==XML_LITERAL))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:630:5: annotationParam ( COMMA annotationParam )*
				{
				DebugLocation(630, 5);
				PushFollow(Follow._annotationParam_in_annotationParamList3449);
				annotationParam268=annotationParam();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationParam.Add(annotationParam268.Tree);
				DebugLocation(631, 4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:631:4: ( COMMA annotationParam )*
				try { DebugEnterSubRule(58);
				while (true)
				{
					int alt58=2;
					try { DebugEnterDecision(58, false);
					int LA58_0 = input.LA(1);

					if ((LA58_0==COMMA))
					{
						alt58 = 1;
					}


					} finally { DebugExitDecision(58); }
					switch ( alt58 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:631:5: COMMA annotationParam
						{
						DebugLocation(631, 5);
						COMMA269=(IToken)Match(input,COMMA,Follow._COMMA_in_annotationParamList3455); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA269);

						DebugLocation(631, 11);
						PushFollow(Follow._annotationParam_in_annotationParamList3457);
						annotationParam270=annotationParam();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_annotationParam.Add(annotationParam270.Tree);

						}
						break;

					default:
						goto loop58;
					}
				}

				loop58:
					;

				} finally { DebugExitSubRule(58); }


				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(633, 3);
			RPAREN271=(IToken)Match(input,RPAREN,Follow._RPAREN_in_annotationParamList3468); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN271);



			{
			// AST REWRITE
			// elements: annotationParam
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 634:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
			{
				DebugLocation(634, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:634:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(634, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);

				DebugLocation(634, 26);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:634:26: ( annotationParam )*
				while ( stream_annotationParam.HasNext )
				{
					DebugLocation(634, 26);
					adaptor.AddChild(root_1, stream_annotationParam.NextTree());

				}
				stream_annotationParam.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotationParamList", 81);
			LeaveRule("annotationParamList", 81);
			LeaveRule_annotationParamList();
		}
		DebugLocation(635, 1);
		} finally { DebugExitRule(GrammarFileName, "annotationParamList"); }
		return retval;

	}
	// $ANTLR end "annotationParamList"

	partial void EnterRule_annotationParam();
	partial void LeaveRule_annotationParam();

	// $ANTLR start "annotationParam"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:648:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );
	[GrammarRule("annotationParam")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> annotationParam()
	{
		EnterRule_annotationParam();
		EnterRule("annotationParam", 82);
		TraceIn("annotationParam", 82);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken ASSIGN273 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident272 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> constant274 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> constant275 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> ident276 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree ASSIGN273_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "annotationParam");
		DebugLocation(648, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:649:2: ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident )
			int alt60=3;
			try { DebugEnterDecision(60, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA60_1 = input.LA(2);

				if ((LA60_1==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_1==COMMA||LA60_1==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case USE:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 2, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case XML:
				{
				int LA60_3 = input.LA(2);

				if ((LA60_3==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_3==COMMA||LA60_3==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DYNAMIC:
				{
				int LA60_4 = input.LA(2);

				if ((LA60_4==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_4==COMMA||LA60_4==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 4, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NAMESPACE:
				{
				int LA60_5 = input.LA(2);

				if ((LA60_5==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_5==COMMA||LA60_5==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 5, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IS:
				{
				int LA60_6 = input.LA(2);

				if ((LA60_6==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_6==COMMA||LA60_6==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 6, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case AS:
				{
				int LA60_7 = input.LA(2);

				if ((LA60_7==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_7==COMMA||LA60_7==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 7, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case GET:
				{
				int LA60_8 = input.LA(2);

				if ((LA60_8==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_8==COMMA||LA60_8==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 8, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SET:
				{
				int LA60_9 = input.LA(2);

				if ((LA60_9==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_9==COMMA||LA60_9==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 9, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SUPER:
				{
				int LA60_10 = input.LA(2);

				if ((LA60_10==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_10==COMMA||LA60_10==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 10, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DECIMAL_LITERAL:
			case FALSE:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case NULL:
			case OCTAL_LITERAL:
			case REGEX_LITERAL:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case TRUE:
			case XML_LITERAL:
				{
				alt60 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:650:3: ident ASSIGN constant
				{
				DebugLocation(650, 3);
				PushFollow(Follow._ident_in_annotationParam3495);
				ident272=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident272.Tree);
				DebugLocation(650, 9);
				ASSIGN273=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_annotationParam3497); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN273);

				DebugLocation(650, 16);
				PushFollow(Follow._constant_in_annotationParam3499);
				constant274=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant274.Tree);


				{
				// AST REWRITE
				// elements: ASSIGN, constant, ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 650:25: -> ^( ASSIGN ident constant )
				{
					DebugLocation(650, 28);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:650:28: ^( ASSIGN ident constant )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(650, 30);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(650, 37);
					adaptor.AddChild(root_1, stream_ident.NextTree());
					DebugLocation(650, 43);
					adaptor.AddChild(root_1, stream_constant.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:651:4: constant
				{
				DebugLocation(651, 4);
				PushFollow(Follow._constant_in_annotationParam3514);
				constant275=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant275.Tree);


				{
				// AST REWRITE
				// elements: constant
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 651:13: -> constant
				{
					DebugLocation(651, 16);
					adaptor.AddChild(root_0, stream_constant.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:652:4: ident
				{
				DebugLocation(652, 4);
				PushFollow(Follow._ident_in_annotationParam3523);
				ident276=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident276.Tree);


				{
				// AST REWRITE
				// elements: ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 652:10: -> ident
				{
					DebugLocation(652, 13);
					adaptor.AddChild(root_0, stream_ident.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotationParam", 82);
			LeaveRule("annotationParam", 82);
			LeaveRule_annotationParam();
		}
		DebugLocation(653, 1);
		} finally { DebugExitRule(GrammarFileName, "annotationParam"); }
		return retval;

	}
	// $ANTLR end "annotationParam"

	partial void EnterRule_modifiers();
	partial void LeaveRule_modifiers();

	// $ANTLR start "modifiers"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:656:1: modifiers : ( modifier ( modifier )* )? -> ^( MODIFIER_LIST ( modifier )* ) ;
	[GrammarRule("modifiers")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> modifiers()
	{
		EnterRule_modifiers();
		EnterRule("modifiers", 83);
		TraceIn("modifiers", 83);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> modifier277 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> modifier278 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_modifier=new RewriteRuleSubtreeStream(adaptor,"rule modifier");
		try { DebugEnterRule(GrammarFileName, "modifiers");
		DebugLocation(656, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:2: ( ( modifier ( modifier )* )? -> ^( MODIFIER_LIST ( modifier )* ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:4: ( modifier ( modifier )* )?
			{
			DebugLocation(657, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:4: ( modifier ( modifier )* )?
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_0 = input.LA(1);

			if ((LA62_0==DYNAMIC||LA62_0==IDENT||LA62_0==INTERNAL||LA62_0==PRIVATE||(LA62_0>=PROTECTED && LA62_0<=PUBLIC)||LA62_0==STATIC||(LA62_0>=244 && LA62_0<=246)||LA62_0==250||LA62_0==252))
			{
				alt62 = 1;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:6: modifier ( modifier )*
				{
				DebugLocation(657, 6);
				PushFollow(Follow._modifier_in_modifiers3541);
				modifier277=modifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_modifier.Add(modifier277.Tree);
				DebugLocation(657, 15);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:15: ( modifier )*
				try { DebugEnterSubRule(61);
				while (true)
				{
					int alt61=2;
					try { DebugEnterDecision(61, false);
					int LA61_0 = input.LA(1);

					if ((LA61_0==DYNAMIC||LA61_0==IDENT||LA61_0==INTERNAL||LA61_0==PRIVATE||(LA61_0>=PROTECTED && LA61_0<=PUBLIC)||LA61_0==STATIC||(LA61_0>=244 && LA61_0<=246)||LA61_0==250||LA61_0==252))
					{
						alt61 = 1;
					}


					} finally { DebugExitDecision(61); }
					switch ( alt61 )
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:657:16: modifier
						{
						DebugLocation(657, 16);
						PushFollow(Follow._modifier_in_modifiers3544);
						modifier278=modifier();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_modifier.Add(modifier278.Tree);

						}
						break;

					default:
						goto loop61;
					}
				}

				loop61:
					;

				} finally { DebugExitSubRule(61); }


				}
				break;

			}
			} finally { DebugExitSubRule(62); }



			{
			// AST REWRITE
			// elements: modifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 658:2: -> ^( MODIFIER_LIST ( modifier )* )
			{
				DebugLocation(658, 5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:658:5: ^( MODIFIER_LIST ( modifier )* )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(658, 7);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(MODIFIER_LIST, "MODIFIER_LIST"), root_1);

				DebugLocation(658, 21);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:658:21: ( modifier )*
				while ( stream_modifier.HasNext )
				{
					DebugLocation(658, 21);
					adaptor.AddChild(root_1, stream_modifier.NextTree());

				}
				stream_modifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modifiers", 83);
			LeaveRule("modifiers", 83);
			LeaveRule_modifiers();
		}
		DebugLocation(659, 1);
		} finally { DebugExitRule(GrammarFileName, "modifiers"); }
		return retval;

	}
	// $ANTLR end "modifiers"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();

	// $ANTLR start "modifier"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:661:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
	[GrammarRule("modifier")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 84);
		TraceIn("modifier", 84);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken STATIC280 = default(IToken);
		IToken string_literal281 = default(IToken);
		IToken string_literal282 = default(IToken);
		IToken string_literal283 = default(IToken);
		IToken string_literal284 = default(IToken);
		IToken DYNAMIC285 = default(IToken);
		IToken string_literal286 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> namespaceName279 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree STATIC280_tree = default(FlyparseTree);
		FlyparseTree string_literal281_tree = default(FlyparseTree);
		FlyparseTree string_literal282_tree = default(FlyparseTree);
		FlyparseTree string_literal283_tree = default(FlyparseTree);
		FlyparseTree string_literal284_tree = default(FlyparseTree);
		FlyparseTree DYNAMIC285_tree = default(FlyparseTree);
		FlyparseTree string_literal286_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(661, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:662:2: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
			int alt63=8;
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case IDENT:
			case INTERNAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
				{
				alt63 = 1;
				}
				break;
			case STATIC:
				{
				alt63 = 2;
				}
				break;
			case 246:
				{
				alt63 = 3;
				}
				break;
			case 244:
				{
				alt63 = 4;
				}
				break;
			case 245:
				{
				alt63 = 5;
				}
				break;
			case 252:
				{
				alt63 = 6;
				}
				break;
			case DYNAMIC:
				{
				alt63 = 7;
				}
				break;
			case 250:
				{
				alt63 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:662:4: namespaceName
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(662, 4);
				PushFollow(Follow._namespaceName_in_modifier3570);
				namespaceName279=namespaceName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceName279.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:663:4: STATIC
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(663, 4);
				STATIC280=(IToken)Match(input,STATIC,Follow._STATIC_in_modifier3575); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STATIC280_tree = (FlyparseTree)adaptor.Create(STATIC280);
				adaptor.AddChild(root_0, STATIC280_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:664:4: 'final'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(664, 4);
				string_literal281=(IToken)Match(input,246,Follow._246_in_modifier3580); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal281_tree = (FlyparseTree)adaptor.Create(string_literal281);
				adaptor.AddChild(root_0, string_literal281_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:665:4: 'enumerable'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(665, 4);
				string_literal282=(IToken)Match(input,244,Follow._244_in_modifier3585); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal282_tree = (FlyparseTree)adaptor.Create(string_literal282);
				adaptor.AddChild(root_0, string_literal282_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:666:4: 'explicit'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(666, 4);
				string_literal283=(IToken)Match(input,245,Follow._245_in_modifier3590); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal283_tree = (FlyparseTree)adaptor.Create(string_literal283);
				adaptor.AddChild(root_0, string_literal283_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:667:4: 'override'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(667, 4);
				string_literal284=(IToken)Match(input,252,Follow._252_in_modifier3595); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal284_tree = (FlyparseTree)adaptor.Create(string_literal284);
				adaptor.AddChild(root_0, string_literal284_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:668:4: DYNAMIC
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(668, 4);
				DYNAMIC285=(IToken)Match(input,DYNAMIC,Follow._DYNAMIC_in_modifier3600); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DYNAMIC285_tree = (FlyparseTree)adaptor.Create(DYNAMIC285);
				adaptor.AddChild(root_0, DYNAMIC285_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:669:4: 'intrinsic'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(669, 4);
				string_literal286=(IToken)Match(input,250,Follow._250_in_modifier3605); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal286_tree = (FlyparseTree)adaptor.Create(string_literal286);
				adaptor.AddChild(root_0, string_literal286_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modifier", 84);
			LeaveRule("modifier", 84);
			LeaveRule_modifier();
		}
		DebugLocation(670, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return retval;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();

	// $ANTLR start "arguments"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:672:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS LPAREN expressionList RPAREN ) | LPAREN RPAREN -> ^( ARGUMENTS LPAREN RPAREN ) );
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 85);
		TraceIn("arguments", 85);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN287 = default(IToken);
		IToken RPAREN289 = default(IToken);
		IToken LPAREN290 = default(IToken);
		IToken RPAREN291 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList288 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN287_tree = default(FlyparseTree);
		FlyparseTree RPAREN289_tree = default(FlyparseTree);
		FlyparseTree LPAREN290_tree = default(FlyparseTree);
		FlyparseTree RPAREN291_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(672, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:673:2: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS LPAREN expressionList RPAREN ) | LPAREN RPAREN -> ^( ARGUMENTS LPAREN RPAREN ) )
			int alt64=2;
			try { DebugEnterDecision(64, false);
			int LA64_0 = input.LA(1);

			if ((LA64_0==LPAREN))
			{
				int LA64_1 = input.LA(2);

				if ((LA64_1==RPAREN))
				{
					alt64 = 2;
				}
				else if ((LA64_1==AS||LA64_1==BNOT||(LA64_1>=DEC && LA64_1<=DECIMAL_LITERAL)||(LA64_1>=DYNAMIC && LA64_1<=E4X_ATTRI)||(LA64_1>=FALSE && LA64_1<=FLOAT_LITERAL)||LA64_1==FUNCTION||LA64_1==GET||(LA64_1>=HEX_LITERAL && LA64_1<=IDENT)||LA64_1==INC||(LA64_1>=INTERNAL && LA64_1<=IS)||(LA64_1>=LBRACK && LA64_1<=LCURLY)||LA64_1==LNOT||LA64_1==LPAREN||LA64_1==MINUS||LA64_1==NAMESPACE||LA64_1==NEW||LA64_1==NULL||LA64_1==OCTAL_LITERAL||LA64_1==PLUS||LA64_1==PRIVATE||(LA64_1>=PROTECTED && LA64_1<=PUBLIC)||LA64_1==REGEX_LITERAL||LA64_1==SET||(LA64_1>=STRING_LITERAL_DOUBLE && LA64_1<=SUPER)||LA64_1==TRUE||LA64_1==USE||LA64_1==XML||LA64_1==XML_LITERAL||LA64_1==243||(LA64_1>=255 && LA64_1<=257)))
				{
					alt64 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 64, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:673:4: LPAREN expressionList RPAREN
				{
				DebugLocation(673, 4);
				LPAREN287=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments3616); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN287);

				DebugLocation(673, 11);
				PushFollow(Follow._expressionList_in_arguments3618);
				expressionList288=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList288.Tree);
				DebugLocation(673, 26);
				RPAREN289=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments3620); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN289);



				{
				// AST REWRITE
				// elements: RPAREN, expressionList, LPAREN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 674:3: -> ^( ARGUMENTS LPAREN expressionList RPAREN )
				{
					DebugLocation(674, 6);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:674:6: ^( ARGUMENTS LPAREN expressionList RPAREN )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(674, 8);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

					DebugLocation(674, 18);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(674, 25);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());
					DebugLocation(674, 40);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:676:4: LPAREN RPAREN
				{
				DebugLocation(676, 4);
				LPAREN290=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments3640); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN290);

				DebugLocation(676, 11);
				RPAREN291=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments3642); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN291);



				{
				// AST REWRITE
				// elements: RPAREN, LPAREN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 677:3: -> ^( ARGUMENTS LPAREN RPAREN )
				{
					DebugLocation(677, 6);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:677:6: ^( ARGUMENTS LPAREN RPAREN )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(677, 8);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

					DebugLocation(677, 18);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(677, 25);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 85);
			LeaveRule("arguments", 85);
			LeaveRule_arguments();
		}
		DebugLocation(678, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();

	// $ANTLR start "arrayLiteral"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:680:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 86);
		TraceIn("arrayLiteral", 86);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LBRACK292 = default(IToken);
		IToken RBRACK294 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> elementList293 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LBRACK292_tree = default(FlyparseTree);
		FlyparseTree RBRACK294_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleSubtreeStream stream_elementList=new RewriteRuleSubtreeStream(adaptor,"rule elementList");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(680, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:681:2: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:681:4: LBRACK ( elementList )? RBRACK
			{
			DebugLocation(681, 4);
			LBRACK292=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayLiteral3665); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK292);

			DebugLocation(681, 11);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:681:11: ( elementList )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_0 = input.LA(1);

			if ((LA65_0==AS||LA65_0==BNOT||LA65_0==COMMA||(LA65_0>=DEC && LA65_0<=DECIMAL_LITERAL)||(LA65_0>=DYNAMIC && LA65_0<=E4X_ATTRI)||(LA65_0>=FALSE && LA65_0<=FLOAT_LITERAL)||LA65_0==FUNCTION||LA65_0==GET||(LA65_0>=HEX_LITERAL && LA65_0<=IDENT)||LA65_0==INC||(LA65_0>=INTERNAL && LA65_0<=IS)||(LA65_0>=LBRACK && LA65_0<=LCURLY)||LA65_0==LNOT||LA65_0==LPAREN||LA65_0==MINUS||LA65_0==NAMESPACE||LA65_0==NEW||LA65_0==NULL||LA65_0==OCTAL_LITERAL||LA65_0==PLUS||LA65_0==PRIVATE||(LA65_0>=PROTECTED && LA65_0<=PUBLIC)||LA65_0==REGEX_LITERAL||LA65_0==SET||(LA65_0>=STRING_LITERAL_DOUBLE && LA65_0<=SUPER)||LA65_0==TRUE||LA65_0==USE||LA65_0==XML||LA65_0==XML_LITERAL||LA65_0==243||(LA65_0>=255 && LA65_0<=257)))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:681:11: elementList
				{
				DebugLocation(681, 11);
				PushFollow(Follow._elementList_in_arrayLiteral3667);
				elementList293=elementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_elementList.Add(elementList293.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(681, 24);
			RBRACK294=(IToken)Match(input,RBRACK,Follow._RBRACK_in_arrayLiteral3670); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK294);



			{
			// AST REWRITE
			// elements: RBRACK, elementList, LBRACK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 682:3: -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK )
			{
				DebugLocation(682, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:682:6: ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(682, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);

				DebugLocation(682, 22);
				adaptor.AddChild(root_1, stream_LBRACK.NextNode());
				DebugLocation(682, 29);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:682:29: ( elementList )?
				if (stream_elementList.HasNext)
				{
					DebugLocation(682, 29);
					adaptor.AddChild(root_1, stream_elementList.NextTree());

				}
				stream_elementList.Reset();
				DebugLocation(682, 42);
				adaptor.AddChild(root_1, stream_RBRACK.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 86);
			LeaveRule("arrayLiteral", 86);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(683, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_elementList();
	partial void LeaveRule_elementList();

	// $ANTLR start "elementList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:685:1: elementList : ( COMMA !| nonemptyElementList );
	[GrammarRule("elementList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> elementList()
	{
		EnterRule_elementList();
		EnterRule("elementList", 87);
		TraceIn("elementList", 87);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA295 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> nonemptyElementList296 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA295_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "elementList");
		DebugLocation(685, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:686:2: ( COMMA !| nonemptyElementList )
			int alt66=2;
			try { DebugEnterDecision(66, false);
			int LA66_0 = input.LA(1);

			if ((LA66_0==COMMA))
			{
				alt66 = 1;
			}
			else if ((LA66_0==AS||LA66_0==BNOT||(LA66_0>=DEC && LA66_0<=DECIMAL_LITERAL)||(LA66_0>=DYNAMIC && LA66_0<=E4X_ATTRI)||(LA66_0>=FALSE && LA66_0<=FLOAT_LITERAL)||LA66_0==FUNCTION||LA66_0==GET||(LA66_0>=HEX_LITERAL && LA66_0<=IDENT)||LA66_0==INC||(LA66_0>=INTERNAL && LA66_0<=IS)||(LA66_0>=LBRACK && LA66_0<=LCURLY)||LA66_0==LNOT||LA66_0==LPAREN||LA66_0==MINUS||LA66_0==NAMESPACE||LA66_0==NEW||LA66_0==NULL||LA66_0==OCTAL_LITERAL||LA66_0==PLUS||LA66_0==PRIVATE||(LA66_0>=PROTECTED && LA66_0<=PUBLIC)||LA66_0==REGEX_LITERAL||LA66_0==SET||(LA66_0>=STRING_LITERAL_DOUBLE && LA66_0<=SUPER)||LA66_0==TRUE||LA66_0==USE||LA66_0==XML||LA66_0==XML_LITERAL||LA66_0==243||(LA66_0>=255 && LA66_0<=257)))
			{
				alt66 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:686:4: COMMA !
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(686, 9);
				COMMA295=(IToken)Match(input,COMMA,Follow._COMMA_in_elementList3698); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:687:4: nonemptyElementList
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(687, 4);
				PushFollow(Follow._nonemptyElementList_in_elementList3704);
				nonemptyElementList296=nonemptyElementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList296.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementList", 87);
			LeaveRule("elementList", 87);
			LeaveRule_elementList();
		}
		DebugLocation(688, 1);
		} finally { DebugExitRule(GrammarFileName, "elementList"); }
		return retval;

	}
	// $ANTLR end "elementList"

	partial void EnterRule_nonemptyElementList();
	partial void LeaveRule_nonemptyElementList();

	// $ANTLR start "nonemptyElementList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:689:1: nonemptyElementList : assignmentExpression ( COMMA ! assignmentExpression )* ;
	[GrammarRule("nonemptyElementList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> nonemptyElementList()
	{
		EnterRule_nonemptyElementList();
		EnterRule("nonemptyElementList", 88);
		TraceIn("nonemptyElementList", 88);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA298 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression297 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression299 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA298_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "nonemptyElementList");
		DebugLocation(689, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:690:2: ( assignmentExpression ( COMMA ! assignmentExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:690:4: assignmentExpression ( COMMA ! assignmentExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(690, 4);
			PushFollow(Follow._assignmentExpression_in_nonemptyElementList3714);
			assignmentExpression297=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression297.Tree);
			DebugLocation(690, 25);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:690:25: ( COMMA ! assignmentExpression )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_0 = input.LA(1);

				if ((LA67_0==COMMA))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:690:26: COMMA ! assignmentExpression
					{
					DebugLocation(690, 31);
					COMMA298=(IToken)Match(input,COMMA,Follow._COMMA_in_nonemptyElementList3717); if (state.failed) return retval;
					DebugLocation(690, 33);
					PushFollow(Follow._assignmentExpression_in_nonemptyElementList3720);
					assignmentExpression299=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression299.Tree);

					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonemptyElementList", 88);
			LeaveRule("nonemptyElementList", 88);
			LeaveRule_nonemptyElementList();
		}
		DebugLocation(691, 1);
		} finally { DebugExitRule(GrammarFileName, "nonemptyElementList"); }
		return retval;

	}
	// $ANTLR end "nonemptyElementList"

	partial void EnterRule_element();
	partial void LeaveRule_element();

	// $ANTLR start "element"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:693:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
	[GrammarRule("element")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> element()
	{
		EnterRule_element();
		EnterRule("element", 89);
		TraceIn("element", 89);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression300 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(693, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:694:2: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:694:4: assignmentExpression
			{
			DebugLocation(694, 4);
			PushFollow(Follow._assignmentExpression_in_element3733);
			assignmentExpression300=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression300.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 695:3: -> ^( ELEMENT assignmentExpression )
			{
				DebugLocation(695, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:695:6: ^( ELEMENT assignmentExpression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(695, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ELEMENT, "ELEMENT"), root_1);

				DebugLocation(695, 16);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element", 89);
			LeaveRule("element", 89);
			LeaveRule_element();
		}
		DebugLocation(696, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();

	// $ANTLR start "objectLiteral"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:699:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 90);
		TraceIn("objectLiteral", 90);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LCURLY301 = default(IToken);
		IToken RCURLY303 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> fieldList302 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LCURLY301_tree = default(FlyparseTree);
		FlyparseTree RCURLY303_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_fieldList=new RewriteRuleSubtreeStream(adaptor,"rule fieldList");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(699, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:700:2: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:700:4: LCURLY ( fieldList )? RCURLY
			{
			DebugLocation(700, 4);
			LCURLY301=(IToken)Match(input,LCURLY,Follow._LCURLY_in_objectLiteral3755); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY301);

			DebugLocation(700, 11);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:700:11: ( fieldList )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_0 = input.LA(1);

			if ((LA68_0==AS||LA68_0==DECIMAL_LITERAL||LA68_0==DYNAMIC||LA68_0==FLOAT_LITERAL||LA68_0==GET||(LA68_0>=HEX_LITERAL && LA68_0<=IDENT)||LA68_0==IS||LA68_0==NAMESPACE||LA68_0==OCTAL_LITERAL||LA68_0==SET||LA68_0==SUPER||LA68_0==USE||LA68_0==XML))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:700:11: fieldList
				{
				DebugLocation(700, 11);
				PushFollow(Follow._fieldList_in_objectLiteral3757);
				fieldList302=fieldList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_fieldList.Add(fieldList302.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(700, 22);
			RCURLY303=(IToken)Match(input,RCURLY,Follow._RCURLY_in_objectLiteral3760); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY303);



			{
			// AST REWRITE
			// elements: fieldList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 701:3: -> ^( OBJECT_LITERAL ( fieldList )? )
			{
				DebugLocation(701, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:701:6: ^( OBJECT_LITERAL ( fieldList )? )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(701, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);

				DebugLocation(701, 23);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:701:23: ( fieldList )?
				if (stream_fieldList.HasNext)
				{
					DebugLocation(701, 23);
					adaptor.AddChild(root_1, stream_fieldList.NextTree());

				}
				stream_fieldList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 90);
			LeaveRule("objectLiteral", 90);
			LeaveRule_objectLiteral();
		}
		DebugLocation(702, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_fieldList();
	partial void LeaveRule_fieldList();

	// $ANTLR start "fieldList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:704:1: fieldList : literalField ( COMMA ! ( literalField )? )* ;
	[GrammarRule("fieldList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> fieldList()
	{
		EnterRule_fieldList();
		EnterRule("fieldList", 91);
		TraceIn("fieldList", 91);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA305 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> literalField304 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> literalField306 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA305_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "fieldList");
		DebugLocation(704, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:2: ( literalField ( COMMA ! ( literalField )? )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:4: literalField ( COMMA ! ( literalField )? )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(705, 4);
			PushFollow(Follow._literalField_in_fieldList3783);
			literalField304=literalField();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, literalField304.Tree);
			DebugLocation(705, 17);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:17: ( COMMA ! ( literalField )? )*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_0 = input.LA(1);

				if ((LA70_0==COMMA))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:18: COMMA ! ( literalField )?
					{
					DebugLocation(705, 23);
					COMMA305=(IToken)Match(input,COMMA,Follow._COMMA_in_fieldList3786); if (state.failed) return retval;
					DebugLocation(705, 25);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:25: ( literalField )?
					int alt69=2;
					try { DebugEnterSubRule(69);
					try { DebugEnterDecision(69, false);
					int LA69_0 = input.LA(1);

					if ((LA69_0==AS||LA69_0==DECIMAL_LITERAL||LA69_0==DYNAMIC||LA69_0==FLOAT_LITERAL||LA69_0==GET||(LA69_0>=HEX_LITERAL && LA69_0<=IDENT)||LA69_0==IS||LA69_0==NAMESPACE||LA69_0==OCTAL_LITERAL||LA69_0==SET||LA69_0==SUPER||LA69_0==USE||LA69_0==XML))
					{
						alt69 = 1;
					}
					} finally { DebugExitDecision(69); }
					switch (alt69)
					{
					case 1:
						DebugEnterAlt(1);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:705:25: literalField
						{
						DebugLocation(705, 25);
						PushFollow(Follow._literalField_in_fieldList3789);
						literalField306=literalField();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, literalField306.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(69); }


					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fieldList", 91);
			LeaveRule("fieldList", 91);
			LeaveRule_fieldList();
		}
		DebugLocation(706, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldList"); }
		return retval;

	}
	// $ANTLR end "fieldList"

	partial void EnterRule_literalField();
	partial void LeaveRule_literalField();

	// $ANTLR start "literalField"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:708:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
	[GrammarRule("literalField")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> literalField()
	{
		EnterRule_literalField();
		EnterRule("literalField", 92);
		TraceIn("literalField", 92);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COLON308 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> fieldName307 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> element309 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COLON308_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
		RewriteRuleSubtreeStream stream_fieldName=new RewriteRuleSubtreeStream(adaptor,"rule fieldName");
		try { DebugEnterRule(GrammarFileName, "literalField");
		DebugLocation(708, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:709:2: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:709:5: fieldName COLON element
			{
			DebugLocation(709, 5);
			PushFollow(Follow._fieldName_in_literalField3806);
			fieldName307=fieldName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fieldName.Add(fieldName307.Tree);
			DebugLocation(709, 15);
			COLON308=(IToken)Match(input,COLON,Follow._COLON_in_literalField3808); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON308);

			DebugLocation(709, 21);
			PushFollow(Follow._element_in_literalField3810);
			element309=element();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_element.Add(element309.Tree);


			{
			// AST REWRITE
			// elements: element, fieldName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 710:3: -> ^( OBJECT_FIELD fieldName element )
			{
				DebugLocation(710, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:710:6: ^( OBJECT_FIELD fieldName element )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(710, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);

				DebugLocation(710, 21);
				adaptor.AddChild(root_1, stream_fieldName.NextTree());
				DebugLocation(710, 31);
				adaptor.AddChild(root_1, stream_element.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literalField", 92);
			LeaveRule("literalField", 92);
			LeaveRule_literalField();
		}
		DebugLocation(711, 1);
		} finally { DebugExitRule(GrammarFileName, "literalField"); }
		return retval;

	}
	// $ANTLR end "literalField"

	partial void EnterRule_fieldName();
	partial void LeaveRule_fieldName();

	// $ANTLR start "fieldName"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:713:1: fieldName : ( ident | number );
	[GrammarRule("fieldName")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> fieldName()
	{
		EnterRule_fieldName();
		EnterRule("fieldName", 93);
		TraceIn("fieldName", 93);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> ident310 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> number311 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "fieldName");
		DebugLocation(713, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:714:2: ( ident | number )
			int alt71=2;
			try { DebugEnterDecision(71, false);
			int LA71_0 = input.LA(1);

			if ((LA71_0==AS||LA71_0==DYNAMIC||LA71_0==GET||LA71_0==IDENT||LA71_0==IS||LA71_0==NAMESPACE||LA71_0==SET||LA71_0==SUPER||LA71_0==USE||LA71_0==XML))
			{
				alt71 = 1;
			}
			else if ((LA71_0==DECIMAL_LITERAL||LA71_0==FLOAT_LITERAL||LA71_0==HEX_LITERAL||LA71_0==OCTAL_LITERAL))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:714:4: ident
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(714, 4);
				PushFollow(Follow._ident_in_fieldName3834);
				ident310=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident310.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:715:4: number
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(715, 4);
				PushFollow(Follow._number_in_fieldName3839);
				number311=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, number311.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fieldName", 93);
			LeaveRule("fieldName", 93);
			LeaveRule_fieldName();
		}
		DebugLocation(716, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldName"); }
		return retval;

	}
	// $ANTLR end "fieldName"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:719:1: expression : assignmentExpression -> ^( EXPRESSION assignmentExpression ) ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 94);
		TraceIn("expression", 94);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression312 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(719, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:720:2: ( assignmentExpression -> ^( EXPRESSION assignmentExpression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:720:4: assignmentExpression
			{
			DebugLocation(720, 4);
			PushFollow(Follow._assignmentExpression_in_expression3851);
			assignmentExpression312=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression312.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 721:9: -> ^( EXPRESSION assignmentExpression )
			{
				DebugLocation(721, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:721:12: ^( EXPRESSION assignmentExpression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(721, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(721, 25);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 94);
			LeaveRule("expression", 94);
			LeaveRule_expression();
		}
		DebugLocation(722, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionList();
	partial void LeaveRule_expressionList();

	// $ANTLR start "expressionList"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:725:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( EXPR_LIST ( assignmentExpression )+ ) ;
	[GrammarRule("expressionList")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> expressionList()
	{
		EnterRule_expressionList();
		EnterRule("expressionList", 95);
		TraceIn("expressionList", 95);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COMMA314 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression313 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression315 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COMMA314_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expressionList");
		DebugLocation(725, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:726:2: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( EXPR_LIST ( assignmentExpression )+ ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:726:4: assignmentExpression ( COMMA assignmentExpression )*
			{
			DebugLocation(726, 4);
			PushFollow(Follow._assignmentExpression_in_expressionList3879);
			assignmentExpression313=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression313.Tree);
			DebugLocation(726, 25);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:726:25: ( COMMA assignmentExpression )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_0 = input.LA(1);

				if ((LA72_0==COMMA))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:726:26: COMMA assignmentExpression
					{
					DebugLocation(726, 26);
					COMMA314=(IToken)Match(input,COMMA,Follow._COMMA_in_expressionList3882); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA314);

					DebugLocation(726, 32);
					PushFollow(Follow._assignmentExpression_in_expressionList3884);
					assignmentExpression315=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression315.Tree);

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 727:9: -> ^( EXPR_LIST ( assignmentExpression )+ )
			{
				DebugLocation(727, 12);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:727:12: ^( EXPR_LIST ( assignmentExpression )+ )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(727, 14);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(EXPR_LIST, "EXPR_LIST"), root_1);

				DebugLocation(727, 24);
				if (!(stream_assignmentExpression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(727, 24);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionList", 95);
			LeaveRule("expressionList", 95);
			LeaveRule_expressionList();
		}
		DebugLocation(728, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionList"); }
		return retval;

	}
	// $ANTLR end "expressionList"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();

	// $ANTLR start "assignmentExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:731:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 96);
		TraceIn("assignmentExpression", 96);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> conditionalExpression316 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentOperator317 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression318 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(731, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:2: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(732, 4);
			PushFollow(Follow._conditionalExpression_in_assignmentExpression3915);
			conditionalExpression316=conditionalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpression316.Tree);
			DebugLocation(732, 26);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:26: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_0 = input.LA(1);

				if ((LA73_0==ASSIGN||LA73_0==BAND_ASSIGN||LA73_0==BOR_ASSIGN||LA73_0==BSR_ASSIGN||LA73_0==BXOR_ASSIGN||LA73_0==DIV_ASSIGN||LA73_0==LAND_ASSIGN||LA73_0==LOR_ASSIGN||LA73_0==MINUS_ASSIGN||LA73_0==MOD_ASSIGN||LA73_0==PLUS_ASSIGN||LA73_0==SL_ASSIGN||LA73_0==SR_ASSIGN||LA73_0==STAR_ASSIGN))
				{
					int LA73_2 = input.LA(2);

					if ((EvaluatePredicate(synpred16_AS3_fragment)))
					{
						alt73 = 1;
					}


				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:27: ( assignmentOperator )=> assignmentOperator assignmentExpression
					{
					DebugLocation(732, 51);
					PushFollow(Follow._assignmentOperator_in_assignmentExpression3924);
					assignmentOperator317=assignmentOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator317.Tree);
					DebugLocation(732, 70);
					PushFollow(Follow._assignmentExpression_in_assignmentExpression3926);
					assignmentExpression318=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression318.Tree);

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 96);
			LeaveRule("assignmentExpression", 96);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(733, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();

	// $ANTLR start "assignmentOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:735:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 97);
		TraceIn("assignmentOperator", 97);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set319 = default(IToken);

		FlyparseTree set319_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(735, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:736:2: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(736, 2);

			set319=(IToken)input.LT(1);
			if (input.LA(1)==ASSIGN||input.LA(1)==BAND_ASSIGN||input.LA(1)==BOR_ASSIGN||input.LA(1)==BSR_ASSIGN||input.LA(1)==BXOR_ASSIGN||input.LA(1)==DIV_ASSIGN||input.LA(1)==LAND_ASSIGN||input.LA(1)==LOR_ASSIGN||input.LA(1)==MINUS_ASSIGN||input.LA(1)==MOD_ASSIGN||input.LA(1)==PLUS_ASSIGN||input.LA(1)==SL_ASSIGN||input.LA(1)==SR_ASSIGN||input.LA(1)==STAR_ASSIGN)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set319));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 97);
			LeaveRule("assignmentOperator", 97);
			LeaveRule_assignmentOperator();
		}
		DebugLocation(750, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();

	// $ANTLR start "conditionalExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:753:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 98);
		TraceIn("conditionalExpression", 98);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken QUESTION321 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> logicalOrExpression320 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> conditionalSubExpression322 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree QUESTION321_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_logicalOrExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
		RewriteRuleSubtreeStream stream_conditionalSubExpression=new RewriteRuleSubtreeStream(adaptor,"rule conditionalSubExpression");
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(753, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:754:2: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:754:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
			{
			DebugLocation(754, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:754:4: ( logicalOrExpression -> logicalOrExpression )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:754:5: logicalOrExpression
			{
			DebugLocation(754, 5);
			PushFollow(Follow._logicalOrExpression_in_conditionalExpression4019);
			logicalOrExpression320=logicalOrExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalOrExpression.Add(logicalOrExpression320.Tree);


			{
			// AST REWRITE
			// elements: logicalOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 754:25: -> logicalOrExpression
			{
				DebugLocation(754, 28);
				adaptor.AddChild(root_0, stream_logicalOrExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(755, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:755:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
			int alt74=2;
			try { DebugEnterSubRule(74);
			try { DebugEnterDecision(74, false);
			int LA74_0 = input.LA(1);

			if ((LA74_0==QUESTION))
			{
				alt74 = 1;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:756:4: QUESTION conditionalSubExpression
				{
				DebugLocation(756, 4);
				QUESTION321=(IToken)Match(input,QUESTION,Follow._QUESTION_in_conditionalExpression4033); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUESTION.Add(QUESTION321);

				DebugLocation(757, 4);
				PushFollow(Follow._conditionalSubExpression_in_conditionalExpression4038);
				conditionalSubExpression322=conditionalSubExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalSubExpression.Add(conditionalSubExpression322.Tree);


				{
				// AST REWRITE
				// elements: conditionalExpression, conditionalSubExpression, QUESTION
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 758:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
				{
					DebugLocation(758, 7);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:758:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(758, 9);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_QUESTION.NextNode(), root_1);

					DebugLocation(758, 19);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(758, 41);
					adaptor.AddChild(root_1, stream_conditionalSubExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(74); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 98);
			LeaveRule("conditionalExpression", 98);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(760, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalSubExpression();
	partial void LeaveRule_conditionalSubExpression();

	// $ANTLR start "conditionalSubExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:761:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
	[GrammarRule("conditionalSubExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> conditionalSubExpression()
	{
		EnterRule_conditionalSubExpression();
		EnterRule("conditionalSubExpression", 99);
		TraceIn("conditionalSubExpression", 99);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken COLON324 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression323 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression325 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree COLON324_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "conditionalSubExpression");
		DebugLocation(761, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:762:2: ( assignmentExpression COLON assignmentExpression )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:762:4: assignmentExpression COLON assignmentExpression
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(762, 4);
			PushFollow(Follow._assignmentExpression_in_conditionalSubExpression4067);
			assignmentExpression323=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression323.Tree);
			DebugLocation(762, 25);
			COLON324=(IToken)Match(input,COLON,Follow._COLON_in_conditionalSubExpression4069); if (state.failed) return retval;
			if (state.backtracking == 0) {
			COLON324_tree = (FlyparseTree)adaptor.Create(COLON324);
			adaptor.AddChild(root_0, COLON324_tree);
			}
			DebugLocation(762, 31);
			PushFollow(Follow._assignmentExpression_in_conditionalSubExpression4071);
			assignmentExpression325=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression325.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalSubExpression", 99);
			LeaveRule("conditionalSubExpression", 99);
			LeaveRule_conditionalSubExpression();
		}
		DebugLocation(763, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalSubExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalSubExpression"

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();

	// $ANTLR start "logicalOrExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:768:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 100);
		TraceIn("logicalOrExpression", 100);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> logicalAndExpression326 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> logicalOrOperator327 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> logicalAndExpression328 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(768, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:769:2: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:769:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(769, 4);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression4085);
			logicalAndExpression326=logicalAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression326.Tree);
			DebugLocation(770, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:770:3: ( logicalOrOperator logicalAndExpression )*
			try { DebugEnterSubRule(75);
			while (true)
			{
				int alt75=2;
				try { DebugEnterDecision(75, false);
				int LA75_0 = input.LA(1);

				if ((LA75_0==LOR||LA75_0==251))
				{
					alt75 = 1;
				}


				} finally { DebugExitDecision(75); }
				switch ( alt75 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:770:4: logicalOrOperator logicalAndExpression
					{
					DebugLocation(770, 4);
					PushFollow(Follow._logicalOrOperator_in_logicalOrExpression4090);
					logicalOrOperator327=logicalOrOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalOrOperator327.Tree);
					DebugLocation(770, 22);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression4092);
					logicalAndExpression328=logicalAndExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression328.Tree);

					}
					break;

				default:
					goto loop75;
				}
			}

			loop75:
				;

			} finally { DebugExitSubRule(75); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 100);
			LeaveRule("logicalOrExpression", 100);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(771, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	partial void EnterRule_logicalOrOperator();
	partial void LeaveRule_logicalOrOperator();

	// $ANTLR start "logicalOrOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:773:1: logicalOrOperator : ( LOR | 'or' );
	[GrammarRule("logicalOrOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> logicalOrOperator()
	{
		EnterRule_logicalOrOperator();
		EnterRule("logicalOrOperator", 101);
		TraceIn("logicalOrOperator", 101);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set329 = default(IToken);

		FlyparseTree set329_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "logicalOrOperator");
		DebugLocation(773, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:774:2: ( LOR | 'or' )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(774, 2);

			set329=(IToken)input.LT(1);
			if (input.LA(1)==LOR||input.LA(1)==251)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set329));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrOperator", 101);
			LeaveRule("logicalOrOperator", 101);
			LeaveRule_logicalOrOperator();
		}
		DebugLocation(775, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrOperator"); }
		return retval;

	}
	// $ANTLR end "logicalOrOperator"

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();

	// $ANTLR start "logicalAndExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:778:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 102);
		TraceIn("logicalAndExpression", 102);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseOrExpression330 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> logicalAndOperator331 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseOrExpression332 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(778, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:779:2: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:779:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(779, 4);
			PushFollow(Follow._bitwiseOrExpression_in_logicalAndExpression4121);
			bitwiseOrExpression330=bitwiseOrExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression330.Tree);
			DebugLocation(780, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:780:3: ( logicalAndOperator bitwiseOrExpression )*
			try { DebugEnterSubRule(76);
			while (true)
			{
				int alt76=2;
				try { DebugEnterDecision(76, false);
				int LA76_0 = input.LA(1);

				if ((LA76_0==LAND||LA76_0==241))
				{
					alt76 = 1;
				}


				} finally { DebugExitDecision(76); }
				switch ( alt76 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:780:4: logicalAndOperator bitwiseOrExpression
					{
					DebugLocation(780, 4);
					PushFollow(Follow._logicalAndOperator_in_logicalAndExpression4126);
					logicalAndOperator331=logicalAndOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndOperator331.Tree);
					DebugLocation(780, 23);
					PushFollow(Follow._bitwiseOrExpression_in_logicalAndExpression4128);
					bitwiseOrExpression332=bitwiseOrExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression332.Tree);

					}
					break;

				default:
					goto loop76;
				}
			}

			loop76:
				;

			} finally { DebugExitSubRule(76); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 102);
			LeaveRule("logicalAndExpression", 102);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(781, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	partial void EnterRule_logicalAndOperator();
	partial void LeaveRule_logicalAndOperator();

	// $ANTLR start "logicalAndOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:783:1: logicalAndOperator : ( LAND | 'and' );
	[GrammarRule("logicalAndOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> logicalAndOperator()
	{
		EnterRule_logicalAndOperator();
		EnterRule("logicalAndOperator", 103);
		TraceIn("logicalAndOperator", 103);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set333 = default(IToken);

		FlyparseTree set333_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "logicalAndOperator");
		DebugLocation(783, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:784:2: ( LAND | 'and' )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(784, 2);

			set333=(IToken)input.LT(1);
			if (input.LA(1)==LAND||input.LA(1)==241)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set333));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndOperator", 103);
			LeaveRule("logicalAndOperator", 103);
			LeaveRule_logicalAndOperator();
		}
		DebugLocation(785, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndOperator"); }
		return retval;

	}
	// $ANTLR end "logicalAndOperator"

	partial void EnterRule_bitwiseOrExpression();
	partial void LeaveRule_bitwiseOrExpression();

	// $ANTLR start "bitwiseOrExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:788:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 104);
		TraceIn("bitwiseOrExpression", 104);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken BOR335 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseXorExpression334 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseXorExpression336 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree BOR335_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(788, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:789:2: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:789:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(789, 4);
			PushFollow(Follow._bitwiseXorExpression_in_bitwiseOrExpression4157);
			bitwiseXorExpression334=bitwiseXorExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression334.Tree);
			DebugLocation(790, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:790:3: ( BOR bitwiseXorExpression )*
			try { DebugEnterSubRule(77);
			while (true)
			{
				int alt77=2;
				try { DebugEnterDecision(77, false);
				int LA77_0 = input.LA(1);

				if ((LA77_0==BOR))
				{
					alt77 = 1;
				}


				} finally { DebugExitDecision(77); }
				switch ( alt77 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:790:4: BOR bitwiseXorExpression
					{
					DebugLocation(790, 4);
					BOR335=(IToken)Match(input,BOR,Follow._BOR_in_bitwiseOrExpression4162); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BOR335_tree = (FlyparseTree)adaptor.Create(BOR335);
					adaptor.AddChild(root_0, BOR335_tree);
					}
					DebugLocation(790, 8);
					PushFollow(Follow._bitwiseXorExpression_in_bitwiseOrExpression4164);
					bitwiseXorExpression336=bitwiseXorExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression336.Tree);

					}
					break;

				default:
					goto loop77;
				}
			}

			loop77:
				;

			} finally { DebugExitSubRule(77); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 104);
			LeaveRule("bitwiseOrExpression", 104);
			LeaveRule_bitwiseOrExpression();
		}
		DebugLocation(791, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"

	partial void EnterRule_bitwiseXorExpression();
	partial void LeaveRule_bitwiseXorExpression();

	// $ANTLR start "bitwiseXorExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:794:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXorExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseXorExpression()
	{
		EnterRule_bitwiseXorExpression();
		EnterRule("bitwiseXorExpression", 105);
		TraceIn("bitwiseXorExpression", 105);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken BXOR338 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseAndExpression337 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseAndExpression339 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree BXOR338_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseXorExpression");
		DebugLocation(794, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:795:2: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:795:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(795, 4);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXorExpression4178);
			bitwiseAndExpression337=bitwiseAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression337.Tree);
			DebugLocation(796, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:796:3: ( BXOR bitwiseAndExpression )*
			try { DebugEnterSubRule(78);
			while (true)
			{
				int alt78=2;
				try { DebugEnterDecision(78, false);
				int LA78_0 = input.LA(1);

				if ((LA78_0==BXOR))
				{
					alt78 = 1;
				}


				} finally { DebugExitDecision(78); }
				switch ( alt78 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:796:4: BXOR bitwiseAndExpression
					{
					DebugLocation(796, 4);
					BXOR338=(IToken)Match(input,BXOR,Follow._BXOR_in_bitwiseXorExpression4183); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BXOR338_tree = (FlyparseTree)adaptor.Create(BXOR338);
					adaptor.AddChild(root_0, BXOR338_tree);
					}
					DebugLocation(796, 9);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXorExpression4185);
					bitwiseAndExpression339=bitwiseAndExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression339.Tree);

					}
					break;

				default:
					goto loop78;
				}
			}

			loop78:
				;

			} finally { DebugExitSubRule(78); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXorExpression", 105);
			LeaveRule("bitwiseXorExpression", 105);
			LeaveRule_bitwiseXorExpression();
		}
		DebugLocation(797, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXorExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXorExpression"

	partial void EnterRule_bitwiseAndExpression();
	partial void LeaveRule_bitwiseAndExpression();

	// $ANTLR start "bitwiseAndExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:800:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 106);
		TraceIn("bitwiseAndExpression", 106);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken BAND341 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> equalityExpression340 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> equalityExpression342 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree BAND341_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(800, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:801:2: ( equalityExpression ( BAND equalityExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:801:4: equalityExpression ( BAND equalityExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(801, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseAndExpression4199);
			equalityExpression340=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression340.Tree);
			DebugLocation(802, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:802:3: ( BAND equalityExpression )*
			try { DebugEnterSubRule(79);
			while (true)
			{
				int alt79=2;
				try { DebugEnterDecision(79, false);
				int LA79_0 = input.LA(1);

				if ((LA79_0==BAND))
				{
					alt79 = 1;
				}


				} finally { DebugExitDecision(79); }
				switch ( alt79 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:802:4: BAND equalityExpression
					{
					DebugLocation(802, 4);
					BAND341=(IToken)Match(input,BAND,Follow._BAND_in_bitwiseAndExpression4204); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BAND341_tree = (FlyparseTree)adaptor.Create(BAND341);
					adaptor.AddChild(root_0, BAND341_tree);
					}
					DebugLocation(802, 9);
					PushFollow(Follow._equalityExpression_in_bitwiseAndExpression4206);
					equalityExpression342=equalityExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression342.Tree);

					}
					break;

				default:
					goto loop79;
				}
			}

			loop79:
				;

			} finally { DebugExitSubRule(79); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 106);
			LeaveRule("bitwiseAndExpression", 106);
			LeaveRule_bitwiseAndExpression();
		}
		DebugLocation(803, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();

	// $ANTLR start "equalityExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:806:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 107);
		TraceIn("equalityExpression", 107);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> relationalExpression343 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> equalityOperator344 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> relationalExpression345 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(806, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:807:2: ( relationalExpression ( equalityOperator relationalExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:807:4: relationalExpression ( equalityOperator relationalExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(807, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression4220);
			relationalExpression343=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression343.Tree);
			DebugLocation(808, 9);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:808:9: ( equalityOperator relationalExpression )*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_0 = input.LA(1);

				if ((LA80_0==EQUAL||LA80_0==NOT_EQUAL||(LA80_0>=STRICT_EQUAL && LA80_0<=STRICT_NOT_EQUAL)))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:808:10: equalityOperator relationalExpression
					{
					DebugLocation(808, 10);
					PushFollow(Follow._equalityOperator_in_equalityExpression4231);
					equalityOperator344=equalityOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityOperator344.Tree);
					DebugLocation(808, 27);
					PushFollow(Follow._relationalExpression_in_equalityExpression4233);
					relationalExpression345=relationalExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression345.Tree);

					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 107);
			LeaveRule("equalityExpression", 107);
			LeaveRule_equalityExpression();
		}
		DebugLocation(809, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityOperator();
	partial void LeaveRule_equalityOperator();

	// $ANTLR start "equalityOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:811:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
	[GrammarRule("equalityOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> equalityOperator()
	{
		EnterRule_equalityOperator();
		EnterRule("equalityOperator", 108);
		TraceIn("equalityOperator", 108);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set346 = default(IToken);

		FlyparseTree set346_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "equalityOperator");
		DebugLocation(811, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:812:2: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(812, 2);

			set346=(IToken)input.LT(1);
			if (input.LA(1)==EQUAL||input.LA(1)==NOT_EQUAL||(input.LA(1)>=STRICT_EQUAL && input.LA(1)<=STRICT_NOT_EQUAL))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set346));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityOperator", 108);
			LeaveRule("equalityOperator", 108);
			LeaveRule_equalityOperator();
		}
		DebugLocation(813, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityOperator"); }
		return retval;

	}
	// $ANTLR end "equalityOperator"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();

	// $ANTLR start "relationalExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:816:1: relationalExpression : shiftExpression ( relationalOperator shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 109);
		TraceIn("relationalExpression", 109);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> shiftExpression347 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> relationalOperator348 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> shiftExpression349 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(816, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:817:2: ( shiftExpression ( relationalOperator shiftExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:817:4: shiftExpression ( relationalOperator shiftExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(817, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpression4271);
			shiftExpression347=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression347.Tree);
			DebugLocation(817, 20);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:817:20: ( relationalOperator shiftExpression )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_0 = input.LA(1);

				if ((LA81_0==AS||LA81_0==GE||LA81_0==GT||LA81_0==IS||LA81_0==LE||LA81_0==LT||LA81_0==249))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:817:21: relationalOperator shiftExpression
					{
					DebugLocation(817, 21);
					PushFollow(Follow._relationalOperator_in_relationalExpression4274);
					relationalOperator348=relationalOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalOperator348.Tree);
					DebugLocation(817, 40);
					PushFollow(Follow._shiftExpression_in_relationalExpression4276);
					shiftExpression349=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression349.Tree);

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 109);
			LeaveRule("relationalExpression", 109);
			LeaveRule_relationalExpression();
		}
		DebugLocation(818, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalOperator();
	partial void LeaveRule_relationalOperator();

	// $ANTLR start "relationalOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:820:1: relationalOperator : ( LT | GT | LE | GE | IS | AS | 'instanceof' );
	[GrammarRule("relationalOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> relationalOperator()
	{
		EnterRule_relationalOperator();
		EnterRule("relationalOperator", 110);
		TraceIn("relationalOperator", 110);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set350 = default(IToken);

		FlyparseTree set350_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "relationalOperator");
		DebugLocation(820, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:821:2: ( LT | GT | LE | GE | IS | AS | 'instanceof' )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(821, 2);

			set350=(IToken)input.LT(1);
			if (input.LA(1)==AS||input.LA(1)==GE||input.LA(1)==GT||input.LA(1)==IS||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==249)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set350));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalOperator", 110);
			LeaveRule("relationalOperator", 110);
			LeaveRule_relationalOperator();
		}
		DebugLocation(822, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalOperator"); }
		return retval;

	}
	// $ANTLR end "relationalOperator"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();

	// $ANTLR start "shiftExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:825:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 111);
		TraceIn("shiftExpression", 111);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> additiveExpression351 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> shiftOperator352 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> additiveExpression353 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(825, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:826:2: ( additiveExpression ( shiftOperator additiveExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:826:4: additiveExpression ( shiftOperator additiveExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(826, 4);
			PushFollow(Follow._additiveExpression_in_shiftExpression4326);
			additiveExpression351=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression351.Tree);
			DebugLocation(827, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:827:3: ( shiftOperator additiveExpression )*
			try { DebugEnterSubRule(82);
			while (true)
			{
				int alt82=2;
				try { DebugEnterDecision(82, false);
				int LA82_0 = input.LA(1);

				if ((LA82_0==BSR||LA82_0==SL||LA82_0==SR))
				{
					alt82 = 1;
				}


				} finally { DebugExitDecision(82); }
				switch ( alt82 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:827:4: shiftOperator additiveExpression
					{
					DebugLocation(827, 4);
					PushFollow(Follow._shiftOperator_in_shiftExpression4331);
					shiftOperator352=shiftOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftOperator352.Tree);
					DebugLocation(827, 18);
					PushFollow(Follow._additiveExpression_in_shiftExpression4333);
					additiveExpression353=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression353.Tree);

					}
					break;

				default:
					goto loop82;
				}
			}

			loop82:
				;

			} finally { DebugExitSubRule(82); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 111);
			LeaveRule("shiftExpression", 111);
			LeaveRule_shiftExpression();
		}
		DebugLocation(828, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_shiftOperator();
	partial void LeaveRule_shiftOperator();

	// $ANTLR start "shiftOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:830:1: shiftOperator : ( SL | SR | BSR );
	[GrammarRule("shiftOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> shiftOperator()
	{
		EnterRule_shiftOperator();
		EnterRule("shiftOperator", 112);
		TraceIn("shiftOperator", 112);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set354 = default(IToken);

		FlyparseTree set354_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "shiftOperator");
		DebugLocation(830, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:831:2: ( SL | SR | BSR )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(831, 2);

			set354=(IToken)input.LT(1);
			if (input.LA(1)==BSR||input.LA(1)==SL||input.LA(1)==SR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set354));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftOperator", 112);
			LeaveRule("shiftOperator", 112);
			LeaveRule_shiftOperator();
		}
		DebugLocation(832, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftOperator"); }
		return retval;

	}
	// $ANTLR end "shiftOperator"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();

	// $ANTLR start "additiveExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:835:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 113);
		TraceIn("additiveExpression", 113);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> multiplicativeExpression355 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> additiveOperator356 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> multiplicativeExpression357 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(835, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:836:2: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:836:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(836, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression4366);
			multiplicativeExpression355=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression355.Tree);
			DebugLocation(836, 29);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:836:29: ( additiveOperator multiplicativeExpression )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_0 = input.LA(1);

				if ((LA83_0==MINUS||LA83_0==PLUS))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:836:30: additiveOperator multiplicativeExpression
					{
					DebugLocation(836, 30);
					PushFollow(Follow._additiveOperator_in_additiveExpression4369);
					additiveOperator356=additiveOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveOperator356.Tree);
					DebugLocation(836, 47);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression4371);
					multiplicativeExpression357=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression357.Tree);

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 113);
			LeaveRule("additiveExpression", 113);
			LeaveRule_additiveExpression();
		}
		DebugLocation(837, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_additiveOperator();
	partial void LeaveRule_additiveOperator();

	// $ANTLR start "additiveOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:839:1: additiveOperator : ( PLUS | MINUS );
	[GrammarRule("additiveOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> additiveOperator()
	{
		EnterRule_additiveOperator();
		EnterRule("additiveOperator", 114);
		TraceIn("additiveOperator", 114);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set358 = default(IToken);

		FlyparseTree set358_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "additiveOperator");
		DebugLocation(839, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:840:2: ( PLUS | MINUS )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(840, 2);

			set358=(IToken)input.LT(1);
			if (input.LA(1)==MINUS||input.LA(1)==PLUS)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set358));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveOperator", 114);
			LeaveRule("additiveOperator", 114);
			LeaveRule_additiveOperator();
		}
		DebugLocation(841, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveOperator"); }
		return retval;

	}
	// $ANTLR end "additiveOperator"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();

	// $ANTLR start "multiplicativeExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:844:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 115);
		TraceIn("multiplicativeExpression", 115);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression359 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> multiplicativeOperator360 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression361 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(844, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:845:2: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:845:4: unaryExpression ( multiplicativeOperator unaryExpression )*
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(845, 4);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression4400);
			unaryExpression359=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression359.Tree);
			DebugLocation(846, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:846:3: ( multiplicativeOperator unaryExpression )*
			try { DebugEnterSubRule(84);
			while (true)
			{
				int alt84=2;
				try { DebugEnterDecision(84, false);
				int LA84_0 = input.LA(1);

				if ((LA84_0==DIV||LA84_0==MOD||LA84_0==STAR))
				{
					alt84 = 1;
				}


				} finally { DebugExitDecision(84); }
				switch ( alt84 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:846:5: multiplicativeOperator unaryExpression
					{
					DebugLocation(846, 5);
					PushFollow(Follow._multiplicativeOperator_in_multiplicativeExpression4406);
					multiplicativeOperator360=multiplicativeOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeOperator360.Tree);
					DebugLocation(847, 4);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression4411);
					unaryExpression361=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression361.Tree);

					}
					break;

				default:
					goto loop84;
				}
			}

			loop84:
				;

			} finally { DebugExitSubRule(84); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 115);
			LeaveRule("multiplicativeExpression", 115);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(849, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_multiplicativeOperator();
	partial void LeaveRule_multiplicativeOperator();

	// $ANTLR start "multiplicativeOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:851:1: multiplicativeOperator : ( STAR | DIV | MOD );
	[GrammarRule("multiplicativeOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> multiplicativeOperator()
	{
		EnterRule_multiplicativeOperator();
		EnterRule("multiplicativeOperator", 116);
		TraceIn("multiplicativeOperator", 116);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set362 = default(IToken);

		FlyparseTree set362_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "multiplicativeOperator");
		DebugLocation(851, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:852:2: ( STAR | DIV | MOD )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(852, 2);

			set362=(IToken)input.LT(1);
			if (input.LA(1)==DIV||input.LA(1)==MOD||input.LA(1)==STAR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set362));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeOperator", 116);
			LeaveRule("multiplicativeOperator", 116);
			LeaveRule_multiplicativeOperator();
		}
		DebugLocation(853, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeOperator"); }
		return retval;

	}
	// $ANTLR end "multiplicativeOperator"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();

	// $ANTLR start "unaryExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:856:1: unaryExpression : (in= INC unaryExpression |de= DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 117);
		TraceIn("unaryExpression", 117);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken in = default(IToken);
		IToken de = default(IToken);
		IToken MINUS365 = default(IToken);
		IToken PLUS367 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression363 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression364 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression366 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression368 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpressionNotPlusMinus369 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree in_tree = default(FlyparseTree);
		FlyparseTree de_tree = default(FlyparseTree);
		FlyparseTree MINUS365_tree = default(FlyparseTree);
		FlyparseTree PLUS367_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(856, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:857:2: (in= INC unaryExpression |de= DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus )
			int alt85=5;
			try { DebugEnterDecision(85, false);
			switch (input.LA(1))
			{
			case INC:
				{
				alt85 = 1;
				}
				break;
			case DEC:
				{
				alt85 = 2;
				}
				break;
			case MINUS:
				{
				alt85 = 3;
				}
				break;
			case PLUS:
				{
				alt85 = 4;
				}
				break;
			case AS:
			case BNOT:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LCURLY:
			case LNOT:
			case LPAREN:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 243:
			case 255:
			case 256:
			case 257:
				{
				alt85 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 85, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(85); }
			switch (alt85)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:857:4: in= INC unaryExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(857, 6);
				in=(IToken)Match(input,INC,Follow._INC_in_unaryExpression4449); if (state.failed) return retval;
				if (state.backtracking == 0) {
				in_tree = (FlyparseTree)adaptor.Create(in);
				adaptor.AddChild(root_0, in_tree);
				}
				DebugLocation(857, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpression4451);
				unaryExpression363=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression363.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:858:4: de= DEC unaryExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(858, 6);
				de=(IToken)Match(input,DEC,Follow._DEC_in_unaryExpression4458); if (state.failed) return retval;
				if (state.backtracking == 0) {
				de_tree = (FlyparseTree)adaptor.Create(de);
				adaptor.AddChild(root_0, de_tree);
				}
				DebugLocation(858, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpression4460);
				unaryExpression364=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression364.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:859:4: MINUS unaryExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(859, 4);
				MINUS365=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression4465); if (state.failed) return retval;
				if (state.backtracking == 0) {
				MINUS365_tree = (FlyparseTree)adaptor.Create(MINUS365);
				adaptor.AddChild(root_0, MINUS365_tree);
				}
				DebugLocation(859, 10);
				PushFollow(Follow._unaryExpression_in_unaryExpression4467);
				unaryExpression366=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression366.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:860:4: PLUS unaryExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(860, 4);
				PLUS367=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryExpression4472); if (state.failed) return retval;
				if (state.backtracking == 0) {
				PLUS367_tree = (FlyparseTree)adaptor.Create(PLUS367);
				adaptor.AddChild(root_0, PLUS367_tree);
				}
				DebugLocation(860, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpression4474);
				unaryExpression368=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression368.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:861:4: unaryExpressionNotPlusMinus
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(861, 4);
				PushFollow(Follow._unaryExpressionNotPlusMinus_in_unaryExpression4479);
				unaryExpressionNotPlusMinus369=unaryExpressionNotPlusMinus();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus369.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 117);
			LeaveRule("unaryExpression", 117);
			LeaveRule_unaryExpression();
		}
		DebugLocation(862, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_unaryExpressionNotPlusMinus();
	partial void LeaveRule_unaryExpressionNotPlusMinus();

	// $ANTLR start "unaryExpressionNotPlusMinus"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:864:1: unaryExpressionNotPlusMinus : ( 'delete' postfixExpression -> ^( 'delete' postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | 'typeof' unaryExpression -> ^( 'typeof' unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
	[GrammarRule("unaryExpressionNotPlusMinus")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpressionNotPlusMinus()
	{
		EnterRule_unaryExpressionNotPlusMinus();
		EnterRule("unaryExpressionNotPlusMinus", 118);
		TraceIn("unaryExpressionNotPlusMinus", 118);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal370 = default(IToken);
		IToken string_literal372 = default(IToken);
		IToken string_literal374 = default(IToken);
		IToken LNOT376 = default(IToken);
		IToken BNOT378 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> postfixExpression371 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression373 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression375 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression377 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> unaryExpression379 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> postfixExpression380 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal370_tree = default(FlyparseTree);
		FlyparseTree string_literal372_tree = default(FlyparseTree);
		FlyparseTree string_literal374_tree = default(FlyparseTree);
		FlyparseTree LNOT376_tree = default(FlyparseTree);
		FlyparseTree BNOT378_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_LNOT=new RewriteRuleITokenStream(adaptor,"token LNOT");
		RewriteRuleITokenStream stream_BNOT=new RewriteRuleITokenStream(adaptor,"token BNOT");
		RewriteRuleITokenStream stream_257=new RewriteRuleITokenStream(adaptor,"token 257");
		RewriteRuleITokenStream stream_243=new RewriteRuleITokenStream(adaptor,"token 243");
		RewriteRuleITokenStream stream_255=new RewriteRuleITokenStream(adaptor,"token 255");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_postfixExpression=new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpressionNotPlusMinus");
		DebugLocation(864, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:865:2: ( 'delete' postfixExpression -> ^( 'delete' postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | 'typeof' unaryExpression -> ^( 'typeof' unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
			int alt86=6;
			try { DebugEnterDecision(86, false);
			switch (input.LA(1))
			{
			case 243:
				{
				alt86 = 1;
				}
				break;
			case 257:
				{
				alt86 = 2;
				}
				break;
			case 255:
				{
				alt86 = 3;
				}
				break;
			case LNOT:
				{
				alt86 = 4;
				}
				break;
			case BNOT:
				{
				alt86 = 5;
				}
				break;
			case AS:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LCURLY:
			case LPAREN:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 256:
				{
				alt86 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:865:4: 'delete' postfixExpression
				{
				DebugLocation(865, 4);
				string_literal370=(IToken)Match(input,243,Follow._243_in_unaryExpressionNotPlusMinus4490); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_243.Add(string_literal370);

				DebugLocation(865, 13);
				PushFollow(Follow._postfixExpression_in_unaryExpressionNotPlusMinus4492);
				postfixExpression371=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(postfixExpression371.Tree);


				{
				// AST REWRITE
				// elements: postfixExpression, 243
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 865:31: -> ^( 'delete' postfixExpression )
				{
					DebugLocation(865, 34);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:865:34: ^( 'delete' postfixExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(865, 36);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_243.NextNode(), root_1);

					DebugLocation(865, 45);
					adaptor.AddChild(root_1, stream_postfixExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:866:4: 'void' unaryExpression
				{
				DebugLocation(866, 4);
				string_literal372=(IToken)Match(input,257,Follow._257_in_unaryExpressionNotPlusMinus4505); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_257.Add(string_literal372);

				DebugLocation(866, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4507);
				unaryExpression373=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression373.Tree);


				{
				// AST REWRITE
				// elements: 257, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 866:27: -> ^( 'void' unaryExpression )
				{
					DebugLocation(866, 30);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:866:30: ^( 'void' unaryExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(866, 32);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_257.NextNode(), root_1);

					DebugLocation(866, 39);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:867:4: 'typeof' unaryExpression
				{
				DebugLocation(867, 4);
				string_literal374=(IToken)Match(input,255,Follow._255_in_unaryExpressionNotPlusMinus4520); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_255.Add(string_literal374);

				DebugLocation(867, 13);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4522);
				unaryExpression375=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression375.Tree);


				{
				// AST REWRITE
				// elements: unaryExpression, 255
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 867:29: -> ^( 'typeof' unaryExpression )
				{
					DebugLocation(867, 32);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:867:32: ^( 'typeof' unaryExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(867, 34);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_255.NextNode(), root_1);

					DebugLocation(867, 43);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:868:4: LNOT unaryExpression
				{
				DebugLocation(868, 4);
				LNOT376=(IToken)Match(input,LNOT,Follow._LNOT_in_unaryExpressionNotPlusMinus4535); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LNOT.Add(LNOT376);

				DebugLocation(868, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4537);
				unaryExpression377=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression377.Tree);


				{
				// AST REWRITE
				// elements: unaryExpression, LNOT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 868:25: -> ^( LNOT unaryExpression )
				{
					DebugLocation(868, 28);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:868:28: ^( LNOT unaryExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(868, 30);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_LNOT.NextNode(), root_1);

					DebugLocation(868, 35);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:869:4: BNOT unaryExpression
				{
				DebugLocation(869, 4);
				BNOT378=(IToken)Match(input,BNOT,Follow._BNOT_in_unaryExpressionNotPlusMinus4550); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BNOT.Add(BNOT378);

				DebugLocation(869, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4552);
				unaryExpression379=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression379.Tree);


				{
				// AST REWRITE
				// elements: BNOT, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 869:25: -> ^( BNOT unaryExpression )
				{
					DebugLocation(869, 28);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:869:28: ^( BNOT unaryExpression )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(869, 30);
					root_1 = (FlyparseTree)adaptor.BecomeRoot(stream_BNOT.NextNode(), root_1);

					DebugLocation(869, 35);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:870:4: postfixExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(870, 4);
				PushFollow(Follow._postfixExpression_in_unaryExpressionNotPlusMinus4565);
				postfixExpression380=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression380.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpressionNotPlusMinus", 118);
			LeaveRule("unaryExpressionNotPlusMinus", 118);
			LeaveRule_unaryExpressionNotPlusMinus();
		}
		DebugLocation(871, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpressionNotPlusMinus"); }
		return retval;

	}
	// $ANTLR end "unaryExpressionNotPlusMinus"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();

	// $ANTLR start "postfixExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:877:1: postfixExpression : ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )? ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 119);
		TraceIn("postfixExpression", 119);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DOT383 = default(IToken);
		IToken E4X_DESC385 = default(IToken);
		IToken LBRACK387 = default(IToken);
		IToken RBRACK389 = default(IToken);
		IToken INC391 = default(IToken);
		IToken DEC392 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> primaryExpression381 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> propOrIdent382 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> e4xExpression384 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> e4xExpression386 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression388 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> arguments390 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DOT383_tree = default(FlyparseTree);
		FlyparseTree E4X_DESC385_tree = default(FlyparseTree);
		FlyparseTree LBRACK387_tree = default(FlyparseTree);
		FlyparseTree RBRACK389_tree = default(FlyparseTree);
		FlyparseTree INC391_tree = default(FlyparseTree);
		FlyparseTree DEC392_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_INC=new RewriteRuleITokenStream(adaptor,"token INC");
		RewriteRuleITokenStream stream_DEC=new RewriteRuleITokenStream(adaptor,"token DEC");
		RewriteRuleITokenStream stream_E4X_DESC=new RewriteRuleITokenStream(adaptor,"token E4X_DESC");
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_propOrIdent=new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_e4xExpression=new RewriteRuleSubtreeStream(adaptor,"rule e4xExpression");
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(877, 2);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:878:2: ( ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )? )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:878:4: ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )?
			{
			DebugLocation(878, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:878:4: ( primaryExpression -> primaryExpression )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:878:5: primaryExpression
			{
			DebugLocation(878, 5);
			PushFollow(Follow._primaryExpression_in_postfixExpression4579);
			primaryExpression381=primaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression381.Tree);


			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 878:23: -> primaryExpression
			{
				DebugLocation(878, 26);
				adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(879, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:879:3: ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=6;
				try { DebugEnterDecision(87, false);
				switch (input.LA(1))
				{
				case DOT:
					{
					int LA87_2 = input.LA(2);

					if ((LA87_2==AS||LA87_2==DYNAMIC||LA87_2==GET||LA87_2==IDENT||(LA87_2>=INTERNAL && LA87_2<=IS)||LA87_2==NAMESPACE||LA87_2==PRIVATE||(LA87_2>=PROTECTED && LA87_2<=PUBLIC)||LA87_2==SET||LA87_2==SUPER||LA87_2==USE||LA87_2==XML))
					{
						alt87 = 1;
					}
					else if ((LA87_2==E4X_ATTRI||LA87_2==LPAREN||LA87_2==STAR))
					{
						alt87 = 2;
					}


					}
					break;
				case E4X_DESC:
					{
					alt87 = 3;
					}
					break;
				case LBRACK:
					{
					alt87 = 4;
					}
					break;
				case LPAREN:
					{
					alt87 = 5;
					}
					break;
				}

				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:880:13: propOrIdent
					{
					DebugLocation(880, 13);
					PushFollow(Follow._propOrIdent_in_postfixExpression4603);
					propOrIdent382=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propOrIdent.Add(propOrIdent382.Tree);


					{
					// AST REWRITE
					// elements: propOrIdent, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 881:13: -> ^( PROP_ACCESS $postfixExpression propOrIdent )
					{
						DebugLocation(881, 16);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:881:16: ^( PROP_ACCESS $postfixExpression propOrIdent )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(881, 18);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PROP_ACCESS, "PROP_ACCESS"), root_1);

						DebugLocation(881, 31);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(881, 49);
						adaptor.AddChild(root_1, stream_propOrIdent.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:884:13: DOT e4xExpression
					{
					DebugLocation(884, 13);
					DOT383=(IToken)Match(input,DOT,Follow._DOT_in_postfixExpression4658); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT383);

					DebugLocation(884, 17);
					PushFollow(Follow._e4xExpression_in_postfixExpression4660);
					e4xExpression384=e4xExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_e4xExpression.Add(e4xExpression384.Tree);


					{
					// AST REWRITE
					// elements: e4xExpression, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 885:13: -> ^( E4X_EXPRESSION $postfixExpression e4xExpression )
					{
						DebugLocation(885, 16);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:885:16: ^( E4X_EXPRESSION $postfixExpression e4xExpression )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(885, 18);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(E4X_EXPRESSION, "E4X_EXPRESSION"), root_1);

						DebugLocation(885, 34);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(885, 52);
						adaptor.AddChild(root_1, stream_e4xExpression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:888:13: E4X_DESC e4xExpression
					{
					DebugLocation(888, 13);
					E4X_DESC385=(IToken)Match(input,E4X_DESC,Follow._E4X_DESC_in_postfixExpression4703); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_E4X_DESC.Add(E4X_DESC385);

					DebugLocation(888, 22);
					PushFollow(Follow._e4xExpression_in_postfixExpression4705);
					e4xExpression386=e4xExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_e4xExpression.Add(e4xExpression386.Tree);


					{
					// AST REWRITE
					// elements: E4X_DESC, e4xExpression, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 889:13: -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression )
					{
						DebugLocation(889, 16);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:889:16: ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(889, 18);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(E4X_EXPRESSION, "E4X_EXPRESSION"), root_1);

						DebugLocation(889, 34);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(889, 52);
						adaptor.AddChild(root_1, stream_E4X_DESC.NextNode());
						DebugLocation(889, 61);
						adaptor.AddChild(root_1, stream_e4xExpression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:892:13: LBRACK expression RBRACK
					{
					DebugLocation(892, 13);
					LBRACK387=(IToken)Match(input,LBRACK,Follow._LBRACK_in_postfixExpression4762); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LBRACK.Add(LBRACK387);

					DebugLocation(892, 20);
					PushFollow(Follow._expression_in_postfixExpression4764);
					expression388=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression388.Tree);
					DebugLocation(892, 31);
					RBRACK389=(IToken)Match(input,RBRACK,Follow._RBRACK_in_postfixExpression4766); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RBRACK.Add(RBRACK389);



					{
					// AST REWRITE
					// elements: RBRACK, LBRACK, postfixExpression, expression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 893:13: -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) )
					{
						DebugLocation(893, 16);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:893:16: ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(893, 18);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARRAY_ACCESS, "ARRAY_ACCESS"), root_1);

						DebugLocation(893, 32);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(893, 50);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:893:50: ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK )
						{
						FlyparseTree root_2 = (FlyparseTree)adaptor.Nil();
						DebugLocation(893, 52);
						root_2 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARRAY_SUBSCRIPT, "ARRAY_SUBSCRIPT"), root_2);

						DebugLocation(893, 68);
						adaptor.AddChild(root_2, stream_LBRACK.NextNode());
						DebugLocation(893, 75);
						adaptor.AddChild(root_2, stream_expression.NextTree());
						DebugLocation(893, 86);
						adaptor.AddChild(root_2, stream_RBRACK.NextNode());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:896:13: arguments
					{
					DebugLocation(896, 13);
					PushFollow(Follow._arguments_in_postfixExpression4817);
					arguments390=arguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arguments.Add(arguments390.Tree);


					{
					// AST REWRITE
					// elements: arguments, postfixExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 897:13: -> ^( FUNCTION_CALL $postfixExpression arguments )
					{
						DebugLocation(897, 16);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:897:16: ^( FUNCTION_CALL $postfixExpression arguments )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(897, 18);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FUNCTION_CALL, "FUNCTION_CALL"), root_1);

						DebugLocation(897, 33);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(897, 51);
						adaptor.AddChild(root_1, stream_arguments.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }

			DebugLocation(900, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:900:3: ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )?
			int alt88=3;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			int LA88_0 = input.LA(1);

			if ((LA88_0==INC))
			{
				alt88 = 1;
			}
			else if ((LA88_0==DEC))
			{
				alt88 = 2;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:900:6: INC
				{
				DebugLocation(900, 6);
				INC391=(IToken)Match(input,INC,Follow._INC_in_postfixExpression4861); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INC.Add(INC391);



				{
				// AST REWRITE
				// elements: INC, postfixExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 900:10: -> ^( POST_INC $postfixExpression INC )
				{
					DebugLocation(900, 13);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:900:13: ^( POST_INC $postfixExpression INC )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(900, 15);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(POST_INC, "POST_INC"), root_1);

					DebugLocation(900, 25);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(900, 43);
					adaptor.AddChild(root_1, stream_INC.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:901:6: DEC
				{
				DebugLocation(901, 6);
				DEC392=(IToken)Match(input,DEC,Follow._DEC_in_postfixExpression4879); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DEC.Add(DEC392);



				{
				// AST REWRITE
				// elements: DEC, postfixExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 901:10: -> ^( POST_DEC $postfixExpression DEC )
				{
					DebugLocation(901, 13);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:901:13: ^( POST_DEC $postfixExpression DEC )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(901, 15);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(POST_DEC, "POST_DEC"), root_1);

					DebugLocation(901, 25);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(901, 43);
					adaptor.AddChild(root_1, stream_DEC.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(88); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 119);
			LeaveRule("postfixExpression", 119);
			LeaveRule_postfixExpression();
		}
		DebugLocation(904, 2);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_e4xExpression();
	partial void LeaveRule_e4xExpression();

	// $ANTLR start "e4xExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:906:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
	[GrammarRule("e4xExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> e4xExpression()
	{
		EnterRule_e4xExpression();
		EnterRule("e4xExpression", 120);
		TraceIn("e4xExpression", 120);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken STAR393 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> e4xAttributeIdentifier394 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> e4xFilterPredicate395 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree STAR393_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "e4xExpression");
		DebugLocation(906, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:907:2: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
			int alt89=3;
			try { DebugEnterDecision(89, false);
			switch (input.LA(1))
			{
			case STAR:
				{
				alt89 = 1;
				}
				break;
			case E4X_ATTRI:
				{
				alt89 = 2;
				}
				break;
			case LPAREN:
				{
				alt89 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:907:4: STAR
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(907, 4);
				STAR393=(IToken)Match(input,STAR,Follow._STAR_in_e4xExpression4908); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STAR393_tree = (FlyparseTree)adaptor.Create(STAR393);
				adaptor.AddChild(root_0, STAR393_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:908:4: e4xAttributeIdentifier
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(908, 4);
				PushFollow(Follow._e4xAttributeIdentifier_in_e4xExpression4913);
				e4xAttributeIdentifier394=e4xAttributeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier394.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:909:4: e4xFilterPredicate
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(909, 4);
				PushFollow(Follow._e4xFilterPredicate_in_e4xExpression4918);
				e4xFilterPredicate395=e4xFilterPredicate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xFilterPredicate395.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xExpression", 120);
			LeaveRule("e4xExpression", 120);
			LeaveRule_e4xExpression();
		}
		DebugLocation(910, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xExpression"); }
		return retval;

	}
	// $ANTLR end "e4xExpression"

	partial void EnterRule_e4xAttributeIdentifier();
	partial void LeaveRule_e4xAttributeIdentifier();

	// $ANTLR start "e4xAttributeIdentifier"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:912:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
	[GrammarRule("e4xAttributeIdentifier")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> e4xAttributeIdentifier()
	{
		EnterRule_e4xAttributeIdentifier();
		EnterRule("e4xAttributeIdentifier", 121);
		TraceIn("e4xAttributeIdentifier", 121);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken E4X_ATTRI396 = default(IToken);
		IToken STAR398 = default(IToken);
		IToken LBRACK399 = default(IToken);
		IToken RBRACK401 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent397 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression400 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree E4X_ATTRI396_tree = default(FlyparseTree);
		FlyparseTree STAR398_tree = default(FlyparseTree);
		FlyparseTree LBRACK399_tree = default(FlyparseTree);
		FlyparseTree RBRACK401_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "e4xAttributeIdentifier");
		DebugLocation(912, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:913:2: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:913:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(913, 4);
			E4X_ATTRI396=(IToken)Match(input,E4X_ATTRI,Follow._E4X_ATTRI_in_e4xAttributeIdentifier4929); if (state.failed) return retval;
			if (state.backtracking == 0) {
			E4X_ATTRI396_tree = (FlyparseTree)adaptor.Create(E4X_ATTRI396);
			adaptor.AddChild(root_0, E4X_ATTRI396_tree);
			}
			DebugLocation(914, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:914:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
			int alt90=3;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			switch (input.LA(1))
			{
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case INTERNAL:
			case IS:
			case NAMESPACE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt90 = 1;
				}
				break;
			case STAR:
				{
				alt90 = 2;
				}
				break;
			case LBRACK:
				{
				alt90 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 90, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:914:5: qualifiedIdent
				{
				DebugLocation(914, 5);
				PushFollow(Follow._qualifiedIdent_in_e4xAttributeIdentifier4935);
				qualifiedIdent397=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent397.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:915:5: STAR
				{
				DebugLocation(915, 5);
				STAR398=(IToken)Match(input,STAR,Follow._STAR_in_e4xAttributeIdentifier4941); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STAR398_tree = (FlyparseTree)adaptor.Create(STAR398);
				adaptor.AddChild(root_0, STAR398_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:916:5: LBRACK expression RBRACK
				{
				DebugLocation(916, 5);
				LBRACK399=(IToken)Match(input,LBRACK,Follow._LBRACK_in_e4xAttributeIdentifier4947); if (state.failed) return retval;
				if (state.backtracking == 0) {
				LBRACK399_tree = (FlyparseTree)adaptor.Create(LBRACK399);
				adaptor.AddChild(root_0, LBRACK399_tree);
				}
				DebugLocation(916, 12);
				PushFollow(Follow._expression_in_e4xAttributeIdentifier4949);
				expression400=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression400.Tree);
				DebugLocation(916, 23);
				RBRACK401=(IToken)Match(input,RBRACK,Follow._RBRACK_in_e4xAttributeIdentifier4951); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RBRACK401_tree = (FlyparseTree)adaptor.Create(RBRACK401);
				adaptor.AddChild(root_0, RBRACK401_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xAttributeIdentifier", 121);
			LeaveRule("e4xAttributeIdentifier", 121);
			LeaveRule_e4xAttributeIdentifier();
		}
		DebugLocation(918, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xAttributeIdentifier"); }
		return retval;

	}
	// $ANTLR end "e4xAttributeIdentifier"

	partial void EnterRule_e4xFilterPredicate();
	partial void LeaveRule_e4xFilterPredicate();

	// $ANTLR start "e4xFilterPredicate"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:920:1: e4xFilterPredicate : LPAREN ! expression RPAREN !;
	[GrammarRule("e4xFilterPredicate")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> e4xFilterPredicate()
	{
		EnterRule_e4xFilterPredicate();
		EnterRule("e4xFilterPredicate", 122);
		TraceIn("e4xFilterPredicate", 122);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN402 = default(IToken);
		IToken RPAREN404 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expression403 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN402_tree = default(FlyparseTree);
		FlyparseTree RPAREN404_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "e4xFilterPredicate");
		DebugLocation(920, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:921:2: ( LPAREN ! expression RPAREN !)
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:921:4: LPAREN ! expression RPAREN !
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(921, 10);
			LPAREN402=(IToken)Match(input,LPAREN,Follow._LPAREN_in_e4xFilterPredicate4966); if (state.failed) return retval;
			DebugLocation(922, 3);
			PushFollow(Follow._expression_in_e4xFilterPredicate4971);
			expression403=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression403.Tree);
			DebugLocation(923, 9);
			RPAREN404=(IToken)Match(input,RPAREN,Follow._RPAREN_in_e4xFilterPredicate4975); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xFilterPredicate", 122);
			LeaveRule("e4xFilterPredicate", 122);
			LeaveRule_e4xFilterPredicate();
		}
		DebugLocation(924, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xFilterPredicate"); }
		return retval;

	}
	// $ANTLR end "e4xFilterPredicate"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();

	// $ANTLR start "primaryExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:926:1: primaryExpression : ( 'undefined' | constant -> ^( CONSTANT constant ) | arrayLiteral | objectLiteral | functionDefinition | newExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 123);
		TraceIn("primaryExpression", 123);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken string_literal405 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> constant406 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> arrayLiteral407 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> objectLiteral408 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> functionDefinition409 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> newExpression410 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> encapsulatedExpression411 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> e4xAttributeIdentifier412 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent413 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree string_literal405_tree = default(FlyparseTree);
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(926, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:927:2: ( 'undefined' | constant -> ^( CONSTANT constant ) | arrayLiteral | objectLiteral | functionDefinition | newExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
			int alt91=9;
			try { DebugEnterDecision(91, false);
			switch (input.LA(1))
			{
			case 256:
				{
				alt91 = 1;
				}
				break;
			case DECIMAL_LITERAL:
			case FALSE:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case NULL:
			case OCTAL_LITERAL:
			case REGEX_LITERAL:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case TRUE:
			case XML_LITERAL:
				{
				alt91 = 2;
				}
				break;
			case LBRACK:
				{
				alt91 = 3;
				}
				break;
			case LCURLY:
				{
				alt91 = 4;
				}
				break;
			case FUNCTION:
				{
				alt91 = 5;
				}
				break;
			case NEW:
				{
				alt91 = 6;
				}
				break;
			case LPAREN:
				{
				alt91 = 7;
				}
				break;
			case E4X_ATTRI:
				{
				alt91 = 8;
				}
				break;
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case INTERNAL:
			case IS:
			case NAMESPACE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt91 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:927:4: 'undefined'
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(927, 4);
				string_literal405=(IToken)Match(input,256,Follow._256_in_primaryExpression4987); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal405_tree = (FlyparseTree)adaptor.Create(string_literal405);
				adaptor.AddChild(root_0, string_literal405_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:928:4: constant
				{
				DebugLocation(928, 4);
				PushFollow(Follow._constant_in_primaryExpression4992);
				constant406=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant406.Tree);


				{
				// AST REWRITE
				// elements: constant
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 929:9: -> ^( CONSTANT constant )
				{
					DebugLocation(929, 12);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:929:12: ^( CONSTANT constant )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(929, 14);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(CONSTANT, "CONSTANT"), root_1);

					DebugLocation(929, 23);
					adaptor.AddChild(root_1, stream_constant.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:930:4: arrayLiteral
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(930, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression5013);
				arrayLiteral407=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arrayLiteral407.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:931:4: objectLiteral
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(931, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression5018);
				objectLiteral408=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectLiteral408.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:932:4: functionDefinition
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(932, 4);
				PushFollow(Follow._functionDefinition_in_primaryExpression5023);
				functionDefinition409=functionDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDefinition409.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:933:4: newExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(933, 4);
				PushFollow(Follow._newExpression_in_primaryExpression5028);
				newExpression410=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression410.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:934:4: encapsulatedExpression
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(934, 4);
				PushFollow(Follow._encapsulatedExpression_in_primaryExpression5033);
				encapsulatedExpression411=encapsulatedExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, encapsulatedExpression411.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:935:4: e4xAttributeIdentifier
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(935, 4);
				PushFollow(Follow._e4xAttributeIdentifier_in_primaryExpression5038);
				e4xAttributeIdentifier412=e4xAttributeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier412.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:936:4: qualifiedIdent
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(936, 4);
				PushFollow(Follow._qualifiedIdent_in_primaryExpression5043);
				qualifiedIdent413=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent413.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 123);
			LeaveRule("primaryExpression", 123);
			LeaveRule_primaryExpression();
		}
		DebugLocation(938, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_propOrIdent();
	partial void LeaveRule_propOrIdent();

	// $ANTLR start "propOrIdent"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:941:1: propOrIdent : DOT qualifiedIdent -> ^( PROP_OR_IDENT qualifiedIdent ) ;
	[GrammarRule("propOrIdent")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> propOrIdent()
	{
		EnterRule_propOrIdent();
		EnterRule("propOrIdent", 124);
		TraceIn("propOrIdent", 124);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DOT414 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent415 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DOT414_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		try { DebugEnterRule(GrammarFileName, "propOrIdent");
		DebugLocation(941, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:942:2: ( DOT qualifiedIdent -> ^( PROP_OR_IDENT qualifiedIdent ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:943:3: DOT qualifiedIdent
			{
			DebugLocation(943, 3);
			DOT414=(IToken)Match(input,DOT,Follow._DOT_in_propOrIdent5059); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT414);

			DebugLocation(943, 7);
			PushFollow(Follow._qualifiedIdent_in_propOrIdent5061);
			qualifiedIdent415=qualifiedIdent();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent415.Tree);


			{
			// AST REWRITE
			// elements: qualifiedIdent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 949:3: -> ^( PROP_OR_IDENT qualifiedIdent )
			{
				DebugLocation(949, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:949:6: ^( PROP_OR_IDENT qualifiedIdent )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(949, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PROP_OR_IDENT, "PROP_OR_IDENT"), root_1);

				DebugLocation(949, 22);
				adaptor.AddChild(root_1, stream_qualifiedIdent.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propOrIdent", 124);
			LeaveRule("propOrIdent", 124);
			LeaveRule_propOrIdent();
		}
		DebugLocation(950, 1);
		} finally { DebugExitRule(GrammarFileName, "propOrIdent"); }
		return retval;

	}
	// $ANTLR end "propOrIdent"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();

	// $ANTLR start "constant"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:952:1: constant : ( xmlLiteral | regexpLiteral | number -> ^( LITERAL_NUMBER number ) | stringLiteral -> ^( LITERAL_STRING stringLiteral ) | TRUE | FALSE | NULL );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 125);
		TraceIn("constant", 125);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken TRUE420 = default(IToken);
		IToken FALSE421 = default(IToken);
		IToken NULL422 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> xmlLiteral416 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> regexpLiteral417 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> number418 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteral419 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree TRUE420_tree = default(FlyparseTree);
		FlyparseTree FALSE421_tree = default(FlyparseTree);
		FlyparseTree NULL422_tree = default(FlyparseTree);
		RewriteRuleSubtreeStream stream_stringLiteral=new RewriteRuleSubtreeStream(adaptor,"rule stringLiteral");
		RewriteRuleSubtreeStream stream_number=new RewriteRuleSubtreeStream(adaptor,"rule number");
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(952, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:953:2: ( xmlLiteral | regexpLiteral | number -> ^( LITERAL_NUMBER number ) | stringLiteral -> ^( LITERAL_STRING stringLiteral ) | TRUE | FALSE | NULL )
			int alt92=7;
			try { DebugEnterDecision(92, false);
			switch (input.LA(1))
			{
			case XML_LITERAL:
				{
				alt92 = 1;
				}
				break;
			case REGEX_LITERAL:
				{
				alt92 = 2;
				}
				break;
			case DECIMAL_LITERAL:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case OCTAL_LITERAL:
				{
				alt92 = 3;
				}
				break;
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
				{
				alt92 = 4;
				}
				break;
			case TRUE:
				{
				alt92 = 5;
				}
				break;
			case FALSE:
				{
				alt92 = 6;
				}
				break;
			case NULL:
				{
				alt92 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(92); }
			switch (alt92)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:953:4: xmlLiteral
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(953, 4);
				PushFollow(Follow._xmlLiteral_in_constant5086);
				xmlLiteral416=xmlLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, xmlLiteral416.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:954:4: regexpLiteral
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(954, 4);
				PushFollow(Follow._regexpLiteral_in_constant5091);
				regexpLiteral417=regexpLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, regexpLiteral417.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:955:4: number
				{
				DebugLocation(955, 4);
				PushFollow(Follow._number_in_constant5096);
				number418=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(number418.Tree);


				{
				// AST REWRITE
				// elements: number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 955:11: -> ^( LITERAL_NUMBER number )
				{
					DebugLocation(955, 14);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:955:14: ^( LITERAL_NUMBER number )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(955, 16);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_NUMBER, "LITERAL_NUMBER"), root_1);

					DebugLocation(955, 31);
					adaptor.AddChild(root_1, stream_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:956:4: stringLiteral
				{
				DebugLocation(956, 4);
				PushFollow(Follow._stringLiteral_in_constant5109);
				stringLiteral419=stringLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stringLiteral.Add(stringLiteral419.Tree);


				{
				// AST REWRITE
				// elements: stringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (FlyparseTree)adaptor.Nil();
				// 956:18: -> ^( LITERAL_STRING stringLiteral )
				{
					DebugLocation(956, 21);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:956:21: ^( LITERAL_STRING stringLiteral )
					{
					FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
					DebugLocation(956, 23);
					root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_STRING, "LITERAL_STRING"), root_1);

					DebugLocation(956, 38);
					adaptor.AddChild(root_1, stream_stringLiteral.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:957:4: TRUE
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(957, 4);
				TRUE420=(IToken)Match(input,TRUE,Follow._TRUE_in_constant5122); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TRUE420_tree = (FlyparseTree)adaptor.Create(TRUE420);
				adaptor.AddChild(root_0, TRUE420_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:958:4: FALSE
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(958, 4);
				FALSE421=(IToken)Match(input,FALSE,Follow._FALSE_in_constant5127); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FALSE421_tree = (FlyparseTree)adaptor.Create(FALSE421);
				adaptor.AddChild(root_0, FALSE421_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:959:4: NULL
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(959, 4);
				NULL422=(IToken)Match(input,NULL,Follow._NULL_in_constant5132); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULL422_tree = (FlyparseTree)adaptor.Create(NULL422);
				adaptor.AddChild(root_0, NULL422_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 125);
			LeaveRule("constant", 125);
			LeaveRule_constant();
		}
		DebugLocation(960, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_stringLiteral();
	partial void LeaveRule_stringLiteral();

	// $ANTLR start "stringLiteral"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:962:1: stringLiteral : ( stringLiteralDouble | stringLiteralSingle );
	[GrammarRule("stringLiteral")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteral()
	{
		EnterRule_stringLiteral();
		EnterRule("stringLiteral", 126);
		TraceIn("stringLiteral", 126);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteralDouble423 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteralSingle424 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "stringLiteral");
		DebugLocation(962, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:963:5: ( stringLiteralDouble | stringLiteralSingle )
			int alt93=2;
			try { DebugEnterDecision(93, false);
			int LA93_0 = input.LA(1);

			if ((LA93_0==STRING_LITERAL_DOUBLE))
			{
				alt93 = 1;
			}
			else if ((LA93_0==STRING_LITERAL_SINGLE))
			{
				alt93 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 93, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:963:7: stringLiteralDouble
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(963, 7);
				PushFollow(Follow._stringLiteralDouble_in_stringLiteral5146);
				stringLiteralDouble423=stringLiteralDouble();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteralDouble423.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:963:29: stringLiteralSingle
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(963, 29);
				PushFollow(Follow._stringLiteralSingle_in_stringLiteral5150);
				stringLiteralSingle424=stringLiteralSingle();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteralSingle424.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteral", 126);
			LeaveRule("stringLiteral", 126);
			LeaveRule_stringLiteral();
		}
		DebugLocation(964, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteral"); }
		return retval;

	}
	// $ANTLR end "stringLiteral"

	partial void EnterRule_stringLiteralDouble();
	partial void LeaveRule_stringLiteralDouble();

	// $ANTLR start "stringLiteralDouble"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:966:1: stringLiteralDouble : STRING_LITERAL_DOUBLE -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE ) ;
	[GrammarRule("stringLiteralDouble")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteralDouble()
	{
		EnterRule_stringLiteralDouble();
		EnterRule("stringLiteralDouble", 127);
		TraceIn("stringLiteralDouble", 127);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken STRING_LITERAL_DOUBLE425 = default(IToken);

		FlyparseTree STRING_LITERAL_DOUBLE425_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_STRING_LITERAL_DOUBLE=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL_DOUBLE");
		try { DebugEnterRule(GrammarFileName, "stringLiteralDouble");
		DebugLocation(966, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:967:5: ( STRING_LITERAL_DOUBLE -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:967:7: STRING_LITERAL_DOUBLE
			{
			DebugLocation(967, 7);
			STRING_LITERAL_DOUBLE425=(IToken)Match(input,STRING_LITERAL_DOUBLE,Follow._STRING_LITERAL_DOUBLE_in_stringLiteralDouble5167); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING_LITERAL_DOUBLE.Add(STRING_LITERAL_DOUBLE425);



			{
			// AST REWRITE
			// elements: STRING_LITERAL_DOUBLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 967:29: -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE )
			{
				DebugLocation(967, 32);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:967:32: ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(967, 34);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_DOUBLE_STRING, "LITERAL_DOUBLE_STRING"), root_1);

				DebugLocation(967, 56);
				adaptor.AddChild(root_1, stream_STRING_LITERAL_DOUBLE.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteralDouble", 127);
			LeaveRule("stringLiteralDouble", 127);
			LeaveRule_stringLiteralDouble();
		}
		DebugLocation(968, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteralDouble"); }
		return retval;

	}
	// $ANTLR end "stringLiteralDouble"

	partial void EnterRule_stringLiteralSingle();
	partial void LeaveRule_stringLiteralSingle();

	// $ANTLR start "stringLiteralSingle"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:970:1: stringLiteralSingle : STRING_LITERAL_SINGLE -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE ) ;
	[GrammarRule("stringLiteralSingle")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> stringLiteralSingle()
	{
		EnterRule_stringLiteralSingle();
		EnterRule("stringLiteralSingle", 128);
		TraceIn("stringLiteralSingle", 128);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken STRING_LITERAL_SINGLE426 = default(IToken);

		FlyparseTree STRING_LITERAL_SINGLE426_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_STRING_LITERAL_SINGLE=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL_SINGLE");
		try { DebugEnterRule(GrammarFileName, "stringLiteralSingle");
		DebugLocation(970, 4);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:971:5: ( STRING_LITERAL_SINGLE -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:971:7: STRING_LITERAL_SINGLE
			{
			DebugLocation(971, 7);
			STRING_LITERAL_SINGLE426=(IToken)Match(input,STRING_LITERAL_SINGLE,Follow._STRING_LITERAL_SINGLE_in_stringLiteralSingle5192); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING_LITERAL_SINGLE.Add(STRING_LITERAL_SINGLE426);



			{
			// AST REWRITE
			// elements: STRING_LITERAL_SINGLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 971:29: -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE )
			{
				DebugLocation(971, 32);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:971:32: ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(971, 34);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_SINGLE_STRING, "LITERAL_SINGLE_STRING"), root_1);

				DebugLocation(971, 56);
				adaptor.AddChild(root_1, stream_STRING_LITERAL_SINGLE.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteralSingle", 128);
			LeaveRule("stringLiteralSingle", 128);
			LeaveRule_stringLiteralSingle();
		}
		DebugLocation(972, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteralSingle"); }
		return retval;

	}
	// $ANTLR end "stringLiteralSingle"

	partial void EnterRule_number();
	partial void LeaveRule_number();

	// $ANTLR start "number"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:975:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 129);
		TraceIn("number", 129);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken set427 = default(IToken);

		FlyparseTree set427_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(975, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:975:8: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(975, 8);

			set427=(IToken)input.LT(1);
			if (input.LA(1)==DECIMAL_LITERAL||input.LA(1)==FLOAT_LITERAL||input.LA(1)==HEX_LITERAL||input.LA(1)==OCTAL_LITERAL)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (FlyparseTree)adaptor.Create(set427));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("number", 129);
			LeaveRule("number", 129);
			LeaveRule_number();
		}
		DebugLocation(979, 1);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_xmlLiteral();
	partial void LeaveRule_xmlLiteral();

	// $ANTLR start "xmlLiteral"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:982:1: xmlLiteral : XML_LITERAL -> ^( LITERAL_XML XML_LITERAL ) ;
	[GrammarRule("xmlLiteral")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> xmlLiteral()
	{
		EnterRule_xmlLiteral();
		EnterRule("xmlLiteral", 130);
		TraceIn("xmlLiteral", 130);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken XML_LITERAL428 = default(IToken);

		FlyparseTree XML_LITERAL428_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_XML_LITERAL=new RewriteRuleITokenStream(adaptor,"token XML_LITERAL");
		try { DebugEnterRule(GrammarFileName, "xmlLiteral");
		DebugLocation(982, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:983:2: ( XML_LITERAL -> ^( LITERAL_XML XML_LITERAL ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:984:11: XML_LITERAL
			{
			DebugLocation(984, 11);
			XML_LITERAL428=(IToken)Match(input,XML_LITERAL,Follow._XML_LITERAL_in_xmlLiteral5253); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_XML_LITERAL.Add(XML_LITERAL428);



			{
			// AST REWRITE
			// elements: XML_LITERAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 985:3: -> ^( LITERAL_XML XML_LITERAL )
			{
				DebugLocation(985, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:985:6: ^( LITERAL_XML XML_LITERAL )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(985, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_XML, "LITERAL_XML"), root_1);

				DebugLocation(985, 20);
				adaptor.AddChild(root_1, stream_XML_LITERAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xmlLiteral", 130);
			LeaveRule("xmlLiteral", 130);
			LeaveRule_xmlLiteral();
		}
		DebugLocation(986, 1);
		} finally { DebugExitRule(GrammarFileName, "xmlLiteral"); }
		return retval;

	}
	// $ANTLR end "xmlLiteral"

	partial void EnterRule_regexpLiteral();
	partial void LeaveRule_regexpLiteral();

	// $ANTLR start "regexpLiteral"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:989:1: regexpLiteral : REGEX_LITERAL -> ^( LITERAL_REGEX REGEX_LITERAL ) ;
	[GrammarRule("regexpLiteral")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> regexpLiteral()
	{
		EnterRule_regexpLiteral();
		EnterRule("regexpLiteral", 131);
		TraceIn("regexpLiteral", 131);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken REGEX_LITERAL429 = default(IToken);

		FlyparseTree REGEX_LITERAL429_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_REGEX_LITERAL=new RewriteRuleITokenStream(adaptor,"token REGEX_LITERAL");
		try { DebugEnterRule(GrammarFileName, "regexpLiteral");
		DebugLocation(989, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:990:2: ( REGEX_LITERAL -> ^( LITERAL_REGEX REGEX_LITERAL ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:990:4: REGEX_LITERAL
			{
			DebugLocation(990, 4);
			REGEX_LITERAL429=(IToken)Match(input,REGEX_LITERAL,Follow._REGEX_LITERAL_in_regexpLiteral5283); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REGEX_LITERAL.Add(REGEX_LITERAL429);



			{
			// AST REWRITE
			// elements: REGEX_LITERAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 991:3: -> ^( LITERAL_REGEX REGEX_LITERAL )
			{
				DebugLocation(991, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:991:6: ^( LITERAL_REGEX REGEX_LITERAL )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(991, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(LITERAL_REGEX, "LITERAL_REGEX"), root_1);

				DebugLocation(991, 22);
				adaptor.AddChild(root_1, stream_REGEX_LITERAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("regexpLiteral", 131);
			LeaveRule("regexpLiteral", 131);
			LeaveRule_regexpLiteral();
		}
		DebugLocation(992, 1);
		} finally { DebugExitRule(GrammarFileName, "regexpLiteral"); }
		return retval;

	}
	// $ANTLR end "regexpLiteral"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();

	// $ANTLR start "newExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:994:1: newExpression : NEW fullNewSubexpression arguments -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments ) ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 132);
		TraceIn("newExpression", 132);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken NEW430 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> fullNewSubexpression431 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> arguments432 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree NEW430_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_fullNewSubexpression=new RewriteRuleSubtreeStream(adaptor,"rule fullNewSubexpression");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(994, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:995:2: ( NEW fullNewSubexpression arguments -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:995:4: NEW fullNewSubexpression arguments
			{
			DebugLocation(995, 4);
			NEW430=(IToken)Match(input,NEW,Follow._NEW_in_newExpression5304); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEW.Add(NEW430);

			DebugLocation(995, 8);
			PushFollow(Follow._fullNewSubexpression_in_newExpression5306);
			fullNewSubexpression431=fullNewSubexpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fullNewSubexpression.Add(fullNewSubexpression431.Tree);
			DebugLocation(995, 29);
			PushFollow(Follow._arguments_in_newExpression5308);
			arguments432=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(arguments432.Tree);


			{
			// AST REWRITE
			// elements: arguments, fullNewSubexpression, NEW
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 995:39: -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments )
			{
				DebugLocation(995, 42);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:995:42: ^( NEW_EXPRESSION NEW fullNewSubexpression arguments )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(995, 44);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(NEW_EXPRESSION, "NEW_EXPRESSION"), root_1);

				DebugLocation(995, 59);
				adaptor.AddChild(root_1, stream_NEW.NextNode());
				DebugLocation(995, 63);
				adaptor.AddChild(root_1, stream_fullNewSubexpression.NextTree());
				DebugLocation(995, 84);
				adaptor.AddChild(root_1, stream_arguments.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 132);
			LeaveRule("newExpression", 132);
			LeaveRule_newExpression();
		}
		DebugLocation(996, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_fullNewSubexpression();
	partial void LeaveRule_fullNewSubexpression();

	// $ANTLR start "fullNewSubexpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:998:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
	[GrammarRule("fullNewSubexpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> fullNewSubexpression()
	{
		EnterRule_fullNewSubexpression();
		EnterRule("fullNewSubexpression", 133);
		TraceIn("fullNewSubexpression", 133);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken d = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> primaryExpression433 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent434 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> brackets435 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree d_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_brackets=new RewriteRuleSubtreeStream(adaptor,"rule brackets");
		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		try { DebugEnterRule(GrammarFileName, "fullNewSubexpression");
		DebugLocation(998, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:999:2: ( ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:999:4: ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
			{
			DebugLocation(999, 4);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:999:4: ( primaryExpression -> primaryExpression )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:999:6: primaryExpression
			{
			DebugLocation(999, 6);
			PushFollow(Follow._primaryExpression_in_fullNewSubexpression5333);
			primaryExpression433=primaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression433.Tree);


			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 999:24: -> primaryExpression
			{
				DebugLocation(999, 27);
				adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(1001, 3);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1001:3: (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
			try { DebugEnterSubRule(94);
			while (true)
			{
				int alt94=3;
				try { DebugEnterDecision(94, false);
				int LA94_0 = input.LA(1);

				if ((LA94_0==DOT))
				{
					alt94 = 1;
				}
				else if ((LA94_0==LBRACK))
				{
					alt94 = 2;
				}


				} finally { DebugExitDecision(94); }
				switch ( alt94 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1001:5: d= DOT qualifiedIdent
					{
					DebugLocation(1001, 6);
					d=(IToken)Match(input,DOT,Follow._DOT_in_fullNewSubexpression5349); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(d);

					DebugLocation(1001, 11);
					PushFollow(Follow._qualifiedIdent_in_fullNewSubexpression5351);
					qualifiedIdent434=qualifiedIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent434.Tree);


					{
					// AST REWRITE
					// elements: qualifiedIdent, fullNewSubexpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 1001:26: -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent )
					{
						DebugLocation(1001, 29);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1001:29: ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(1001, 31);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(PROP_OR_IDENT, "PROP_OR_IDENT"), root_1);

						DebugLocation(1001, 46);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(1001, 67);
						adaptor.AddChild(root_1, stream_qualifiedIdent.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1002:5: brackets
					{
					DebugLocation(1002, 5);
					PushFollow(Follow._brackets_in_fullNewSubexpression5368);
					brackets435=brackets();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_brackets.Add(brackets435.Tree);


					{
					// AST REWRITE
					// elements: fullNewSubexpression, brackets
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (FlyparseTree)adaptor.Nil();
					// 1002:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
					{
						DebugLocation(1002, 17);
						// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1002:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
						{
						FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
						DebugLocation(1002, 19);
						root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

						DebugLocation(1002, 30);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(1002, 51);
						adaptor.AddChild(root_1, stream_brackets.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop94;
				}
			}

			loop94:
				;

			} finally { DebugExitSubRule(94); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fullNewSubexpression", 133);
			LeaveRule("fullNewSubexpression", 133);
			LeaveRule_fullNewSubexpression();
		}
		DebugLocation(1004, 1);
		} finally { DebugExitRule(GrammarFileName, "fullNewSubexpression"); }
		return retval;

	}
	// $ANTLR end "fullNewSubexpression"

	partial void EnterRule_propertyOperator();
	partial void LeaveRule_propertyOperator();

	// $ANTLR start "propertyOperator"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1006:1: propertyOperator : ( DOT qualifiedIdent | brackets );
	[GrammarRule("propertyOperator")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> propertyOperator()
	{
		EnterRule_propertyOperator();
		EnterRule("propertyOperator", 134);
		TraceIn("propertyOperator", 134);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken DOT436 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> qualifiedIdent437 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> brackets438 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree DOT436_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "propertyOperator");
		DebugLocation(1006, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1007:2: ( DOT qualifiedIdent | brackets )
			int alt95=2;
			try { DebugEnterDecision(95, false);
			int LA95_0 = input.LA(1);

			if ((LA95_0==DOT))
			{
				alt95 = 1;
			}
			else if ((LA95_0==LBRACK))
			{
				alt95 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 95, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1007:4: DOT qualifiedIdent
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(1007, 4);
				DOT436=(IToken)Match(input,DOT,Follow._DOT_in_propertyOperator5395); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DOT436_tree = (FlyparseTree)adaptor.Create(DOT436);
				adaptor.AddChild(root_0, DOT436_tree);
				}
				DebugLocation(1007, 8);
				PushFollow(Follow._qualifiedIdent_in_propertyOperator5397);
				qualifiedIdent437=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent437.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1008:4: brackets
				{
				root_0 = (FlyparseTree)adaptor.Nil();

				DebugLocation(1008, 4);
				PushFollow(Follow._brackets_in_propertyOperator5402);
				brackets438=brackets();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, brackets438.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyOperator", 134);
			LeaveRule("propertyOperator", 134);
			LeaveRule_propertyOperator();
		}
		DebugLocation(1009, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyOperator"); }
		return retval;

	}
	// $ANTLR end "propertyOperator"

	partial void EnterRule_brackets();
	partial void LeaveRule_brackets();

	// $ANTLR start "brackets"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1011:1: brackets : LBRACK expressionList RBRACK ;
	[GrammarRule("brackets")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> brackets()
	{
		EnterRule_brackets();
		EnterRule("brackets", 135);
		TraceIn("brackets", 135);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LBRACK439 = default(IToken);
		IToken RBRACK441 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> expressionList440 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LBRACK439_tree = default(FlyparseTree);
		FlyparseTree RBRACK441_tree = default(FlyparseTree);
		try { DebugEnterRule(GrammarFileName, "brackets");
		DebugLocation(1011, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1012:2: ( LBRACK expressionList RBRACK )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1012:4: LBRACK expressionList RBRACK
			{
			root_0 = (FlyparseTree)adaptor.Nil();

			DebugLocation(1012, 4);
			LBRACK439=(IToken)Match(input,LBRACK,Follow._LBRACK_in_brackets5413); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LBRACK439_tree = (FlyparseTree)adaptor.Create(LBRACK439);
			adaptor.AddChild(root_0, LBRACK439_tree);
			}
			DebugLocation(1012, 11);
			PushFollow(Follow._expressionList_in_brackets5415);
			expressionList440=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expressionList440.Tree);
			DebugLocation(1012, 26);
			RBRACK441=(IToken)Match(input,RBRACK,Follow._RBRACK_in_brackets5417); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RBRACK441_tree = (FlyparseTree)adaptor.Create(RBRACK441);
			adaptor.AddChild(root_0, RBRACK441_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("brackets", 135);
			LeaveRule("brackets", 135);
			LeaveRule_brackets();
		}
		DebugLocation(1013, 1);
		} finally { DebugExitRule(GrammarFileName, "brackets"); }
		return retval;

	}
	// $ANTLR end "brackets"

	partial void EnterRule_encapsulatedExpression();
	partial void LeaveRule_encapsulatedExpression();

	// $ANTLR start "encapsulatedExpression"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1015:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
	[GrammarRule("encapsulatedExpression")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> encapsulatedExpression()
	{
		EnterRule_encapsulatedExpression();
		EnterRule("encapsulatedExpression", 136);
		TraceIn("encapsulatedExpression", 136);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken LPAREN442 = default(IToken);
		IToken RPAREN444 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> assignmentExpression443 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree LPAREN442_tree = default(FlyparseTree);
		FlyparseTree RPAREN444_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "encapsulatedExpression");
		DebugLocation(1015, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1016:2: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1016:4: LPAREN assignmentExpression RPAREN
			{
			DebugLocation(1016, 4);
			LPAREN442=(IToken)Match(input,LPAREN,Follow._LPAREN_in_encapsulatedExpression5428); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN442);

			DebugLocation(1016, 11);
			PushFollow(Follow._assignmentExpression_in_encapsulatedExpression5430);
			assignmentExpression443=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression443.Tree);
			DebugLocation(1016, 32);
			RPAREN444=(IToken)Match(input,RPAREN,Follow._RPAREN_in_encapsulatedExpression5432); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN444);



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 1017:3: -> ^( ENCPS_EXPR assignmentExpression )
			{
				DebugLocation(1017, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1017:6: ^( ENCPS_EXPR assignmentExpression )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(1017, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);

				DebugLocation(1017, 19);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("encapsulatedExpression", 136);
			LeaveRule("encapsulatedExpression", 136);
			LeaveRule_encapsulatedExpression();
		}
		DebugLocation(1018, 1);
		} finally { DebugExitRule(GrammarFileName, "encapsulatedExpression"); }
		return retval;

	}
	// $ANTLR end "encapsulatedExpression"

	partial void EnterRule_functionDefinition();
	partial void LeaveRule_functionDefinition();

	// $ANTLR start "functionDefinition"
	// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1023:1: functionDefinition : FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
	[GrammarRule("functionDefinition")]
	private AstParserRuleReturnScope<FlyparseTree, IToken> functionDefinition()
	{
		EnterRule_functionDefinition();
		EnterRule("functionDefinition", 137);
		TraceIn("functionDefinition", 137);
		AstParserRuleReturnScope<FlyparseTree, IToken> retval = new AstParserRuleReturnScope<FlyparseTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		FlyparseTree root_0 = default(FlyparseTree);

		IToken FUNCTION445 = default(IToken);
		AstParserRuleReturnScope<FlyparseTree, IToken> parameterDeclarationList446 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> typeExpression447 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);
		AstParserRuleReturnScope<FlyparseTree, IToken> block448 = default(AstParserRuleReturnScope<FlyparseTree, IToken>);

		FlyparseTree FUNCTION445_tree = default(FlyparseTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_parameterDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
		try { DebugEnterRule(GrammarFileName, "functionDefinition");
		DebugLocation(1023, 1);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1024:2: ( FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1024:4: FUNCTION parameterDeclarationList ( typeExpression )? block
			{
			DebugLocation(1024, 4);
			FUNCTION445=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionDefinition5456); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION445);

			DebugLocation(1024, 13);
			PushFollow(Follow._parameterDeclarationList_in_functionDefinition5458);
			parameterDeclarationList446=parameterDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList446.Tree);
			DebugLocation(1024, 38);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1024:38: ( typeExpression )?
			int alt96=2;
			try { DebugEnterSubRule(96);
			try { DebugEnterDecision(96, false);
			int LA96_0 = input.LA(1);

			if ((LA96_0==COLON))
			{
				alt96 = 1;
			}
			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1024:38: typeExpression
				{
				DebugLocation(1024, 38);
				PushFollow(Follow._typeExpression_in_functionDefinition5460);
				typeExpression447=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression447.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(96); }

			DebugLocation(1024, 54);
			PushFollow(Follow._block_in_functionDefinition5463);
			block448=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(block448.Tree);


			{
			// AST REWRITE
			// elements: parameterDeclarationList, block, typeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (FlyparseTree)adaptor.Nil();
			// 1025:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
			{
				DebugLocation(1025, 6);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1025:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
				{
				FlyparseTree root_1 = (FlyparseTree)adaptor.Nil();
				DebugLocation(1025, 8);
				root_1 = (FlyparseTree)adaptor.BecomeRoot((FlyparseTree)adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

				DebugLocation(1025, 17);
				adaptor.AddChild(root_1, stream_parameterDeclarationList.NextTree());
				DebugLocation(1025, 42);
				// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:1025:42: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(1025, 42);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(1025, 58);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (FlyparseTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (FlyparseTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDefinition", 137);
			LeaveRule("functionDefinition", 137);
			LeaveRule_functionDefinition();
		}
		DebugLocation(1026, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDefinition"); }
		return retval;

	}
	// $ANTLR end "functionDefinition"

	partial void EnterRule_synpred1_AS3_fragment();
	partial void LeaveRule_synpred1_AS3_fragment();

	// $ANTLR start synpred1_AS3
	public void synpred1_AS3_fragment()
	{
		EnterRule_synpred1_AS3_fragment();
		EnterRule("synpred1_AS3_fragment", 138);
		TraceIn("synpred1_AS3_fragment", 138);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:123:4: ( modifiers CLASS )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:123:5: modifiers CLASS
			{
			DebugLocation(123, 5);
			PushFollow(Follow._modifiers_in_synpred1_AS3524);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(123, 15);
			Match(input,CLASS,Follow._CLASS_in_synpred1_AS3526); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_AS3_fragment", 138);
			LeaveRule("synpred1_AS3_fragment", 138);
			LeaveRule_synpred1_AS3_fragment();
		}
	}
	// $ANTLR end synpred1_AS3

	partial void EnterRule_synpred2_AS3_fragment();
	partial void LeaveRule_synpred2_AS3_fragment();

	// $ANTLR start synpred2_AS3
	public void synpred2_AS3_fragment()
	{
		EnterRule_synpred2_AS3_fragment();
		EnterRule("synpred2_AS3_fragment", 139);
		TraceIn("synpred2_AS3_fragment", 139);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:124:4: ( modifiers INTERFACE )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:124:5: modifiers INTERFACE
			{
			DebugLocation(124, 5);
			PushFollow(Follow._modifiers_in_synpred2_AS3537);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(124, 15);
			Match(input,INTERFACE,Follow._INTERFACE_in_synpred2_AS3539); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_AS3_fragment", 139);
			LeaveRule("synpred2_AS3_fragment", 139);
			LeaveRule_synpred2_AS3_fragment();
		}
	}
	// $ANTLR end synpred2_AS3

	partial void EnterRule_synpred3_AS3_fragment();
	partial void LeaveRule_synpred3_AS3_fragment();

	// $ANTLR start synpred3_AS3
	public void synpred3_AS3_fragment()
	{
		EnterRule_synpred3_AS3_fragment();
		EnterRule("synpred3_AS3_fragment", 140);
		TraceIn("synpred3_AS3_fragment", 140);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:146:7: ( LBRACK IDENT )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:146:8: LBRACK IDENT
			{
			DebugLocation(146, 8);
			Match(input,LBRACK,Follow._LBRACK_in_synpred3_AS3670); if (state.failed) return;
			DebugLocation(146, 15);
			Match(input,IDENT,Follow._IDENT_in_synpred3_AS3672); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_AS3_fragment", 140);
			LeaveRule("synpred3_AS3_fragment", 140);
			LeaveRule_synpred3_AS3_fragment();
		}
	}
	// $ANTLR end synpred3_AS3

	partial void EnterRule_synpred4_AS3_fragment();
	partial void LeaveRule_synpred4_AS3_fragment();

	// $ANTLR start synpred4_AS3
	public void synpred4_AS3_fragment()
	{
		EnterRule_synpred4_AS3_fragment();
		EnterRule("synpred4_AS3_fragment", 141);
		TraceIn("synpred4_AS3_fragment", 141);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:147:7: ( modifiers NAMESPACE )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:147:8: modifiers NAMESPACE
			{
			DebugLocation(147, 8);
			PushFollow(Follow._modifiers_in_synpred4_AS3686);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(147, 18);
			Match(input,NAMESPACE,Follow._NAMESPACE_in_synpred4_AS3688); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_AS3_fragment", 141);
			LeaveRule("synpred4_AS3_fragment", 141);
			LeaveRule_synpred4_AS3_fragment();
		}
	}
	// $ANTLR end synpred4_AS3

	partial void EnterRule_synpred5_AS3_fragment();
	partial void LeaveRule_synpred5_AS3_fragment();

	// $ANTLR start synpred5_AS3
	public void synpred5_AS3_fragment()
	{
		EnterRule_synpred5_AS3_fragment();
		EnterRule("synpred5_AS3_fragment", 142);
		TraceIn("synpred5_AS3_fragment", 142);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:148:13: ( modifiers CLASS )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:148:14: modifiers CLASS
			{
			DebugLocation(148, 14);
			PushFollow(Follow._modifiers_in_synpred5_AS3708);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(148, 24);
			Match(input,CLASS,Follow._CLASS_in_synpred5_AS3710); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_AS3_fragment", 142);
			LeaveRule("synpred5_AS3_fragment", 142);
			LeaveRule_synpred5_AS3_fragment();
		}
	}
	// $ANTLR end synpred5_AS3

	partial void EnterRule_synpred6_AS3_fragment();
	partial void LeaveRule_synpred6_AS3_fragment();

	// $ANTLR start synpred6_AS3
	public void synpred6_AS3_fragment()
	{
		EnterRule_synpred6_AS3_fragment();
		EnterRule("synpred6_AS3_fragment", 143);
		TraceIn("synpred6_AS3_fragment", 143);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:149:7: ( modifiers INTERFACE )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:149:8: modifiers INTERFACE
			{
			DebugLocation(149, 8);
			PushFollow(Follow._modifiers_in_synpred6_AS3724);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(149, 18);
			Match(input,INTERFACE,Follow._INTERFACE_in_synpred6_AS3726); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_AS3_fragment", 143);
			LeaveRule("synpred6_AS3_fragment", 143);
			LeaveRule_synpred6_AS3_fragment();
		}
	}
	// $ANTLR end synpred6_AS3

	partial void EnterRule_synpred7_AS3_fragment();
	partial void LeaveRule_synpred7_AS3_fragment();

	// $ANTLR start synpred7_AS3
	public void synpred7_AS3_fragment()
	{
		EnterRule_synpred7_AS3_fragment();
		EnterRule("synpred7_AS3_fragment", 144);
		TraceIn("synpred7_AS3_fragment", 144);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:150:7: ( modifiers FUNCTION )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:150:8: modifiers FUNCTION
			{
			DebugLocation(150, 8);
			PushFollow(Follow._modifiers_in_synpred7_AS3740);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(150, 18);
			Match(input,FUNCTION,Follow._FUNCTION_in_synpred7_AS3742); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_AS3_fragment", 144);
			LeaveRule("synpred7_AS3_fragment", 144);
			LeaveRule_synpred7_AS3_fragment();
		}
	}
	// $ANTLR end synpred7_AS3

	partial void EnterRule_synpred8_AS3_fragment();
	partial void LeaveRule_synpred8_AS3_fragment();

	// $ANTLR start synpred8_AS3
	public void synpred8_AS3_fragment()
	{
		EnterRule_synpred8_AS3_fragment();
		EnterRule("synpred8_AS3_fragment", 145);
		TraceIn("synpred8_AS3_fragment", 145);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:151:7: ( modifiers varOrConst )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:151:8: modifiers varOrConst
			{
			DebugLocation(151, 8);
			PushFollow(Follow._modifiers_in_synpred8_AS3756);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(151, 18);
			PushFollow(Follow._varOrConst_in_synpred8_AS3758);
			varOrConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_AS3_fragment", 145);
			LeaveRule("synpred8_AS3_fragment", 145);
			LeaveRule_synpred8_AS3_fragment();
		}
	}
	// $ANTLR end synpred8_AS3

	partial void EnterRule_synpred9_AS3_fragment();
	partial void LeaveRule_synpred9_AS3_fragment();

	// $ANTLR start synpred9_AS3
	public void synpred9_AS3_fragment()
	{
		EnterRule_synpred9_AS3_fragment();
		EnterRule("synpred9_AS3_fragment", 146);
		TraceIn("synpred9_AS3_fragment", 146);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:231:4: ( LBRACK IDENT )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:231:5: LBRACK IDENT
			{
			DebugLocation(231, 5);
			Match(input,LBRACK,Follow._LBRACK_in_synpred9_AS31237); if (state.failed) return;
			DebugLocation(231, 12);
			Match(input,IDENT,Follow._IDENT_in_synpred9_AS31239); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_AS3_fragment", 146);
			LeaveRule("synpred9_AS3_fragment", 146);
			LeaveRule_synpred9_AS3_fragment();
		}
	}
	// $ANTLR end synpred9_AS3

	partial void EnterRule_synpred10_AS3_fragment();
	partial void LeaveRule_synpred10_AS3_fragment();

	// $ANTLR start synpred10_AS3
	public void synpred10_AS3_fragment()
	{
		EnterRule_synpred10_AS3_fragment();
		EnterRule("synpred10_AS3_fragment", 147);
		TraceIn("synpred10_AS3_fragment", 147);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:232:4: ( modifiers varOrConst )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:232:5: modifiers varOrConst
			{
			DebugLocation(232, 5);
			PushFollow(Follow._modifiers_in_synpred10_AS31250);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(232, 15);
			PushFollow(Follow._varOrConst_in_synpred10_AS31252);
			varOrConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_AS3_fragment", 147);
			LeaveRule("synpred10_AS3_fragment", 147);
			LeaveRule_synpred10_AS3_fragment();
		}
	}
	// $ANTLR end synpred10_AS3

	partial void EnterRule_synpred11_AS3_fragment();
	partial void LeaveRule_synpred11_AS3_fragment();

	// $ANTLR start synpred11_AS3
	public void synpred11_AS3_fragment()
	{
		EnterRule_synpred11_AS3_fragment();
		EnterRule("synpred11_AS3_fragment", 148);
		TraceIn("synpred11_AS3_fragment", 148);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:233:4: ( modifiers FUNCTION )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:233:5: modifiers FUNCTION
			{
			DebugLocation(233, 5);
			PushFollow(Follow._modifiers_in_synpred11_AS31272);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(233, 15);
			Match(input,FUNCTION,Follow._FUNCTION_in_synpred11_AS31274); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_AS3_fragment", 148);
			LeaveRule("synpred11_AS3_fragment", 148);
			LeaveRule_synpred11_AS3_fragment();
		}
	}
	// $ANTLR end synpred11_AS3

	partial void EnterRule_synpred12_AS3_fragment();
	partial void LeaveRule_synpred12_AS3_fragment();

	// $ANTLR start synpred12_AS3
	public void synpred12_AS3_fragment()
	{
		EnterRule_synpred12_AS3_fragment();
		EnterRule("synpred12_AS3_fragment", 149);
		TraceIn("synpred12_AS3_fragment", 149);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:267:5: ( LCURLY )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:267:6: LCURLY
			{
			DebugLocation(267, 6);
			Match(input,LCURLY,Follow._LCURLY_in_synpred12_AS31485); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_AS3_fragment", 149);
			LeaveRule("synpred12_AS3_fragment", 149);
			LeaveRule_synpred12_AS3_fragment();
		}
	}
	// $ANTLR end synpred12_AS3

	partial void EnterRule_synpred13_AS3_fragment();
	partial void LeaveRule_synpred13_AS3_fragment();

	// $ANTLR start synpred13_AS3
	public void synpred13_AS3_fragment()
	{
		EnterRule_synpred13_AS3_fragment();
		EnterRule("synpred13_AS3_fragment", 150);
		TraceIn("synpred13_AS3_fragment", 150);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:367:4: ( LCURLY )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:367:5: LCURLY
			{
			DebugLocation(367, 5);
			Match(input,LCURLY,Follow._LCURLY_in_synpred13_AS32021); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_AS3_fragment", 150);
			LeaveRule("synpred13_AS3_fragment", 150);
			LeaveRule_synpred13_AS3_fragment();
		}
	}
	// $ANTLR end synpred13_AS3

	partial void EnterRule_synpred14_AS3_fragment();
	partial void LeaveRule_synpred14_AS3_fragment();

	// $ANTLR start synpred14_AS3
	public void synpred14_AS3_fragment()
	{
		EnterRule_synpred14_AS3_fragment();
		EnterRule("synpred14_AS3_fragment", 151);
		TraceIn("synpred14_AS3_fragment", 151);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:414:4: ( ELSE )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:414:5: ELSE
			{
			DebugLocation(414, 5);
			Match(input,ELSE,Follow._ELSE_in_synpred14_AS32216); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_AS3_fragment", 151);
			LeaveRule("synpred14_AS3_fragment", 151);
			LeaveRule_synpred14_AS3_fragment();
		}
	}
	// $ANTLR end synpred14_AS3

	partial void EnterRule_synpred15_AS3_fragment();
	partial void LeaveRule_synpred15_AS3_fragment();

	// $ANTLR start synpred15_AS3
	public void synpred15_AS3_fragment()
	{
		EnterRule_synpred15_AS3_fragment();
		EnterRule("synpred15_AS3_fragment", 152);
		TraceIn("synpred15_AS3_fragment", 152);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:579:10: ( namespaceName DBL_COLON )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:579:11: namespaceName DBL_COLON
			{
			DebugLocation(579, 11);
			PushFollow(Follow._namespaceName_in_synpred15_AS33178);
			namespaceName();
			PopFollow();
			if (state.failed) return;
			DebugLocation(579, 25);
			Match(input,DBL_COLON,Follow._DBL_COLON_in_synpred15_AS33180); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_AS3_fragment", 152);
			LeaveRule("synpred15_AS3_fragment", 152);
			LeaveRule_synpred15_AS3_fragment();
		}
	}
	// $ANTLR end synpred15_AS3

	partial void EnterRule_synpred16_AS3_fragment();
	partial void LeaveRule_synpred16_AS3_fragment();

	// $ANTLR start synpred16_AS3
	public void synpred16_AS3_fragment()
	{
		EnterRule_synpred16_AS3_fragment();
		EnterRule("synpred16_AS3_fragment", 153);
		TraceIn("synpred16_AS3_fragment", 153);
		try
		{
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:27: ( assignmentOperator )
			DebugEnterAlt(1);
			// C:\\Library\\hg\\xas\\xas\\flyparse\\AS3.g:732:28: assignmentOperator
			{
			DebugLocation(732, 28);
			PushFollow(Follow._assignmentOperator_in_synpred16_AS33919);
			assignmentOperator();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_AS3_fragment", 153);
			LeaveRule("synpred16_AS3_fragment", 153);
			LeaveRule_synpred16_AS3_fragment();
		}
	}
	// $ANTLR end synpred16_AS3
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA3 dfa3;
	private DFA7 dfa7;
	private DFA17 dfa17;
	private DFA20 dfa20;
	private DFA43 dfa43;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa3 = new DFA3( this, SpecialStateTransition3 );
		dfa7 = new DFA7( this, SpecialStateTransition7 );
		dfa17 = new DFA17( this, SpecialStateTransition17 );
		dfa20 = new DFA20( this, SpecialStateTransition20 );
		dfa43 = new DFA43( this );
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x16\xFFFF";
		private const string DFA3_eofS =
			"\x16\xFFFF";
		private const string DFA3_minS =
			"\x1\x22\x1\xFFFF\x9\x22\x2\xFFFF\x9\x22";
		private const string DFA3_maxS =
			"\x1\xFC\x1\xFFFF\x9\xFC\x2\xFFFF\x9\xFC";
		private const string DFA3_acceptS =
			"\x1\xFFFF\x1\x1\x9\xFFFF\x1\x2\x1\x3\x9\xFFFF";
		private const string DFA3_specialS =
			"\x1\x0\x1\xFFFF\x1\xE\x1\x9\x1\xC\x1\x11\x1\x10\x1\x4\x1\x1\x1\xA\x1"+
			"\x6\x2\xFFFF\x1\x8\x1\x3\x1\x12\x1\xD\x1\xF\x1\x7\x1\xB\x1\x2\x1\x5}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x1\xB\x19\xFFFF\x1\x9\x25\xFFFF\x1\x2\xA\xFFFF\x1\x1\x1\xC\x1\xFFFF"+
				"\x1\x3\x3B\xFFFF\x1\x3\x2\xFFFF\x2\x3\x17\xFFFF\x1\x4\x2B\xFFFF\x1\x6"+
				"\x1\x7\x1\x5\x3\xFFFF\x1\xA\x1\xFFFF\x1\x8",
				"",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"",
				"",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1"+
				"\xE\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11"+
				"\x1\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13"
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "122:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition3(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA3_0 = input.LA(1);


				int index3_0 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_0==INCLUDE_DIRECTIVE)) {s = 1;}

				else if ((LA3_0==IDENT)) {s = 2;}

				else if ((LA3_0==INTERNAL||LA3_0==PRIVATE||(LA3_0>=PROTECTED && LA3_0<=PUBLIC))) {s = 3;}

				else if ((LA3_0==STATIC)) {s = 4;}

				else if ((LA3_0==246)) {s = 5;}

				else if ((LA3_0==244)) {s = 6;}

				else if ((LA3_0==245)) {s = 7;}

				else if ((LA3_0==252)) {s = 8;}

				else if ((LA3_0==DYNAMIC)) {s = 9;}

				else if ((LA3_0==250)) {s = 10;}

				else if ((LA3_0==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_0==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_0);
				if (s >= 0) return s;
				break;

			case 1:
				int LA3_8 = input.LA(1);


				int index3_8 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_8==IDENT)) {s = 13;}

				else if ((LA3_8==INTERNAL||LA3_8==PRIVATE||(LA3_8>=PROTECTED && LA3_8<=PUBLIC))) {s = 14;}

				else if ((LA3_8==STATIC)) {s = 15;}

				else if ((LA3_8==246)) {s = 16;}

				else if ((LA3_8==244)) {s = 17;}

				else if ((LA3_8==245)) {s = 18;}

				else if ((LA3_8==252)) {s = 19;}

				else if ((LA3_8==DYNAMIC)) {s = 20;}

				else if ((LA3_8==250)) {s = 21;}

				else if ((LA3_8==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_8==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_8);
				if (s >= 0) return s;
				break;

			case 2:
				int LA3_20 = input.LA(1);


				int index3_20 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_20==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_20==IDENT)) {s = 13;}

				else if ((LA3_20==INTERNAL||LA3_20==PRIVATE||(LA3_20>=PROTECTED && LA3_20<=PUBLIC))) {s = 14;}

				else if ((LA3_20==STATIC)) {s = 15;}

				else if ((LA3_20==246)) {s = 16;}

				else if ((LA3_20==244)) {s = 17;}

				else if ((LA3_20==245)) {s = 18;}

				else if ((LA3_20==252)) {s = 19;}

				else if ((LA3_20==DYNAMIC)) {s = 20;}

				else if ((LA3_20==250)) {s = 21;}

				else if ((LA3_20==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_20);
				if (s >= 0) return s;
				break;

			case 3:
				int LA3_14 = input.LA(1);


				int index3_14 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_14==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_14==IDENT)) {s = 13;}

				else if ((LA3_14==INTERNAL||LA3_14==PRIVATE||(LA3_14>=PROTECTED && LA3_14<=PUBLIC))) {s = 14;}

				else if ((LA3_14==STATIC)) {s = 15;}

				else if ((LA3_14==246)) {s = 16;}

				else if ((LA3_14==244)) {s = 17;}

				else if ((LA3_14==245)) {s = 18;}

				else if ((LA3_14==252)) {s = 19;}

				else if ((LA3_14==DYNAMIC)) {s = 20;}

				else if ((LA3_14==250)) {s = 21;}

				else if ((LA3_14==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_14);
				if (s >= 0) return s;
				break;

			case 4:
				int LA3_7 = input.LA(1);


				int index3_7 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_7==IDENT)) {s = 13;}

				else if ((LA3_7==INTERNAL||LA3_7==PRIVATE||(LA3_7>=PROTECTED && LA3_7<=PUBLIC))) {s = 14;}

				else if ((LA3_7==STATIC)) {s = 15;}

				else if ((LA3_7==246)) {s = 16;}

				else if ((LA3_7==244)) {s = 17;}

				else if ((LA3_7==245)) {s = 18;}

				else if ((LA3_7==252)) {s = 19;}

				else if ((LA3_7==DYNAMIC)) {s = 20;}

				else if ((LA3_7==250)) {s = 21;}

				else if ((LA3_7==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_7==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_7);
				if (s >= 0) return s;
				break;

			case 5:
				int LA3_21 = input.LA(1);


				int index3_21 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_21==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_21==IDENT)) {s = 13;}

				else if ((LA3_21==INTERNAL||LA3_21==PRIVATE||(LA3_21>=PROTECTED && LA3_21<=PUBLIC))) {s = 14;}

				else if ((LA3_21==STATIC)) {s = 15;}

				else if ((LA3_21==246)) {s = 16;}

				else if ((LA3_21==244)) {s = 17;}

				else if ((LA3_21==245)) {s = 18;}

				else if ((LA3_21==252)) {s = 19;}

				else if ((LA3_21==DYNAMIC)) {s = 20;}

				else if ((LA3_21==250)) {s = 21;}

				else if ((LA3_21==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_21);
				if (s >= 0) return s;
				break;

			case 6:
				int LA3_10 = input.LA(1);


				int index3_10 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_10==IDENT)) {s = 13;}

				else if ((LA3_10==INTERNAL||LA3_10==PRIVATE||(LA3_10>=PROTECTED && LA3_10<=PUBLIC))) {s = 14;}

				else if ((LA3_10==STATIC)) {s = 15;}

				else if ((LA3_10==246)) {s = 16;}

				else if ((LA3_10==244)) {s = 17;}

				else if ((LA3_10==245)) {s = 18;}

				else if ((LA3_10==252)) {s = 19;}

				else if ((LA3_10==DYNAMIC)) {s = 20;}

				else if ((LA3_10==250)) {s = 21;}

				else if ((LA3_10==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_10==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_10);
				if (s >= 0) return s;
				break;

			case 7:
				int LA3_18 = input.LA(1);


				int index3_18 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_18==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_18==IDENT)) {s = 13;}

				else if ((LA3_18==INTERNAL||LA3_18==PRIVATE||(LA3_18>=PROTECTED && LA3_18<=PUBLIC))) {s = 14;}

				else if ((LA3_18==STATIC)) {s = 15;}

				else if ((LA3_18==246)) {s = 16;}

				else if ((LA3_18==244)) {s = 17;}

				else if ((LA3_18==245)) {s = 18;}

				else if ((LA3_18==252)) {s = 19;}

				else if ((LA3_18==DYNAMIC)) {s = 20;}

				else if ((LA3_18==250)) {s = 21;}

				else if ((LA3_18==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_18);
				if (s >= 0) return s;
				break;

			case 8:
				int LA3_13 = input.LA(1);


				int index3_13 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_13==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_13==IDENT)) {s = 13;}

				else if ((LA3_13==INTERNAL||LA3_13==PRIVATE||(LA3_13>=PROTECTED && LA3_13<=PUBLIC))) {s = 14;}

				else if ((LA3_13==STATIC)) {s = 15;}

				else if ((LA3_13==246)) {s = 16;}

				else if ((LA3_13==244)) {s = 17;}

				else if ((LA3_13==245)) {s = 18;}

				else if ((LA3_13==252)) {s = 19;}

				else if ((LA3_13==DYNAMIC)) {s = 20;}

				else if ((LA3_13==250)) {s = 21;}

				else if ((LA3_13==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_13);
				if (s >= 0) return s;
				break;

			case 9:
				int LA3_3 = input.LA(1);


				int index3_3 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_3==IDENT)) {s = 13;}

				else if ((LA3_3==INTERNAL||LA3_3==PRIVATE||(LA3_3>=PROTECTED && LA3_3<=PUBLIC))) {s = 14;}

				else if ((LA3_3==STATIC)) {s = 15;}

				else if ((LA3_3==246)) {s = 16;}

				else if ((LA3_3==244)) {s = 17;}

				else if ((LA3_3==245)) {s = 18;}

				else if ((LA3_3==252)) {s = 19;}

				else if ((LA3_3==DYNAMIC)) {s = 20;}

				else if ((LA3_3==250)) {s = 21;}

				else if ((LA3_3==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_3==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_3);
				if (s >= 0) return s;
				break;

			case 10:
				int LA3_9 = input.LA(1);


				int index3_9 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_9==IDENT)) {s = 13;}

				else if ((LA3_9==INTERNAL||LA3_9==PRIVATE||(LA3_9>=PROTECTED && LA3_9<=PUBLIC))) {s = 14;}

				else if ((LA3_9==STATIC)) {s = 15;}

				else if ((LA3_9==246)) {s = 16;}

				else if ((LA3_9==244)) {s = 17;}

				else if ((LA3_9==245)) {s = 18;}

				else if ((LA3_9==252)) {s = 19;}

				else if ((LA3_9==DYNAMIC)) {s = 20;}

				else if ((LA3_9==250)) {s = 21;}

				else if ((LA3_9==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_9==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_9);
				if (s >= 0) return s;
				break;

			case 11:
				int LA3_19 = input.LA(1);


				int index3_19 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_19==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_19==IDENT)) {s = 13;}

				else if ((LA3_19==INTERNAL||LA3_19==PRIVATE||(LA3_19>=PROTECTED && LA3_19<=PUBLIC))) {s = 14;}

				else if ((LA3_19==STATIC)) {s = 15;}

				else if ((LA3_19==246)) {s = 16;}

				else if ((LA3_19==244)) {s = 17;}

				else if ((LA3_19==245)) {s = 18;}

				else if ((LA3_19==252)) {s = 19;}

				else if ((LA3_19==DYNAMIC)) {s = 20;}

				else if ((LA3_19==250)) {s = 21;}

				else if ((LA3_19==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_19);
				if (s >= 0) return s;
				break;

			case 12:
				int LA3_4 = input.LA(1);


				int index3_4 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_4==IDENT)) {s = 13;}

				else if ((LA3_4==INTERNAL||LA3_4==PRIVATE||(LA3_4>=PROTECTED && LA3_4<=PUBLIC))) {s = 14;}

				else if ((LA3_4==STATIC)) {s = 15;}

				else if ((LA3_4==246)) {s = 16;}

				else if ((LA3_4==244)) {s = 17;}

				else if ((LA3_4==245)) {s = 18;}

				else if ((LA3_4==252)) {s = 19;}

				else if ((LA3_4==DYNAMIC)) {s = 20;}

				else if ((LA3_4==250)) {s = 21;}

				else if ((LA3_4==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_4==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_4);
				if (s >= 0) return s;
				break;

			case 13:
				int LA3_16 = input.LA(1);


				int index3_16 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_16==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_16==IDENT)) {s = 13;}

				else if ((LA3_16==INTERNAL||LA3_16==PRIVATE||(LA3_16>=PROTECTED && LA3_16<=PUBLIC))) {s = 14;}

				else if ((LA3_16==STATIC)) {s = 15;}

				else if ((LA3_16==246)) {s = 16;}

				else if ((LA3_16==244)) {s = 17;}

				else if ((LA3_16==245)) {s = 18;}

				else if ((LA3_16==252)) {s = 19;}

				else if ((LA3_16==DYNAMIC)) {s = 20;}

				else if ((LA3_16==250)) {s = 21;}

				else if ((LA3_16==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_16);
				if (s >= 0) return s;
				break;

			case 14:
				int LA3_2 = input.LA(1);


				int index3_2 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_2==IDENT)) {s = 13;}

				else if ((LA3_2==INTERNAL||LA3_2==PRIVATE||(LA3_2>=PROTECTED && LA3_2<=PUBLIC))) {s = 14;}

				else if ((LA3_2==STATIC)) {s = 15;}

				else if ((LA3_2==246)) {s = 16;}

				else if ((LA3_2==244)) {s = 17;}

				else if ((LA3_2==245)) {s = 18;}

				else if ((LA3_2==252)) {s = 19;}

				else if ((LA3_2==DYNAMIC)) {s = 20;}

				else if ((LA3_2==250)) {s = 21;}

				else if ((LA3_2==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_2==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_2);
				if (s >= 0) return s;
				break;

			case 15:
				int LA3_17 = input.LA(1);


				int index3_17 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_17==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_17==IDENT)) {s = 13;}

				else if ((LA3_17==INTERNAL||LA3_17==PRIVATE||(LA3_17>=PROTECTED && LA3_17<=PUBLIC))) {s = 14;}

				else if ((LA3_17==STATIC)) {s = 15;}

				else if ((LA3_17==246)) {s = 16;}

				else if ((LA3_17==244)) {s = 17;}

				else if ((LA3_17==245)) {s = 18;}

				else if ((LA3_17==252)) {s = 19;}

				else if ((LA3_17==DYNAMIC)) {s = 20;}

				else if ((LA3_17==250)) {s = 21;}

				else if ((LA3_17==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_17);
				if (s >= 0) return s;
				break;

			case 16:
				int LA3_6 = input.LA(1);


				int index3_6 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_6==IDENT)) {s = 13;}

				else if ((LA3_6==INTERNAL||LA3_6==PRIVATE||(LA3_6>=PROTECTED && LA3_6<=PUBLIC))) {s = 14;}

				else if ((LA3_6==STATIC)) {s = 15;}

				else if ((LA3_6==246)) {s = 16;}

				else if ((LA3_6==244)) {s = 17;}

				else if ((LA3_6==245)) {s = 18;}

				else if ((LA3_6==252)) {s = 19;}

				else if ((LA3_6==DYNAMIC)) {s = 20;}

				else if ((LA3_6==250)) {s = 21;}

				else if ((LA3_6==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_6==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_6);
				if (s >= 0) return s;
				break;

			case 17:
				int LA3_5 = input.LA(1);


				int index3_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_5==IDENT)) {s = 13;}

				else if ((LA3_5==INTERNAL||LA3_5==PRIVATE||(LA3_5>=PROTECTED && LA3_5<=PUBLIC))) {s = 14;}

				else if ((LA3_5==STATIC)) {s = 15;}

				else if ((LA3_5==246)) {s = 16;}

				else if ((LA3_5==244)) {s = 17;}

				else if ((LA3_5==245)) {s = 18;}

				else if ((LA3_5==252)) {s = 19;}

				else if ((LA3_5==DYNAMIC)) {s = 20;}

				else if ((LA3_5==250)) {s = 21;}

				else if ((LA3_5==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_5==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_5);
				if (s >= 0) return s;
				break;

			case 18:
				int LA3_15 = input.LA(1);


				int index3_15 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA3_15==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_15==IDENT)) {s = 13;}

				else if ((LA3_15==INTERNAL||LA3_15==PRIVATE||(LA3_15>=PROTECTED && LA3_15<=PUBLIC))) {s = 14;}

				else if ((LA3_15==STATIC)) {s = 15;}

				else if ((LA3_15==246)) {s = 16;}

				else if ((LA3_15==244)) {s = 17;}

				else if ((LA3_15==245)) {s = 18;}

				else if ((LA3_15==252)) {s = 19;}

				else if ((LA3_15==DYNAMIC)) {s = 20;}

				else if ((LA3_15==250)) {s = 21;}

				else if ((LA3_15==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}


				input.Seek(index3_15);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 3, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA7 : DFA
	{
		private const string DFA7_eotS =
			"\x14A\xFFFF";
		private const string DFA7_eofS =
			"\x14A\xFFFF";
		private const string DFA7_minS =
			"\x1\xF\x2\xFFFF\x3\xF\x6\x22\x1\xF\x1\x22\x1\xF\x2\xFFFF\x2\xF\x3E\xFFFF"+
			"\xA\x0\x1B\xFFFF\x9\x0\x1A\xFFFF\x9\x0\x6\xFFFF\x9\x0\x5\xFFFF\x9\x0"+
			"\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x19\xFFFF"+
			"\x9\x0\x26\xFFFF\xA\x0\x1\xFFFF";
		private const string DFA7_maxS =
			"\x1\x101\x2\xFFFF\x1\xFB\x1\x101\x9\xFC\x1\xFB\x2\xFFFF\x2\xE7\x3E\xFFFF"+
			"\xA\x0\x1B\xFFFF\x9\x0\x1A\xFFFF\x9\x0\x6\xFFFF\x9\x0\x5\xFFFF\x9\x0"+
			"\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x19\xFFFF"+
			"\x9\x0\x26\xFFFF\xA\x0\x1\xFFFF";
		private const string DFA7_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\xC\xFFFF\x1\x6\x1\x7\x2\xFFFF\x1\xA\x28\xFFFF\x1"+
			"\x3\x42\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1E\xFFFF\x1\x5\x1\x6\x1"+
			"\x7\x1\x8\x1\x9\xA\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5"+
			"\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF"+
			"\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1D\xFFFF\x1\x5\x1\x6\x1\x7\x1"+
			"\x8\x1\x9\x2\x5\x14\xFFFF\xA\x8\xB\xFFFF\x1\x4";
		private const string DFA7_specialS =
			"\x1\x0\x4\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x1\xA\x2\xFFFF\x1\xB\x3F\xFFFF\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11"+
			"\x1\x12\x1\x13\x1\x14\x1\x15\x1B\xFFFF\x1\x16\x1\x17\x1\x18\x1\x19\x1"+
			"\x1A\x1\x1B\x1\x1C\x1\x1D\x1\x1E\x1A\xFFFF\x1\x1F\x1\x20\x1\x21\x1\x22"+
			"\x1\x23\x1\x24\x1\x25\x1\x26\x1\x27\x6\xFFFF\x1\x28\x1\x29\x1\x2A\x1"+
			"\x2B\x1\x2C\x1\x2D\x1\x2E\x1\x2F\x1\x30\x5\xFFFF\x1\x31\x1\x32\x1\x33"+
			"\x1\x34\x1\x35\x1\x36\x1\x37\x1\x38\x1\x39\x5\xFFFF\x1\x3A\x1\x3B\x1"+
			"\x3C\x1\x3D\x1\x3E\x1\x3F\x1\x40\x1\x41\x1\x42\x5\xFFFF\x1\x43\x1\x44"+
			"\x1\x45\x1\x46\x1\x47\x1\x48\x1\x49\x1\x4A\x1\x4B\x5\xFFFF\x1\x4C\x1"+
			"\x4D\x1\x4E\x1\x4F\x1\x50\x1\x51\x1\x52\x1\x53\x1\x54\x5\xFFFF\x1\x55"+
			"\x1\x56\x1\x57\x1\x58\x1\x59\x1\x5A\x1\x5B\x1\x5C\x1\x5D\x19\xFFFF\x1"+
			"\x5E\x1\x5F\x1\x60\x1\x61\x1\x62\x1\x63\x1\x64\x1\x65\x1\x66\x26\xFFFF"+
			"\x1\x67\x1\x68\x1\x69\x1\x6A\x1\x6B\x1\x6C\x1\x6D\x1\x6E\x1\x6F\x1\x70"+
			"\x1\xFFFF}>";
		private static readonly string[] DFA7_transitionS =
			{
				"\x1\x13\x5\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\xF\x7\xFFFF\x1\x12"+
				"\x1\xFFFF\x1\x13\x3\xFFFF\x2\x13\x2\xFFFF\x1\x13\x3\xFFFF\x1\x13\x3"+
				"\xFFFF\x1\xC\x1\x13\x11\xFFFF\x3\x13\x8\xFFFF\x1\x11\x3\xFFFF\x1\x13"+
				"\x2\xFFFF\x1\x13\x1\x5\x2\xFFFF\x1\x13\x3\xFFFF\x1\x1\x2\xFFFF\x1\x13"+
				"\x1\xFFFF\x1\x10\x1\xFFFF\x1\x6\x1\x13\x2\xFFFF\x1\x4\x1\x13\x7\xFFFF"+
				"\x1\x13\x2\xFFFF\x1\x13\x7\xFFFF\x1\x13\x7\xFFFF\x1\xE\x2\xFFFF\x1\x13"+
				"\x4\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\x13\x6\xFFFF\x1\x6\x2\xFFFF"+
				"\x2\x6\x6\xFFFF\x1\x13\x2\xFFFF\x1\x13\x2\xFFFF\x2\x13\x9\xFFFF\x1\x7"+
				"\x2\xFFFF\x4\x13\x5\xFFFF\x1\x13\x6\xFFFF\x1\x3\x1\x12\x6\xFFFF\x1\x13"+
				"\x1\xFFFF\x1\x13\x1\xFFFF\x1\x13\x5\xFFFF\x1\x13\x5\xFFFF\x1\x13\x1"+
				"\x9\x1\xA\x1\x8\x1\xFFFF\x1\x2\x1\xFFFF\x1\xD\x1\xFFFF\x1\xB\x5\x13",
				"",
				"",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x7\xFFFF\x1"+
				"\x13\x8\xFFFF\x1\x13\x5\xFFFF\x2\x13\x1\xFFFF\x1\x13\x4\xFFFF\x1\x13"+
				"\x7\xFFFF\x1\x13\x16\xFFFF\x1\x13\x1\xFFFF\x1\x13\xC\xFFFF\x1\x13\x4"+
				"\xFFFF\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF"+
				"\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1\x3C\x6\xFFFF\x1\x13\xD\xFFFF\x2"+
				"\x13\xB\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13"+
				"\x3\xFFFF\x2\x13\x26\xFFFF\x1\x13\x7\xFFFF\x1\x13\x1\xFFFF\x1\x13",
				"\x1\x57\x5\xFFFF\x1\x13\x11\xFFFF\x1\x13\x8\xFFFF\x2\x13\xA\xFFFF\x1"+
				"\x54\x1\x13\x11\xFFFF\x2\x13\x9\xFFFF\x1\x13\x3\xFFFF\x1\x58\x2\xFFFF"+
				"\x1\x13\x1\x51\x9\xFFFF\x1\x13\x3\xFFFF\x1\x13\x1\x56\x2\xFFFF\x2\x13"+
				"\x7\xFFFF\x1\x13\x2\xFFFF\x1\x13\x7\xFFFF\x1\x13\x7\xFFFF\x1\x55\x2"+
				"\xFFFF\x1\x13\x4\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\x13\x6\xFFFF"+
				"\x1\x13\x2\xFFFF\x2\x13\x2\xFFFF\x1\x13\x3\xFFFF\x1\x13\x6\xFFFF\x1"+
				"\x59\xC\xFFFF\x2\x13\x1\x5A\x6\xFFFF\x1\x13\x6\xFFFF\x1\x52\xB\xFFFF"+
				"\x1\x53\x5\xFFFF\x1\x13\x5\xFFFF\x1\x13\xB\xFFFF\x3\x13",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x2\xFFFF\x1"+
				"\x80\x4\xFFFF\x1\x13\x2\xFFFF\x1\x83\x4\xFFFF\x2\x13\x5\xFFFF\x2\x13"+
				"\x1\xFFFF\x1\x13\x2\xFFFF\x1\x7D\x1\xFFFF\x1\x13\x7\xFFFF\x1\x13\x13"+
				"\xFFFF\x1\x82\x2\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x76\x9\xFFFF"+
				"\x1\x13\x1\xFFFF\x1\x81\x1\xFFFF\x1\x77\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF"+
				"\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1"+
				"\x7F\x6\xFFFF\x1\x13\xD\xFFFF\x2\x13\x5\xFFFF\x1\x77\x2\xFFFF\x2\x77"+
				"\x1\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x2"+
				"\xFFFF\x1\x78\x2\x13\x11\xFFFF\x1\x83\x14\xFFFF\x1\x13\x2\xFFFF\x1\x7A"+
				"\x1\x7B\x1\x79\x2\xFFFF\x1\x13\x1\x7E\x1\x13\x1\x7C",
				"\x1\xA3\x7\xFFFF\x1\xA6\x4\xFFFF\x1\x13\xC\xFFFF\x1\xA0\x1D\xFFFF\x1"+
				"\xA5\x7\xFFFF\x1\x99\xB\xFFFF\x1\xA4\x1\xFFFF\x1\x9A\x1F\xFFFF\x1\xA2"+
				"\x1B\xFFFF\x1\x9A\x2\xFFFF\x2\x9A\x17\xFFFF\x1\x9B\x13\xFFFF\x1\xA6"+
				"\x17\xFFFF\x1\x9D\x1\x9E\x1\x9C\x3\xFFFF\x1\xA1\x1\xFFFF\x1\x9F",
				"\x1\xB2\x7\xFFFF\x1\xB5\x11\xFFFF\x1\xAF\x1D\xFFFF\x1\xB4\x7\xFFFF"+
				"\x1\xA8\xB\xFFFF\x1\xB3\x1\xFFFF\x1\xA9\x1F\xFFFF\x1\xB1\x1B\xFFFF\x1"+
				"\xA9\x2\xFFFF\x2\xA9\x17\xFFFF\x1\xAA\x13\xFFFF\x1\xB5\x17\xFFFF\x1"+
				"\xAC\x1\xAD\x1\xAB\x3\xFFFF\x1\xB0\x1\xFFFF\x1\xAE",
				"\x1\xC0\x7\xFFFF\x1\xC3\x11\xFFFF\x1\xBD\x1D\xFFFF\x1\xC2\x7\xFFFF"+
				"\x1\xB6\xB\xFFFF\x1\xC1\x1\xFFFF\x1\xB7\x1F\xFFFF\x1\xBF\x1B\xFFFF\x1"+
				"\xB7\x2\xFFFF\x2\xB7\x17\xFFFF\x1\xB8\x13\xFFFF\x1\xC3\x17\xFFFF\x1"+
				"\xBA\x1\xBB\x1\xB9\x3\xFFFF\x1\xBE\x1\xFFFF\x1\xBC",
				"\x1\xCE\x7\xFFFF\x1\xD1\x11\xFFFF\x1\xCB\x1D\xFFFF\x1\xD0\x7\xFFFF"+
				"\x1\xC4\xB\xFFFF\x1\xCF\x1\xFFFF\x1\xC5\x1F\xFFFF\x1\xCD\x1B\xFFFF\x1"+
				"\xC5\x2\xFFFF\x2\xC5\x17\xFFFF\x1\xC6\x13\xFFFF\x1\xD1\x17\xFFFF\x1"+
				"\xC8\x1\xC9\x1\xC7\x3\xFFFF\x1\xCC\x1\xFFFF\x1\xCA",
				"\x1\xDC\x7\xFFFF\x1\xDF\x11\xFFFF\x1\xD9\x1D\xFFFF\x1\xDE\x7\xFFFF"+
				"\x1\xD2\xB\xFFFF\x1\xDD\x1\xFFFF\x1\xD3\x1F\xFFFF\x1\xDB\x1B\xFFFF\x1"+
				"\xD3\x2\xFFFF\x2\xD3\x17\xFFFF\x1\xD4\x13\xFFFF\x1\xDF\x17\xFFFF\x1"+
				"\xD6\x1\xD7\x1\xD5\x3\xFFFF\x1\xDA\x1\xFFFF\x1\xD8",
				"\x1\xEA\x7\xFFFF\x1\xED\x11\xFFFF\x1\xE7\x1D\xFFFF\x1\xEC\x7\xFFFF"+
				"\x1\xE0\xB\xFFFF\x1\xEB\x1\xFFFF\x1\xE1\x1F\xFFFF\x1\xE9\x1B\xFFFF\x1"+
				"\xE1\x2\xFFFF\x2\xE1\x17\xFFFF\x1\xE2\x13\xFFFF\x1\xED\x17\xFFFF\x1"+
				"\xE4\x1\xE5\x1\xE3\x3\xFFFF\x1\xE8\x1\xFFFF\x1\xE6",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x2\xFFFF\x1"+
				"\xF8\x4\xFFFF\x1\x13\x2\xFFFF\x1\xFB\x5\xFFFF\x1\x13\x5\xFFFF\x2\x13"+
				"\x1\xFFFF\x1\x13\x2\xFFFF\x1\xF5\x1\xFFFF\x1\x13\x7\xFFFF\x1\x13\x13"+
				"\xFFFF\x1\xFA\x2\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\xEE\x9\xFFFF"+
				"\x1\x13\x1\xFFFF\x1\xF9\x1\xFFFF\x1\xEF\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF"+
				"\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1"+
				"\xF7\x6\xFFFF\x1\x13\xD\xFFFF\x2\x13\x5\xFFFF\x1\xEF\x2\xFFFF\x2\xEF"+
				"\x1\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x2"+
				"\xFFFF\x1\xF0\x2\x13\x11\xFFFF\x1\xFB\x14\xFFFF\x1\x13\x2\xFFFF\x1\xF2"+
				"\x1\xF3\x1\xF1\x2\xFFFF\x1\x13\x1\xF6\x1\x13\x1\xF4",
				"\x1\x11A\x7\xFFFF\x1\x11D\x11\xFFFF\x1\x117\x1D\xFFFF\x1\x11C\x7\xFFFF"+
				"\x1\x110\xB\xFFFF\x1\x11B\x1\xFFFF\x1\x111\x1F\xFFFF\x1\x119\x1B\xFFFF"+
				"\x1\x111\x2\xFFFF\x2\x111\x17\xFFFF\x1\x112\x13\xFFFF\x1\x11D\x17\xFFFF"+
				"\x1\x114\x1\x115\x1\x113\x3\xFFFF\x1\x118\x1\xFFFF\x1\x116",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x7\xFFFF\x1"+
				"\x13\x8\xFFFF\x1\x13\x5\xFFFF\x2\x13\x1\xFFFF\x1\x13\x4\xFFFF\x1\x13"+
				"\x7\xFFFF\x1\x13\x16\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x11E\x9"+
				"\xFFFF\x1\x13\x3\xFFFF\x1\x11F\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF\x4\x13"+
				"\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x8\xFFFF\x1\x13\xD"+
				"\xFFFF\x2\x13\x5\xFFFF\x1\x11F\x2\xFFFF\x2\x11F\x1\xFFFF\x1\x13\xA\xFFFF"+
				"\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x3\xFFFF\x2\x13\x26\xFFFF\x1"+
				"\x13\x7\xFFFF\x1\x13\x1\xFFFF\x1\x13",
				"",
				"",
				"\x1\x13B\x2C\xFFFF\x1\x138\x21\xFFFF\x1\x134\x3\xFFFF\x1\x135\xE\xFFFF"+
				"\x1\x13A\xE\xFFFF\x1\x13\xF\xFFFF\x1\x139\x2D\xFFFF\x1\x13C\xE\xFFFF"+
				"\x1\x13D\xD\xFFFF\x1\x136\xB\xFFFF\x1\x137",
				"\x1\x145\x2C\xFFFF\x1\x142\x21\xFFFF\x1\x146\x3\xFFFF\x1\x13F\xE\xFFFF"+
				"\x1\x144\x1E\xFFFF\x1\x143\x2D\xFFFF\x1\x147\xE\xFFFF\x1\x148\xD\xFFFF"+
				"\x1\x140\xB\xFFFF\x1\x141",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				""
			};

		private static readonly short[] DFA7_eot = DFA.UnpackEncodedString(DFA7_eotS);
		private static readonly short[] DFA7_eof = DFA.UnpackEncodedString(DFA7_eofS);
		private static readonly char[] DFA7_min = DFA.UnpackEncodedStringToUnsignedChars(DFA7_minS);
		private static readonly char[] DFA7_max = DFA.UnpackEncodedStringToUnsignedChars(DFA7_maxS);
		private static readonly short[] DFA7_accept = DFA.UnpackEncodedString(DFA7_acceptS);
		private static readonly short[] DFA7_special = DFA.UnpackEncodedString(DFA7_specialS);
		private static readonly short[][] DFA7_transition;

		static DFA7()
		{
			int numStates = DFA7_transitionS.Length;
			DFA7_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA7_transition[i] = DFA.UnpackEncodedString(DFA7_transitionS[i]);
			}
		}

		public DFA7( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 7;
			this.eot = DFA7_eot;
			this.eof = DFA7_eof;
			this.min = DFA7_min;
			this.max = DFA7_max;
			this.accept = DFA7_accept;
			this.special = DFA7_special;
			this.transition = DFA7_transition;
		}

		public override string Description { get { return "142:2: packageBlockEntry options {k=2; } : ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition7(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA7_0 = input.LA(1);


				int index7_0 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_0==IMPORT)) {s = 1;}

				else if ((LA7_0==248)) {s = 2;}

				else if ((LA7_0==USE)) {s = 3;}

				else if ((LA7_0==LBRACK)) {s = 4;}

				else if ((LA7_0==IDENT)) {s = 5;}

				else if ((LA7_0==INTERNAL||LA7_0==PRIVATE||(LA7_0>=PROTECTED && LA7_0<=PUBLIC))) {s = 6;}

				else if ((LA7_0==STATIC)) {s = 7;}

				else if ((LA7_0==246)) {s = 8;}

				else if ((LA7_0==244)) {s = 9;}

				else if ((LA7_0==245)) {s = 10;}

				else if ((LA7_0==252)) {s = 11;}

				else if ((LA7_0==DYNAMIC)) {s = 12;}

				else if ((LA7_0==250)) {s = 13;}

				else if ((LA7_0==NAMESPACE)) {s = 14;}

				else if ((LA7_0==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 15;}

				else if ((LA7_0==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 16;}

				else if ((LA7_0==FUNCTION)) {s = 17;}

				else if ((LA7_0==CONST||LA7_0==VAR)) {s = 18;}

				else if ((LA7_0==AS||LA7_0==BNOT||LA7_0==BREAK||LA7_0==CONTINUE||(LA7_0>=DEC && LA7_0<=DECIMAL_LITERAL)||LA7_0==DEFAULT||LA7_0==DO||LA7_0==E4X_ATTRI||(LA7_0>=FALSE && LA7_0<=FOR)||LA7_0==GET||LA7_0==HEX_LITERAL||LA7_0==IF||LA7_0==INC||LA7_0==IS||LA7_0==LCURLY||LA7_0==LNOT||LA7_0==LPAREN||LA7_0==MINUS||LA7_0==NEW||LA7_0==NULL||LA7_0==OCTAL_LITERAL||LA7_0==PLUS||LA7_0==REGEX_LITERAL||LA7_0==RETURN||(LA7_0>=SEMI && LA7_0<=SET)||(LA7_0>=STRING_LITERAL_DOUBLE && LA7_0<=SWITCH)||LA7_0==TRUE||LA7_0==WHILE||LA7_0==WITH||LA7_0==XML||LA7_0==XML_LITERAL||LA7_0==243||(LA7_0>=253 && LA7_0<=257))) {s = 19;}


				input.Seek(index7_0);
				if (s >= 0) return s;
				break;

			case 1:
				int LA7_5 = input.LA(1);


				int index7_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_5==IDENT)) {s = 118;}

				else if ((LA7_5==INTERNAL||LA7_5==PRIVATE||(LA7_5>=PROTECTED && LA7_5<=PUBLIC))) {s = 119;}

				else if ((LA7_5==STATIC)) {s = 120;}

				else if ((LA7_5==246)) {s = 121;}

				else if ((LA7_5==244)) {s = 122;}

				else if ((LA7_5==245)) {s = 123;}

				else if ((LA7_5==252)) {s = 124;}

				else if ((LA7_5==DYNAMIC)) {s = 125;}

				else if ((LA7_5==250)) {s = 126;}

				else if ((LA7_5==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 127;}

				else if ((LA7_5==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 128;}

				else if ((LA7_5==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 129;}

				else if ((LA7_5==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 130;}

				else if ((LA7_5==CONST||LA7_5==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 131;}

				else if (((LA7_5>=AS && LA7_5<=ASSIGN)||(LA7_5>=BAND && LA7_5<=BAND_ASSIGN)||(LA7_5>=BOR && LA7_5<=BOR_ASSIGN)||(LA7_5>=BSR && LA7_5<=BXOR_ASSIGN)||LA7_5==COMMA||(LA7_5>=DBL_COLON && LA7_5<=DEC)||(LA7_5>=DIV && LA7_5<=DIV_ASSIGN)||LA7_5==DOT||LA7_5==E4X_DESC||LA7_5==EQUAL||LA7_5==GE||LA7_5==GT||LA7_5==INC||(LA7_5>=IS && LA7_5<=LBRACK)||LA7_5==LE||(LA7_5>=LOR && LA7_5<=LT)||(LA7_5>=MINUS && LA7_5<=MINUS_ASSIGN)||LA7_5==MOD||LA7_5==MOD_ASSIGN||LA7_5==NOT_EQUAL||(LA7_5>=PLUS && LA7_5<=PLUS_ASSIGN)||LA7_5==QUESTION||LA7_5==SEMI||(LA7_5>=SL && LA7_5<=SL_ASSIGN)||(LA7_5>=SR && LA7_5<=STAR_ASSIGN)||(LA7_5>=STRICT_EQUAL && LA7_5<=STRICT_NOT_EQUAL)||LA7_5==241||LA7_5==249||LA7_5==251)) {s = 19;}


				input.Seek(index7_5);
				if (s >= 0) return s;
				break;

			case 2:
				int LA7_6 = input.LA(1);


				int index7_6 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_6==IDENT)) {s = 153;}

				else if ((LA7_6==INTERNAL||LA7_6==PRIVATE||(LA7_6>=PROTECTED && LA7_6<=PUBLIC))) {s = 154;}

				else if ((LA7_6==STATIC)) {s = 155;}

				else if ((LA7_6==246)) {s = 156;}

				else if ((LA7_6==244)) {s = 157;}

				else if ((LA7_6==245)) {s = 158;}

				else if ((LA7_6==252)) {s = 159;}

				else if ((LA7_6==DYNAMIC)) {s = 160;}

				else if ((LA7_6==250)) {s = 161;}

				else if ((LA7_6==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 162;}

				else if ((LA7_6==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 163;}

				else if ((LA7_6==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 164;}

				else if ((LA7_6==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 165;}

				else if ((LA7_6==CONST||LA7_6==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 166;}

				else if ((LA7_6==DBL_COLON)) {s = 19;}


				input.Seek(index7_6);
				if (s >= 0) return s;
				break;

			case 3:
				int LA7_7 = input.LA(1);


				int index7_7 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_7==IDENT)) {s = 168;}

				else if ((LA7_7==INTERNAL||LA7_7==PRIVATE||(LA7_7>=PROTECTED && LA7_7<=PUBLIC))) {s = 169;}

				else if ((LA7_7==STATIC)) {s = 170;}

				else if ((LA7_7==246)) {s = 171;}

				else if ((LA7_7==244)) {s = 172;}

				else if ((LA7_7==245)) {s = 173;}

				else if ((LA7_7==252)) {s = 174;}

				else if ((LA7_7==DYNAMIC)) {s = 175;}

				else if ((LA7_7==250)) {s = 176;}

				else if ((LA7_7==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 177;}

				else if ((LA7_7==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 178;}

				else if ((LA7_7==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 179;}

				else if ((LA7_7==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 180;}

				else if ((LA7_7==CONST||LA7_7==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 181;}


				input.Seek(index7_7);
				if (s >= 0) return s;
				break;

			case 4:
				int LA7_8 = input.LA(1);


				int index7_8 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_8==IDENT)) {s = 182;}

				else if ((LA7_8==INTERNAL||LA7_8==PRIVATE||(LA7_8>=PROTECTED && LA7_8<=PUBLIC))) {s = 183;}

				else if ((LA7_8==STATIC)) {s = 184;}

				else if ((LA7_8==246)) {s = 185;}

				else if ((LA7_8==244)) {s = 186;}

				else if ((LA7_8==245)) {s = 187;}

				else if ((LA7_8==252)) {s = 188;}

				else if ((LA7_8==DYNAMIC)) {s = 189;}

				else if ((LA7_8==250)) {s = 190;}

				else if ((LA7_8==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 191;}

				else if ((LA7_8==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 192;}

				else if ((LA7_8==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 193;}

				else if ((LA7_8==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 194;}

				else if ((LA7_8==CONST||LA7_8==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 195;}


				input.Seek(index7_8);
				if (s >= 0) return s;
				break;

			case 5:
				int LA7_9 = input.LA(1);


				int index7_9 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_9==IDENT)) {s = 196;}

				else if ((LA7_9==INTERNAL||LA7_9==PRIVATE||(LA7_9>=PROTECTED && LA7_9<=PUBLIC))) {s = 197;}

				else if ((LA7_9==STATIC)) {s = 198;}

				else if ((LA7_9==246)) {s = 199;}

				else if ((LA7_9==244)) {s = 200;}

				else if ((LA7_9==245)) {s = 201;}

				else if ((LA7_9==252)) {s = 202;}

				else if ((LA7_9==DYNAMIC)) {s = 203;}

				else if ((LA7_9==250)) {s = 204;}

				else if ((LA7_9==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 205;}

				else if ((LA7_9==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 206;}

				else if ((LA7_9==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 207;}

				else if ((LA7_9==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 208;}

				else if ((LA7_9==CONST||LA7_9==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 209;}


				input.Seek(index7_9);
				if (s >= 0) return s;
				break;

			case 6:
				int LA7_10 = input.LA(1);


				int index7_10 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_10==IDENT)) {s = 210;}

				else if ((LA7_10==INTERNAL||LA7_10==PRIVATE||(LA7_10>=PROTECTED && LA7_10<=PUBLIC))) {s = 211;}

				else if ((LA7_10==STATIC)) {s = 212;}

				else if ((LA7_10==246)) {s = 213;}

				else if ((LA7_10==244)) {s = 214;}

				else if ((LA7_10==245)) {s = 215;}

				else if ((LA7_10==252)) {s = 216;}

				else if ((LA7_10==DYNAMIC)) {s = 217;}

				else if ((LA7_10==250)) {s = 218;}

				else if ((LA7_10==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 219;}

				else if ((LA7_10==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 220;}

				else if ((LA7_10==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 221;}

				else if ((LA7_10==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 222;}

				else if ((LA7_10==CONST||LA7_10==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 223;}


				input.Seek(index7_10);
				if (s >= 0) return s;
				break;

			case 7:
				int LA7_11 = input.LA(1);


				int index7_11 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_11==IDENT)) {s = 224;}

				else if ((LA7_11==INTERNAL||LA7_11==PRIVATE||(LA7_11>=PROTECTED && LA7_11<=PUBLIC))) {s = 225;}

				else if ((LA7_11==STATIC)) {s = 226;}

				else if ((LA7_11==246)) {s = 227;}

				else if ((LA7_11==244)) {s = 228;}

				else if ((LA7_11==245)) {s = 229;}

				else if ((LA7_11==252)) {s = 230;}

				else if ((LA7_11==DYNAMIC)) {s = 231;}

				else if ((LA7_11==250)) {s = 232;}

				else if ((LA7_11==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 233;}

				else if ((LA7_11==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 234;}

				else if ((LA7_11==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 235;}

				else if ((LA7_11==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 236;}

				else if ((LA7_11==CONST||LA7_11==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 237;}


				input.Seek(index7_11);
				if (s >= 0) return s;
				break;

			case 8:
				int LA7_12 = input.LA(1);


				int index7_12 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_12==IDENT)) {s = 238;}

				else if ((LA7_12==INTERNAL||LA7_12==PRIVATE||(LA7_12>=PROTECTED && LA7_12<=PUBLIC))) {s = 239;}

				else if ((LA7_12==STATIC)) {s = 240;}

				else if ((LA7_12==246)) {s = 241;}

				else if ((LA7_12==244)) {s = 242;}

				else if ((LA7_12==245)) {s = 243;}

				else if ((LA7_12==252)) {s = 244;}

				else if ((LA7_12==DYNAMIC)) {s = 245;}

				else if ((LA7_12==250)) {s = 246;}

				else if ((LA7_12==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 247;}

				else if ((LA7_12==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 248;}

				else if ((LA7_12==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 249;}

				else if ((LA7_12==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 250;}

				else if ((LA7_12==CONST||LA7_12==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 251;}

				else if (((LA7_12>=AS && LA7_12<=ASSIGN)||(LA7_12>=BAND && LA7_12<=BAND_ASSIGN)||(LA7_12>=BOR && LA7_12<=BOR_ASSIGN)||(LA7_12>=BSR && LA7_12<=BXOR_ASSIGN)||LA7_12==COMMA||LA7_12==DEC||(LA7_12>=DIV && LA7_12<=DIV_ASSIGN)||LA7_12==DOT||LA7_12==E4X_DESC||LA7_12==EQUAL||LA7_12==GE||LA7_12==GT||LA7_12==INC||(LA7_12>=IS && LA7_12<=LBRACK)||LA7_12==LE||(LA7_12>=LOR && LA7_12<=LT)||(LA7_12>=MINUS && LA7_12<=MINUS_ASSIGN)||LA7_12==MOD||LA7_12==MOD_ASSIGN||LA7_12==NOT_EQUAL||(LA7_12>=PLUS && LA7_12<=PLUS_ASSIGN)||LA7_12==QUESTION||LA7_12==SEMI||(LA7_12>=SL && LA7_12<=SL_ASSIGN)||(LA7_12>=SR && LA7_12<=STAR_ASSIGN)||(LA7_12>=STRICT_EQUAL && LA7_12<=STRICT_NOT_EQUAL)||LA7_12==241||LA7_12==249||LA7_12==251)) {s = 19;}


				input.Seek(index7_12);
				if (s >= 0) return s;
				break;

			case 9:
				int LA7_13 = input.LA(1);


				int index7_13 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_13==IDENT)) {s = 272;}

				else if ((LA7_13==INTERNAL||LA7_13==PRIVATE||(LA7_13>=PROTECTED && LA7_13<=PUBLIC))) {s = 273;}

				else if ((LA7_13==STATIC)) {s = 274;}

				else if ((LA7_13==246)) {s = 275;}

				else if ((LA7_13==244)) {s = 276;}

				else if ((LA7_13==245)) {s = 277;}

				else if ((LA7_13==252)) {s = 278;}

				else if ((LA7_13==DYNAMIC)) {s = 279;}

				else if ((LA7_13==250)) {s = 280;}

				else if ((LA7_13==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 281;}

				else if ((LA7_13==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((LA7_13==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((LA7_13==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 284;}

				else if ((LA7_13==CONST||LA7_13==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_13);
				if (s >= 0) return s;
				break;

			case 10:
				int LA7_14 = input.LA(1);


				int index7_14 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_14==IDENT) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 286;}

				else if ((LA7_14==INTERNAL||LA7_14==PRIVATE||(LA7_14>=PROTECTED && LA7_14<=PUBLIC)) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if (((LA7_14>=AS && LA7_14<=ASSIGN)||(LA7_14>=BAND && LA7_14<=BAND_ASSIGN)||(LA7_14>=BOR && LA7_14<=BOR_ASSIGN)||(LA7_14>=BSR && LA7_14<=BXOR_ASSIGN)||LA7_14==COMMA||LA7_14==DEC||(LA7_14>=DIV && LA7_14<=DIV_ASSIGN)||LA7_14==DOT||LA7_14==E4X_DESC||LA7_14==EQUAL||LA7_14==GE||LA7_14==GT||LA7_14==INC||(LA7_14>=IS && LA7_14<=LBRACK)||LA7_14==LE||(LA7_14>=LOR && LA7_14<=LT)||(LA7_14>=MINUS && LA7_14<=MINUS_ASSIGN)||LA7_14==MOD||LA7_14==MOD_ASSIGN||LA7_14==NOT_EQUAL||(LA7_14>=PLUS && LA7_14<=PLUS_ASSIGN)||LA7_14==QUESTION||LA7_14==SEMI||(LA7_14>=SL && LA7_14<=SL_ASSIGN)||(LA7_14>=SR && LA7_14<=STAR_ASSIGN)||(LA7_14>=STRICT_EQUAL && LA7_14<=STRICT_NOT_EQUAL)||LA7_14==241||LA7_14==249||LA7_14==251)) {s = 19;}


				input.Seek(index7_14);
				if (s >= 0) return s;
				break;

			case 11:
				int LA7_17 = input.LA(1);


				int index7_17 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA7_17==GET) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 308;}

				else if ((LA7_17==IDENT) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 309;}

				else if ((LA7_17==USE) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 310;}

				else if ((LA7_17==XML) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 311;}

				else if ((LA7_17==DYNAMIC) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 312;}

				else if ((LA7_17==NAMESPACE) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 313;}

				else if ((LA7_17==IS) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 314;}

				else if ((LA7_17==AS) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 315;}

				else if ((LA7_17==SET) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 316;}

				else if ((LA7_17==SUPER) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((LA7_17==LPAREN)) {s = 19;}


				input.Seek(index7_17);
				if (s >= 0) return s;
				break;

			case 12:
				int LA7_81 = input.LA(1);


				int index7_81 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_81);
				if (s >= 0) return s;
				break;

			case 13:
				int LA7_82 = input.LA(1);


				int index7_82 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_82);
				if (s >= 0) return s;
				break;

			case 14:
				int LA7_83 = input.LA(1);


				int index7_83 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_83);
				if (s >= 0) return s;
				break;

			case 15:
				int LA7_84 = input.LA(1);


				int index7_84 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_84);
				if (s >= 0) return s;
				break;

			case 16:
				int LA7_85 = input.LA(1);


				int index7_85 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_85);
				if (s >= 0) return s;
				break;

			case 17:
				int LA7_86 = input.LA(1);


				int index7_86 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_86);
				if (s >= 0) return s;
				break;

			case 18:
				int LA7_87 = input.LA(1);


				int index7_87 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_87);
				if (s >= 0) return s;
				break;

			case 19:
				int LA7_88 = input.LA(1);


				int index7_88 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_88);
				if (s >= 0) return s;
				break;

			case 20:
				int LA7_89 = input.LA(1);


				int index7_89 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_89);
				if (s >= 0) return s;
				break;

			case 21:
				int LA7_90 = input.LA(1);


				int index7_90 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}


				input.Seek(index7_90);
				if (s >= 0) return s;
				break;

			case 22:
				int LA7_118 = input.LA(1);


				int index7_118 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_118);
				if (s >= 0) return s;
				break;

			case 23:
				int LA7_119 = input.LA(1);


				int index7_119 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_119);
				if (s >= 0) return s;
				break;

			case 24:
				int LA7_120 = input.LA(1);


				int index7_120 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_120);
				if (s >= 0) return s;
				break;

			case 25:
				int LA7_121 = input.LA(1);


				int index7_121 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_121);
				if (s >= 0) return s;
				break;

			case 26:
				int LA7_122 = input.LA(1);


				int index7_122 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_122);
				if (s >= 0) return s;
				break;

			case 27:
				int LA7_123 = input.LA(1);


				int index7_123 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_123);
				if (s >= 0) return s;
				break;

			case 28:
				int LA7_124 = input.LA(1);


				int index7_124 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_124);
				if (s >= 0) return s;
				break;

			case 29:
				int LA7_125 = input.LA(1);


				int index7_125 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_125);
				if (s >= 0) return s;
				break;

			case 30:
				int LA7_126 = input.LA(1);


				int index7_126 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_126);
				if (s >= 0) return s;
				break;

			case 31:
				int LA7_153 = input.LA(1);


				int index7_153 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_153);
				if (s >= 0) return s;
				break;

			case 32:
				int LA7_154 = input.LA(1);


				int index7_154 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_154);
				if (s >= 0) return s;
				break;

			case 33:
				int LA7_155 = input.LA(1);


				int index7_155 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_155);
				if (s >= 0) return s;
				break;

			case 34:
				int LA7_156 = input.LA(1);


				int index7_156 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_156);
				if (s >= 0) return s;
				break;

			case 35:
				int LA7_157 = input.LA(1);


				int index7_157 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_157);
				if (s >= 0) return s;
				break;

			case 36:
				int LA7_158 = input.LA(1);


				int index7_158 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_158);
				if (s >= 0) return s;
				break;

			case 37:
				int LA7_159 = input.LA(1);


				int index7_159 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_159);
				if (s >= 0) return s;
				break;

			case 38:
				int LA7_160 = input.LA(1);


				int index7_160 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_160);
				if (s >= 0) return s;
				break;

			case 39:
				int LA7_161 = input.LA(1);


				int index7_161 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_161);
				if (s >= 0) return s;
				break;

			case 40:
				int LA7_168 = input.LA(1);


				int index7_168 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_168);
				if (s >= 0) return s;
				break;

			case 41:
				int LA7_169 = input.LA(1);


				int index7_169 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_169);
				if (s >= 0) return s;
				break;

			case 42:
				int LA7_170 = input.LA(1);


				int index7_170 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_170);
				if (s >= 0) return s;
				break;

			case 43:
				int LA7_171 = input.LA(1);


				int index7_171 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_171);
				if (s >= 0) return s;
				break;

			case 44:
				int LA7_172 = input.LA(1);


				int index7_172 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_172);
				if (s >= 0) return s;
				break;

			case 45:
				int LA7_173 = input.LA(1);


				int index7_173 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_173);
				if (s >= 0) return s;
				break;

			case 46:
				int LA7_174 = input.LA(1);


				int index7_174 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_174);
				if (s >= 0) return s;
				break;

			case 47:
				int LA7_175 = input.LA(1);


				int index7_175 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_175);
				if (s >= 0) return s;
				break;

			case 48:
				int LA7_176 = input.LA(1);


				int index7_176 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_176);
				if (s >= 0) return s;
				break;

			case 49:
				int LA7_182 = input.LA(1);


				int index7_182 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_182);
				if (s >= 0) return s;
				break;

			case 50:
				int LA7_183 = input.LA(1);


				int index7_183 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_183);
				if (s >= 0) return s;
				break;

			case 51:
				int LA7_184 = input.LA(1);


				int index7_184 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_184);
				if (s >= 0) return s;
				break;

			case 52:
				int LA7_185 = input.LA(1);


				int index7_185 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_185);
				if (s >= 0) return s;
				break;

			case 53:
				int LA7_186 = input.LA(1);


				int index7_186 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_186);
				if (s >= 0) return s;
				break;

			case 54:
				int LA7_187 = input.LA(1);


				int index7_187 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_187);
				if (s >= 0) return s;
				break;

			case 55:
				int LA7_188 = input.LA(1);


				int index7_188 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_188);
				if (s >= 0) return s;
				break;

			case 56:
				int LA7_189 = input.LA(1);


				int index7_189 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_189);
				if (s >= 0) return s;
				break;

			case 57:
				int LA7_190 = input.LA(1);


				int index7_190 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_190);
				if (s >= 0) return s;
				break;

			case 58:
				int LA7_196 = input.LA(1);


				int index7_196 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_196);
				if (s >= 0) return s;
				break;

			case 59:
				int LA7_197 = input.LA(1);


				int index7_197 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_197);
				if (s >= 0) return s;
				break;

			case 60:
				int LA7_198 = input.LA(1);


				int index7_198 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_198);
				if (s >= 0) return s;
				break;

			case 61:
				int LA7_199 = input.LA(1);


				int index7_199 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_199);
				if (s >= 0) return s;
				break;

			case 62:
				int LA7_200 = input.LA(1);


				int index7_200 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_200);
				if (s >= 0) return s;
				break;

			case 63:
				int LA7_201 = input.LA(1);


				int index7_201 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_201);
				if (s >= 0) return s;
				break;

			case 64:
				int LA7_202 = input.LA(1);


				int index7_202 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_202);
				if (s >= 0) return s;
				break;

			case 65:
				int LA7_203 = input.LA(1);


				int index7_203 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_203);
				if (s >= 0) return s;
				break;

			case 66:
				int LA7_204 = input.LA(1);


				int index7_204 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_204);
				if (s >= 0) return s;
				break;

			case 67:
				int LA7_210 = input.LA(1);


				int index7_210 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_210);
				if (s >= 0) return s;
				break;

			case 68:
				int LA7_211 = input.LA(1);


				int index7_211 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_211);
				if (s >= 0) return s;
				break;

			case 69:
				int LA7_212 = input.LA(1);


				int index7_212 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_212);
				if (s >= 0) return s;
				break;

			case 70:
				int LA7_213 = input.LA(1);


				int index7_213 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_213);
				if (s >= 0) return s;
				break;

			case 71:
				int LA7_214 = input.LA(1);


				int index7_214 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_214);
				if (s >= 0) return s;
				break;

			case 72:
				int LA7_215 = input.LA(1);


				int index7_215 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_215);
				if (s >= 0) return s;
				break;

			case 73:
				int LA7_216 = input.LA(1);


				int index7_216 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_216);
				if (s >= 0) return s;
				break;

			case 74:
				int LA7_217 = input.LA(1);


				int index7_217 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_217);
				if (s >= 0) return s;
				break;

			case 75:
				int LA7_218 = input.LA(1);


				int index7_218 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_218);
				if (s >= 0) return s;
				break;

			case 76:
				int LA7_224 = input.LA(1);


				int index7_224 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_224);
				if (s >= 0) return s;
				break;

			case 77:
				int LA7_225 = input.LA(1);


				int index7_225 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_225);
				if (s >= 0) return s;
				break;

			case 78:
				int LA7_226 = input.LA(1);


				int index7_226 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_226);
				if (s >= 0) return s;
				break;

			case 79:
				int LA7_227 = input.LA(1);


				int index7_227 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_227);
				if (s >= 0) return s;
				break;

			case 80:
				int LA7_228 = input.LA(1);


				int index7_228 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_228);
				if (s >= 0) return s;
				break;

			case 81:
				int LA7_229 = input.LA(1);


				int index7_229 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_229);
				if (s >= 0) return s;
				break;

			case 82:
				int LA7_230 = input.LA(1);


				int index7_230 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_230);
				if (s >= 0) return s;
				break;

			case 83:
				int LA7_231 = input.LA(1);


				int index7_231 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_231);
				if (s >= 0) return s;
				break;

			case 84:
				int LA7_232 = input.LA(1);


				int index7_232 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_232);
				if (s >= 0) return s;
				break;

			case 85:
				int LA7_238 = input.LA(1);


				int index7_238 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_238);
				if (s >= 0) return s;
				break;

			case 86:
				int LA7_239 = input.LA(1);


				int index7_239 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_239);
				if (s >= 0) return s;
				break;

			case 87:
				int LA7_240 = input.LA(1);


				int index7_240 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_240);
				if (s >= 0) return s;
				break;

			case 88:
				int LA7_241 = input.LA(1);


				int index7_241 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_241);
				if (s >= 0) return s;
				break;

			case 89:
				int LA7_242 = input.LA(1);


				int index7_242 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_242);
				if (s >= 0) return s;
				break;

			case 90:
				int LA7_243 = input.LA(1);


				int index7_243 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_243);
				if (s >= 0) return s;
				break;

			case 91:
				int LA7_244 = input.LA(1);


				int index7_244 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_244);
				if (s >= 0) return s;
				break;

			case 92:
				int LA7_245 = input.LA(1);


				int index7_245 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_245);
				if (s >= 0) return s;
				break;

			case 93:
				int LA7_246 = input.LA(1);


				int index7_246 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_246);
				if (s >= 0) return s;
				break;

			case 94:
				int LA7_272 = input.LA(1);


				int index7_272 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_272);
				if (s >= 0) return s;
				break;

			case 95:
				int LA7_273 = input.LA(1);


				int index7_273 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_273);
				if (s >= 0) return s;
				break;

			case 96:
				int LA7_274 = input.LA(1);


				int index7_274 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_274);
				if (s >= 0) return s;
				break;

			case 97:
				int LA7_275 = input.LA(1);


				int index7_275 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_275);
				if (s >= 0) return s;
				break;

			case 98:
				int LA7_276 = input.LA(1);


				int index7_276 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_276);
				if (s >= 0) return s;
				break;

			case 99:
				int LA7_277 = input.LA(1);


				int index7_277 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_277);
				if (s >= 0) return s;
				break;

			case 100:
				int LA7_278 = input.LA(1);


				int index7_278 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_278);
				if (s >= 0) return s;
				break;

			case 101:
				int LA7_279 = input.LA(1);


				int index7_279 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_279);
				if (s >= 0) return s;
				break;

			case 102:
				int LA7_280 = input.LA(1);


				int index7_280 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}


				input.Seek(index7_280);
				if (s >= 0) return s;
				break;

			case 103:
				int LA7_319 = input.LA(1);


				int index7_319 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_319);
				if (s >= 0) return s;
				break;

			case 104:
				int LA7_320 = input.LA(1);


				int index7_320 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_320);
				if (s >= 0) return s;
				break;

			case 105:
				int LA7_321 = input.LA(1);


				int index7_321 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_321);
				if (s >= 0) return s;
				break;

			case 106:
				int LA7_322 = input.LA(1);


				int index7_322 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_322);
				if (s >= 0) return s;
				break;

			case 107:
				int LA7_323 = input.LA(1);


				int index7_323 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_323);
				if (s >= 0) return s;
				break;

			case 108:
				int LA7_324 = input.LA(1);


				int index7_324 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_324);
				if (s >= 0) return s;
				break;

			case 109:
				int LA7_325 = input.LA(1);


				int index7_325 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_325);
				if (s >= 0) return s;
				break;

			case 110:
				int LA7_326 = input.LA(1);


				int index7_326 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_326);
				if (s >= 0) return s;
				break;

			case 111:
				int LA7_327 = input.LA(1);


				int index7_327 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_327);
				if (s >= 0) return s;
				break;

			case 112:
				int LA7_328 = input.LA(1);


				int index7_328 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}


				input.Seek(index7_328);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 7, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\x102\xFFFF";
		private const string DFA17_eofS =
			"\x102\xFFFF";
		private const string DFA17_minS =
			"\x1\xF\x2\xFFFF\x2\xF\x6\x2A\x1\xF\x1\x2A\x2\xF\x2B\xFFFF\xA\x0\x1B\xFFFF"+
			"\x9\x0\x17\xFFFF\x9\x0\x3\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2"+
			"\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x16\xFFFF\x9\x0\x2\xFFFF\xA"+
			"\x0\xC\xFFFF";
		private const string DFA17_maxS =
			"\x1\x101\x2\xFFFF\x1\x101\x9\xFC\x2\xE7\x2B\xFFFF\xA\x0\x1B\xFFFF\x9"+
			"\x0\x17\xFFFF\x9\x0\x3\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF"+
			"\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x16\xFFFF\x9\x0\x2\xFFFF\xA\x0\xC"+
			"\xFFFF";
		private const string DFA17_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\xC\xFFFF\x1\x6\x58\xFFFF\x1\x4\x1\x5\x1E\xFFFF"+
			"\x1\x4\x1\x5\xA\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4"+
			"\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5"+
			"\x1D\xFFFF\x1\x4\x1\x5\xA\xFFFF\xA\x5\x1\xFFFF\x1\x3";
		private const string DFA17_specialS =
			"\x4\xFFFF\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF"+
			"\x1\x9\x2B\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1"+
			"\x12\x1\x13\x1B\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A"+
			"\x1\x1B\x1\x1C\x17\xFFFF\x1\x1D\x1\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1"+
			"\x23\x1\x24\x1\x25\x3\xFFFF\x1\x26\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B"+
			"\x1\x2C\x1\x2D\x1\x2E\x2\xFFFF\x1\x2F\x1\x30\x1\x31\x1\x32\x1\x33\x1"+
			"\x34\x1\x35\x1\x36\x1\x37\x2\xFFFF\x1\x38\x1\x39\x1\x3A\x1\x3B\x1\x3C"+
			"\x1\x3D\x1\x3E\x1\x3F\x1\x40\x2\xFFFF\x1\x41\x1\x42\x1\x43\x1\x44\x1"+
			"\x45\x1\x46\x1\x47\x1\x48\x1\x49\x2\xFFFF\x1\x4A\x1\x4B\x1\x4C\x1\x4D"+
			"\x1\x4E\x1\x4F\x1\x50\x1\x51\x1\x52\x2\xFFFF\x1\x53\x1\x54\x1\x55\x1"+
			"\x56\x1\x57\x1\x58\x1\x59\x1\x5A\x1\x5B\x16\xFFFF\x1\x5C\x1\x5D\x1\x5E"+
			"\x1\x5F\x1\x60\x1\x61\x1\x62\x1\x63\x1\x64\x2\xFFFF\x1\x65\x1\x66\x1"+
			"\x67\x1\x68\x1\x69\x1\x6A\x1\x6B\x1\x6C\x1\x6D\x1\x6E\xC\xFFFF}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\x1\xF\x5\xFFFF\x1\xF\x3\xFFFF\x1\xF\x10\xFFFF\x1\xD\x1\xFFFF\x1\xF"+
				"\x3\xFFFF\x2\xF\x2\xFFFF\x1\xF\x3\xFFFF\x1\xF\x3\xFFFF\x1\xB\x1\xF\x11"+
				"\xFFFF\x3\xF\x8\xFFFF\x1\xE\x3\xFFFF\x1\xF\x2\xFFFF\x1\xF\x1\x4\x2\xFFFF"+
				"\x1\xF\x3\xFFFF\x1\x2\x2\xFFFF\x1\xF\x3\xFFFF\x1\x5\x1\xF\x2\xFFFF\x1"+
				"\x3\x1\xF\x7\xFFFF\x1\xF\x2\xFFFF\x1\xF\x7\xFFFF\x1\xF\x7\xFFFF\x1\xF"+
				"\x2\xFFFF\x1\xF\x4\xFFFF\x1\xF\x3\xFFFF\x1\xF\x8\xFFFF\x1\xF\x6\xFFFF"+
				"\x1\x5\x2\xFFFF\x2\x5\x6\xFFFF\x1\xF\x2\xFFFF\x1\xF\x2\xFFFF\x2\xF\x9"+
				"\xFFFF\x1\x6\x2\xFFFF\x4\xF\x5\xFFFF\x1\xF\x6\xFFFF\x1\xF\x1\xD\x6\xFFFF"+
				"\x1\xF\x1\xFFFF\x1\xF\x1\xFFFF\x1\xF\x5\xFFFF\x1\xF\x5\xFFFF\x1\xF\x1"+
				"\x8\x1\x9\x1\x7\x1\xFFFF\x1\x1\x1\xFFFF\x1\xC\x1\xFFFF\x1\xA\x5\xF",
				"",
				"",
				"\x1\x40\x5\xFFFF\x1\xF\x11\xFFFF\x1\xF\x8\xFFFF\x2\xF\xA\xFFFF\x1\x3D"+
				"\x1\xF\x11\xFFFF\x2\xF\x9\xFFFF\x1\xF\x3\xFFFF\x1\x41\x2\xFFFF\x1\xF"+
				"\x1\x3A\x9\xFFFF\x1\xF\x3\xFFFF\x1\xF\x1\x3F\x2\xFFFF\x2\xF\x7\xFFFF"+
				"\x1\xF\x2\xFFFF\x1\xF\x7\xFFFF\x1\xF\x7\xFFFF\x1\x3E\x2\xFFFF\x1\xF"+
				"\x4\xFFFF\x1\xF\x3\xFFFF\x1\xF\x8\xFFFF\x1\xF\x6\xFFFF\x1\xF\x2\xFFFF"+
				"\x2\xF\x2\xFFFF\x1\xF\x3\xFFFF\x1\xF\x6\xFFFF\x1\x42\xC\xFFFF\x2\xF"+
				"\x1\x43\x6\xFFFF\x1\xF\x6\xFFFF\x1\x3B\xB\xFFFF\x1\x3C\x5\xFFFF\x1\xF"+
				"\x5\xFFFF\x1\xF\xB\xFFFF\x3\xF",
				"\x2\xF\x1\xFFFF\x2\xF\x3\xFFFF\x2\xF\x3\xFFFF\x4\xF\x7\xFFFF\x1\xF"+
				"\x2\xFFFF\x1\x68\x4\xFFFF\x2\xF\x5\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\x66\x1\xFFFF\x1\xF\x7\xFFFF\x1\xF\x13\xFFFF\x1\x69\x2\xFFFF\x1\xF"+
				"\x1\xFFFF\x1\xF\x2\xFFFF\x1\x5F\x9\xFFFF\x1\xF\x3\xFFFF\x1\x60\x4\xF"+
				"\x1\xFFFF\x1\xF\x7\xFFFF\x4\xF\x6\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xF\x8\xFFFF\x1\xF\xD\xFFFF\x2\xF\x5\xFFFF\x1\x60\x2\xFFFF\x2\x60"+
				"\x1\xFFFF\x1\xF\xA\xFFFF\x1\xF\x1\xFFFF\x2\xF\x1\xFFFF\x4\xF\x2\xFFFF"+
				"\x1\x61\x2\xF\x11\xFFFF\x1\x68\x14\xFFFF\x1\xF\x2\xFFFF\x1\x63\x1\x64"+
				"\x1\x62\x2\xFFFF\x1\xF\x1\x67\x1\xF\x1\x65",
				"\x1\x88\x4\xFFFF\x1\xF\xC\xFFFF\x1\x86\x1D\xFFFF\x1\x89\x7\xFFFF\x1"+
				"\x7F\xD\xFFFF\x1\x80\x3B\xFFFF\x1\x80\x2\xFFFF\x2\x80\x17\xFFFF\x1\x81"+
				"\x13\xFFFF\x1\x88\x17\xFFFF\x1\x83\x1\x84\x1\x82\x3\xFFFF\x1\x87\x1"+
				"\xFFFF\x1\x85",
				"\x1\x94\x11\xFFFF\x1\x92\x1D\xFFFF\x1\x95\x7\xFFFF\x1\x8B\xD\xFFFF"+
				"\x1\x8C\x3B\xFFFF\x1\x8C\x2\xFFFF\x2\x8C\x17\xFFFF\x1\x8D\x13\xFFFF"+
				"\x1\x94\x17\xFFFF\x1\x8F\x1\x90\x1\x8E\x3\xFFFF\x1\x93\x1\xFFFF\x1\x91",
				"\x1\x9F\x11\xFFFF\x1\x9D\x1D\xFFFF\x1\xA0\x7\xFFFF\x1\x96\xD\xFFFF"+
				"\x1\x97\x3B\xFFFF\x1\x97\x2\xFFFF\x2\x97\x17\xFFFF\x1\x98\x13\xFFFF"+
				"\x1\x9F\x17\xFFFF\x1\x9A\x1\x9B\x1\x99\x3\xFFFF\x1\x9E\x1\xFFFF\x1\x9C",
				"\x1\xAA\x11\xFFFF\x1\xA8\x1D\xFFFF\x1\xAB\x7\xFFFF\x1\xA1\xD\xFFFF"+
				"\x1\xA2\x3B\xFFFF\x1\xA2\x2\xFFFF\x2\xA2\x17\xFFFF\x1\xA3\x13\xFFFF"+
				"\x1\xAA\x17\xFFFF\x1\xA5\x1\xA6\x1\xA4\x3\xFFFF\x1\xA9\x1\xFFFF\x1\xA7",
				"\x1\xB5\x11\xFFFF\x1\xB3\x1D\xFFFF\x1\xB6\x7\xFFFF\x1\xAC\xD\xFFFF"+
				"\x1\xAD\x3B\xFFFF\x1\xAD\x2\xFFFF\x2\xAD\x17\xFFFF\x1\xAE\x13\xFFFF"+
				"\x1\xB5\x17\xFFFF\x1\xB0\x1\xB1\x1\xAF\x3\xFFFF\x1\xB4\x1\xFFFF\x1\xB2",
				"\x1\xC0\x11\xFFFF\x1\xBE\x1D\xFFFF\x1\xC1\x7\xFFFF\x1\xB7\xD\xFFFF"+
				"\x1\xB8\x3B\xFFFF\x1\xB8\x2\xFFFF\x2\xB8\x17\xFFFF\x1\xB9\x13\xFFFF"+
				"\x1\xC0\x17\xFFFF\x1\xBB\x1\xBC\x1\xBA\x3\xFFFF\x1\xBF\x1\xFFFF\x1\xBD",
				"\x2\xF\x1\xFFFF\x2\xF\x3\xFFFF\x2\xF\x3\xFFFF\x4\xF\x7\xFFFF\x1\xF"+
				"\x2\xFFFF\x1\xCB\x5\xFFFF\x1\xF\x5\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xC9\x1\xFFFF\x1\xF\x7\xFFFF\x1\xF\x13\xFFFF\x1\xCC\x2\xFFFF\x1\xF"+
				"\x1\xFFFF\x1\xF\x2\xFFFF\x1\xC2\x9\xFFFF\x1\xF\x3\xFFFF\x1\xC3\x4\xF"+
				"\x1\xFFFF\x1\xF\x7\xFFFF\x4\xF\x6\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xF\x8\xFFFF\x1\xF\xD\xFFFF\x2\xF\x5\xFFFF\x1\xC3\x2\xFFFF\x2\xC3"+
				"\x1\xFFFF\x1\xF\xA\xFFFF\x1\xF\x1\xFFFF\x2\xF\x1\xFFFF\x4\xF\x2\xFFFF"+
				"\x1\xC4\x2\xF\x11\xFFFF\x1\xCB\x14\xFFFF\x1\xF\x2\xFFFF\x1\xC6\x1\xC7"+
				"\x1\xC5\x2\xFFFF\x1\xF\x1\xCA\x1\xF\x1\xC8",
				"\x1\xEA\x11\xFFFF\x1\xE8\x1D\xFFFF\x1\xEB\x7\xFFFF\x1\xE1\xD\xFFFF"+
				"\x1\xE2\x3B\xFFFF\x1\xE2\x2\xFFFF\x2\xE2\x17\xFFFF\x1\xE3\x13\xFFFF"+
				"\x1\xEA\x17\xFFFF\x1\xE5\x1\xE6\x1\xE4\x3\xFFFF\x1\xE9\x1\xFFFF\x1\xE7",
				"\x1\xF2\x2C\xFFFF\x1\xEF\x21\xFFFF\x1\xF3\x3\xFFFF\x1\xEC\xE\xFFFF"+
				"\x1\xF1\x1E\xFFFF\x1\xF0\x2D\xFFFF\x1\xF4\xE\xFFFF\x1\xF5\xD\xFFFF\x1"+
				"\xED\xB\xFFFF\x1\xEE",
				"\x1\xFD\x2C\xFFFF\x1\xFA\x21\xFFFF\x1\xF6\x3\xFFFF\x1\xF7\xE\xFFFF"+
				"\x1\xFC\xE\xFFFF\x1\xF\xF\xFFFF\x1\xFB\x2D\xFFFF\x1\xFE\xE\xFFFF\x1"+
				"\xFF\xD\xFFFF\x1\xF8\xB\xFFFF\x1\xF9",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "227:1: typeBlockEntry options {k=2; } : ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition17(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA17_4 = input.LA(1);


				int index17_4 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_4==IDENT)) {s = 95;}

				else if ((LA17_4==INTERNAL||LA17_4==PRIVATE||(LA17_4>=PROTECTED && LA17_4<=PUBLIC))) {s = 96;}

				else if ((LA17_4==STATIC)) {s = 97;}

				else if ((LA17_4==246)) {s = 98;}

				else if ((LA17_4==244)) {s = 99;}

				else if ((LA17_4==245)) {s = 100;}

				else if ((LA17_4==252)) {s = 101;}

				else if ((LA17_4==DYNAMIC)) {s = 102;}

				else if ((LA17_4==250)) {s = 103;}

				else if ((LA17_4==CONST||LA17_4==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 104;}

				else if ((LA17_4==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 105;}

				else if (((LA17_4>=AS && LA17_4<=ASSIGN)||(LA17_4>=BAND && LA17_4<=BAND_ASSIGN)||(LA17_4>=BOR && LA17_4<=BOR_ASSIGN)||(LA17_4>=BSR && LA17_4<=BXOR_ASSIGN)||LA17_4==COMMA||(LA17_4>=DBL_COLON && LA17_4<=DEC)||(LA17_4>=DIV && LA17_4<=DIV_ASSIGN)||LA17_4==DOT||LA17_4==E4X_DESC||LA17_4==EQUAL||LA17_4==GE||LA17_4==GT||LA17_4==INC||(LA17_4>=IS && LA17_4<=LBRACK)||LA17_4==LE||(LA17_4>=LOR && LA17_4<=LT)||(LA17_4>=MINUS && LA17_4<=MINUS_ASSIGN)||LA17_4==MOD||LA17_4==MOD_ASSIGN||LA17_4==NOT_EQUAL||(LA17_4>=PLUS && LA17_4<=PLUS_ASSIGN)||LA17_4==QUESTION||LA17_4==SEMI||(LA17_4>=SL && LA17_4<=SL_ASSIGN)||(LA17_4>=SR && LA17_4<=STAR_ASSIGN)||(LA17_4>=STRICT_EQUAL && LA17_4<=STRICT_NOT_EQUAL)||LA17_4==241||LA17_4==249||LA17_4==251)) {s = 15;}


				input.Seek(index17_4);
				if (s >= 0) return s;
				break;

			case 1:
				int LA17_5 = input.LA(1);


				int index17_5 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_5==IDENT)) {s = 127;}

				else if ((LA17_5==INTERNAL||LA17_5==PRIVATE||(LA17_5>=PROTECTED && LA17_5<=PUBLIC))) {s = 128;}

				else if ((LA17_5==STATIC)) {s = 129;}

				else if ((LA17_5==246)) {s = 130;}

				else if ((LA17_5==244)) {s = 131;}

				else if ((LA17_5==245)) {s = 132;}

				else if ((LA17_5==252)) {s = 133;}

				else if ((LA17_5==DYNAMIC)) {s = 134;}

				else if ((LA17_5==250)) {s = 135;}

				else if ((LA17_5==CONST||LA17_5==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 136;}

				else if ((LA17_5==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 137;}

				else if ((LA17_5==DBL_COLON)) {s = 15;}


				input.Seek(index17_5);
				if (s >= 0) return s;
				break;

			case 2:
				int LA17_6 = input.LA(1);


				int index17_6 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_6==IDENT)) {s = 139;}

				else if ((LA17_6==INTERNAL||LA17_6==PRIVATE||(LA17_6>=PROTECTED && LA17_6<=PUBLIC))) {s = 140;}

				else if ((LA17_6==STATIC)) {s = 141;}

				else if ((LA17_6==246)) {s = 142;}

				else if ((LA17_6==244)) {s = 143;}

				else if ((LA17_6==245)) {s = 144;}

				else if ((LA17_6==252)) {s = 145;}

				else if ((LA17_6==DYNAMIC)) {s = 146;}

				else if ((LA17_6==250)) {s = 147;}

				else if ((LA17_6==CONST||LA17_6==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 148;}

				else if ((LA17_6==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 149;}


				input.Seek(index17_6);
				if (s >= 0) return s;
				break;

			case 3:
				int LA17_7 = input.LA(1);


				int index17_7 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_7==IDENT)) {s = 150;}

				else if ((LA17_7==INTERNAL||LA17_7==PRIVATE||(LA17_7>=PROTECTED && LA17_7<=PUBLIC))) {s = 151;}

				else if ((LA17_7==STATIC)) {s = 152;}

				else if ((LA17_7==246)) {s = 153;}

				else if ((LA17_7==244)) {s = 154;}

				else if ((LA17_7==245)) {s = 155;}

				else if ((LA17_7==252)) {s = 156;}

				else if ((LA17_7==DYNAMIC)) {s = 157;}

				else if ((LA17_7==250)) {s = 158;}

				else if ((LA17_7==CONST||LA17_7==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 159;}

				else if ((LA17_7==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 160;}


				input.Seek(index17_7);
				if (s >= 0) return s;
				break;

			case 4:
				int LA17_8 = input.LA(1);


				int index17_8 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_8==IDENT)) {s = 161;}

				else if ((LA17_8==INTERNAL||LA17_8==PRIVATE||(LA17_8>=PROTECTED && LA17_8<=PUBLIC))) {s = 162;}

				else if ((LA17_8==STATIC)) {s = 163;}

				else if ((LA17_8==246)) {s = 164;}

				else if ((LA17_8==244)) {s = 165;}

				else if ((LA17_8==245)) {s = 166;}

				else if ((LA17_8==252)) {s = 167;}

				else if ((LA17_8==DYNAMIC)) {s = 168;}

				else if ((LA17_8==250)) {s = 169;}

				else if ((LA17_8==CONST||LA17_8==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 170;}

				else if ((LA17_8==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 171;}


				input.Seek(index17_8);
				if (s >= 0) return s;
				break;

			case 5:
				int LA17_9 = input.LA(1);


				int index17_9 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_9==IDENT)) {s = 172;}

				else if ((LA17_9==INTERNAL||LA17_9==PRIVATE||(LA17_9>=PROTECTED && LA17_9<=PUBLIC))) {s = 173;}

				else if ((LA17_9==STATIC)) {s = 174;}

				else if ((LA17_9==246)) {s = 175;}

				else if ((LA17_9==244)) {s = 176;}

				else if ((LA17_9==245)) {s = 177;}

				else if ((LA17_9==252)) {s = 178;}

				else if ((LA17_9==DYNAMIC)) {s = 179;}

				else if ((LA17_9==250)) {s = 180;}

				else if ((LA17_9==CONST||LA17_9==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 181;}

				else if ((LA17_9==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 182;}


				input.Seek(index17_9);
				if (s >= 0) return s;
				break;

			case 6:
				int LA17_10 = input.LA(1);


				int index17_10 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_10==IDENT)) {s = 183;}

				else if ((LA17_10==INTERNAL||LA17_10==PRIVATE||(LA17_10>=PROTECTED && LA17_10<=PUBLIC))) {s = 184;}

				else if ((LA17_10==STATIC)) {s = 185;}

				else if ((LA17_10==246)) {s = 186;}

				else if ((LA17_10==244)) {s = 187;}

				else if ((LA17_10==245)) {s = 188;}

				else if ((LA17_10==252)) {s = 189;}

				else if ((LA17_10==DYNAMIC)) {s = 190;}

				else if ((LA17_10==250)) {s = 191;}

				else if ((LA17_10==CONST||LA17_10==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 192;}

				else if ((LA17_10==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 193;}


				input.Seek(index17_10);
				if (s >= 0) return s;
				break;

			case 7:
				int LA17_11 = input.LA(1);


				int index17_11 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_11==IDENT)) {s = 194;}

				else if ((LA17_11==INTERNAL||LA17_11==PRIVATE||(LA17_11>=PROTECTED && LA17_11<=PUBLIC))) {s = 195;}

				else if ((LA17_11==STATIC)) {s = 196;}

				else if ((LA17_11==246)) {s = 197;}

				else if ((LA17_11==244)) {s = 198;}

				else if ((LA17_11==245)) {s = 199;}

				else if ((LA17_11==252)) {s = 200;}

				else if ((LA17_11==DYNAMIC)) {s = 201;}

				else if ((LA17_11==250)) {s = 202;}

				else if ((LA17_11==CONST||LA17_11==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 203;}

				else if ((LA17_11==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 204;}

				else if (((LA17_11>=AS && LA17_11<=ASSIGN)||(LA17_11>=BAND && LA17_11<=BAND_ASSIGN)||(LA17_11>=BOR && LA17_11<=BOR_ASSIGN)||(LA17_11>=BSR && LA17_11<=BXOR_ASSIGN)||LA17_11==COMMA||LA17_11==DEC||(LA17_11>=DIV && LA17_11<=DIV_ASSIGN)||LA17_11==DOT||LA17_11==E4X_DESC||LA17_11==EQUAL||LA17_11==GE||LA17_11==GT||LA17_11==INC||(LA17_11>=IS && LA17_11<=LBRACK)||LA17_11==LE||(LA17_11>=LOR && LA17_11<=LT)||(LA17_11>=MINUS && LA17_11<=MINUS_ASSIGN)||LA17_11==MOD||LA17_11==MOD_ASSIGN||LA17_11==NOT_EQUAL||(LA17_11>=PLUS && LA17_11<=PLUS_ASSIGN)||LA17_11==QUESTION||LA17_11==SEMI||(LA17_11>=SL && LA17_11<=SL_ASSIGN)||(LA17_11>=SR && LA17_11<=STAR_ASSIGN)||(LA17_11>=STRICT_EQUAL && LA17_11<=STRICT_NOT_EQUAL)||LA17_11==241||LA17_11==249||LA17_11==251)) {s = 15;}


				input.Seek(index17_11);
				if (s >= 0) return s;
				break;

			case 8:
				int LA17_12 = input.LA(1);


				int index17_12 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_12==IDENT)) {s = 225;}

				else if ((LA17_12==INTERNAL||LA17_12==PRIVATE||(LA17_12>=PROTECTED && LA17_12<=PUBLIC))) {s = 226;}

				else if ((LA17_12==STATIC)) {s = 227;}

				else if ((LA17_12==246)) {s = 228;}

				else if ((LA17_12==244)) {s = 229;}

				else if ((LA17_12==245)) {s = 230;}

				else if ((LA17_12==252)) {s = 231;}

				else if ((LA17_12==DYNAMIC)) {s = 232;}

				else if ((LA17_12==250)) {s = 233;}

				else if ((LA17_12==CONST||LA17_12==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((LA17_12==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 235;}


				input.Seek(index17_12);
				if (s >= 0) return s;
				break;

			case 9:
				int LA17_14 = input.LA(1);


				int index17_14 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA17_14==GET) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 246;}

				else if ((LA17_14==IDENT) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 247;}

				else if ((LA17_14==USE) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 248;}

				else if ((LA17_14==XML) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 249;}

				else if ((LA17_14==DYNAMIC) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 250;}

				else if ((LA17_14==NAMESPACE) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 251;}

				else if ((LA17_14==IS) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 252;}

				else if ((LA17_14==AS) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 253;}

				else if ((LA17_14==SET) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 254;}

				else if ((LA17_14==SUPER) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				else if ((LA17_14==LPAREN)) {s = 15;}


				input.Seek(index17_14);
				if (s >= 0) return s;
				break;

			case 10:
				int LA17_58 = input.LA(1);


				int index17_58 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_58);
				if (s >= 0) return s;
				break;

			case 11:
				int LA17_59 = input.LA(1);


				int index17_59 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_59);
				if (s >= 0) return s;
				break;

			case 12:
				int LA17_60 = input.LA(1);


				int index17_60 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_60);
				if (s >= 0) return s;
				break;

			case 13:
				int LA17_61 = input.LA(1);


				int index17_61 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_61);
				if (s >= 0) return s;
				break;

			case 14:
				int LA17_62 = input.LA(1);


				int index17_62 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_62);
				if (s >= 0) return s;
				break;

			case 15:
				int LA17_63 = input.LA(1);


				int index17_63 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_63);
				if (s >= 0) return s;
				break;

			case 16:
				int LA17_64 = input.LA(1);


				int index17_64 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_64);
				if (s >= 0) return s;
				break;

			case 17:
				int LA17_65 = input.LA(1);


				int index17_65 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_65);
				if (s >= 0) return s;
				break;

			case 18:
				int LA17_66 = input.LA(1);


				int index17_66 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_66);
				if (s >= 0) return s;
				break;

			case 19:
				int LA17_67 = input.LA(1);


				int index17_67 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}


				input.Seek(index17_67);
				if (s >= 0) return s;
				break;

			case 20:
				int LA17_95 = input.LA(1);


				int index17_95 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_95);
				if (s >= 0) return s;
				break;

			case 21:
				int LA17_96 = input.LA(1);


				int index17_96 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_96);
				if (s >= 0) return s;
				break;

			case 22:
				int LA17_97 = input.LA(1);


				int index17_97 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_97);
				if (s >= 0) return s;
				break;

			case 23:
				int LA17_98 = input.LA(1);


				int index17_98 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_98);
				if (s >= 0) return s;
				break;

			case 24:
				int LA17_99 = input.LA(1);


				int index17_99 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_99);
				if (s >= 0) return s;
				break;

			case 25:
				int LA17_100 = input.LA(1);


				int index17_100 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_100);
				if (s >= 0) return s;
				break;

			case 26:
				int LA17_101 = input.LA(1);


				int index17_101 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_101);
				if (s >= 0) return s;
				break;

			case 27:
				int LA17_102 = input.LA(1);


				int index17_102 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_102);
				if (s >= 0) return s;
				break;

			case 28:
				int LA17_103 = input.LA(1);


				int index17_103 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_103);
				if (s >= 0) return s;
				break;

			case 29:
				int LA17_127 = input.LA(1);


				int index17_127 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_127);
				if (s >= 0) return s;
				break;

			case 30:
				int LA17_128 = input.LA(1);


				int index17_128 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_128);
				if (s >= 0) return s;
				break;

			case 31:
				int LA17_129 = input.LA(1);


				int index17_129 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_129);
				if (s >= 0) return s;
				break;

			case 32:
				int LA17_130 = input.LA(1);


				int index17_130 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_130);
				if (s >= 0) return s;
				break;

			case 33:
				int LA17_131 = input.LA(1);


				int index17_131 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_131);
				if (s >= 0) return s;
				break;

			case 34:
				int LA17_132 = input.LA(1);


				int index17_132 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_132);
				if (s >= 0) return s;
				break;

			case 35:
				int LA17_133 = input.LA(1);


				int index17_133 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_133);
				if (s >= 0) return s;
				break;

			case 36:
				int LA17_134 = input.LA(1);


				int index17_134 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_134);
				if (s >= 0) return s;
				break;

			case 37:
				int LA17_135 = input.LA(1);


				int index17_135 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_135);
				if (s >= 0) return s;
				break;

			case 38:
				int LA17_139 = input.LA(1);


				int index17_139 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_139);
				if (s >= 0) return s;
				break;

			case 39:
				int LA17_140 = input.LA(1);


				int index17_140 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_140);
				if (s >= 0) return s;
				break;

			case 40:
				int LA17_141 = input.LA(1);


				int index17_141 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_141);
				if (s >= 0) return s;
				break;

			case 41:
				int LA17_142 = input.LA(1);


				int index17_142 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_142);
				if (s >= 0) return s;
				break;

			case 42:
				int LA17_143 = input.LA(1);


				int index17_143 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_143);
				if (s >= 0) return s;
				break;

			case 43:
				int LA17_144 = input.LA(1);


				int index17_144 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_144);
				if (s >= 0) return s;
				break;

			case 44:
				int LA17_145 = input.LA(1);


				int index17_145 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_145);
				if (s >= 0) return s;
				break;

			case 45:
				int LA17_146 = input.LA(1);


				int index17_146 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_146);
				if (s >= 0) return s;
				break;

			case 46:
				int LA17_147 = input.LA(1);


				int index17_147 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_147);
				if (s >= 0) return s;
				break;

			case 47:
				int LA17_150 = input.LA(1);


				int index17_150 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_150);
				if (s >= 0) return s;
				break;

			case 48:
				int LA17_151 = input.LA(1);


				int index17_151 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_151);
				if (s >= 0) return s;
				break;

			case 49:
				int LA17_152 = input.LA(1);


				int index17_152 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_152);
				if (s >= 0) return s;
				break;

			case 50:
				int LA17_153 = input.LA(1);


				int index17_153 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_153);
				if (s >= 0) return s;
				break;

			case 51:
				int LA17_154 = input.LA(1);


				int index17_154 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_154);
				if (s >= 0) return s;
				break;

			case 52:
				int LA17_155 = input.LA(1);


				int index17_155 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_155);
				if (s >= 0) return s;
				break;

			case 53:
				int LA17_156 = input.LA(1);


				int index17_156 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_156);
				if (s >= 0) return s;
				break;

			case 54:
				int LA17_157 = input.LA(1);


				int index17_157 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_157);
				if (s >= 0) return s;
				break;

			case 55:
				int LA17_158 = input.LA(1);


				int index17_158 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_158);
				if (s >= 0) return s;
				break;

			case 56:
				int LA17_161 = input.LA(1);


				int index17_161 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_161);
				if (s >= 0) return s;
				break;

			case 57:
				int LA17_162 = input.LA(1);


				int index17_162 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_162);
				if (s >= 0) return s;
				break;

			case 58:
				int LA17_163 = input.LA(1);


				int index17_163 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_163);
				if (s >= 0) return s;
				break;

			case 59:
				int LA17_164 = input.LA(1);


				int index17_164 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_164);
				if (s >= 0) return s;
				break;

			case 60:
				int LA17_165 = input.LA(1);


				int index17_165 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_165);
				if (s >= 0) return s;
				break;

			case 61:
				int LA17_166 = input.LA(1);


				int index17_166 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_166);
				if (s >= 0) return s;
				break;

			case 62:
				int LA17_167 = input.LA(1);


				int index17_167 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_167);
				if (s >= 0) return s;
				break;

			case 63:
				int LA17_168 = input.LA(1);


				int index17_168 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_168);
				if (s >= 0) return s;
				break;

			case 64:
				int LA17_169 = input.LA(1);


				int index17_169 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_169);
				if (s >= 0) return s;
				break;

			case 65:
				int LA17_172 = input.LA(1);


				int index17_172 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_172);
				if (s >= 0) return s;
				break;

			case 66:
				int LA17_173 = input.LA(1);


				int index17_173 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_173);
				if (s >= 0) return s;
				break;

			case 67:
				int LA17_174 = input.LA(1);


				int index17_174 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_174);
				if (s >= 0) return s;
				break;

			case 68:
				int LA17_175 = input.LA(1);


				int index17_175 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_175);
				if (s >= 0) return s;
				break;

			case 69:
				int LA17_176 = input.LA(1);


				int index17_176 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_176);
				if (s >= 0) return s;
				break;

			case 70:
				int LA17_177 = input.LA(1);


				int index17_177 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_177);
				if (s >= 0) return s;
				break;

			case 71:
				int LA17_178 = input.LA(1);


				int index17_178 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_178);
				if (s >= 0) return s;
				break;

			case 72:
				int LA17_179 = input.LA(1);


				int index17_179 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_179);
				if (s >= 0) return s;
				break;

			case 73:
				int LA17_180 = input.LA(1);


				int index17_180 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_180);
				if (s >= 0) return s;
				break;

			case 74:
				int LA17_183 = input.LA(1);


				int index17_183 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_183);
				if (s >= 0) return s;
				break;

			case 75:
				int LA17_184 = input.LA(1);


				int index17_184 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_184);
				if (s >= 0) return s;
				break;

			case 76:
				int LA17_185 = input.LA(1);


				int index17_185 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_185);
				if (s >= 0) return s;
				break;

			case 77:
				int LA17_186 = input.LA(1);


				int index17_186 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_186);
				if (s >= 0) return s;
				break;

			case 78:
				int LA17_187 = input.LA(1);


				int index17_187 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_187);
				if (s >= 0) return s;
				break;

			case 79:
				int LA17_188 = input.LA(1);


				int index17_188 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_188);
				if (s >= 0) return s;
				break;

			case 80:
				int LA17_189 = input.LA(1);


				int index17_189 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_189);
				if (s >= 0) return s;
				break;

			case 81:
				int LA17_190 = input.LA(1);


				int index17_190 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_190);
				if (s >= 0) return s;
				break;

			case 82:
				int LA17_191 = input.LA(1);


				int index17_191 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_191);
				if (s >= 0) return s;
				break;

			case 83:
				int LA17_194 = input.LA(1);


				int index17_194 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_194);
				if (s >= 0) return s;
				break;

			case 84:
				int LA17_195 = input.LA(1);


				int index17_195 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_195);
				if (s >= 0) return s;
				break;

			case 85:
				int LA17_196 = input.LA(1);


				int index17_196 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_196);
				if (s >= 0) return s;
				break;

			case 86:
				int LA17_197 = input.LA(1);


				int index17_197 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_197);
				if (s >= 0) return s;
				break;

			case 87:
				int LA17_198 = input.LA(1);


				int index17_198 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_198);
				if (s >= 0) return s;
				break;

			case 88:
				int LA17_199 = input.LA(1);


				int index17_199 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_199);
				if (s >= 0) return s;
				break;

			case 89:
				int LA17_200 = input.LA(1);


				int index17_200 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_200);
				if (s >= 0) return s;
				break;

			case 90:
				int LA17_201 = input.LA(1);


				int index17_201 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_201);
				if (s >= 0) return s;
				break;

			case 91:
				int LA17_202 = input.LA(1);


				int index17_202 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_202);
				if (s >= 0) return s;
				break;

			case 92:
				int LA17_225 = input.LA(1);


				int index17_225 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_225);
				if (s >= 0) return s;
				break;

			case 93:
				int LA17_226 = input.LA(1);


				int index17_226 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_226);
				if (s >= 0) return s;
				break;

			case 94:
				int LA17_227 = input.LA(1);


				int index17_227 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_227);
				if (s >= 0) return s;
				break;

			case 95:
				int LA17_228 = input.LA(1);


				int index17_228 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_228);
				if (s >= 0) return s;
				break;

			case 96:
				int LA17_229 = input.LA(1);


				int index17_229 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_229);
				if (s >= 0) return s;
				break;

			case 97:
				int LA17_230 = input.LA(1);


				int index17_230 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_230);
				if (s >= 0) return s;
				break;

			case 98:
				int LA17_231 = input.LA(1);


				int index17_231 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_231);
				if (s >= 0) return s;
				break;

			case 99:
				int LA17_232 = input.LA(1);


				int index17_232 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_232);
				if (s >= 0) return s;
				break;

			case 100:
				int LA17_233 = input.LA(1);


				int index17_233 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}


				input.Seek(index17_233);
				if (s >= 0) return s;
				break;

			case 101:
				int LA17_236 = input.LA(1);


				int index17_236 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_236);
				if (s >= 0) return s;
				break;

			case 102:
				int LA17_237 = input.LA(1);


				int index17_237 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_237);
				if (s >= 0) return s;
				break;

			case 103:
				int LA17_238 = input.LA(1);


				int index17_238 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_238);
				if (s >= 0) return s;
				break;

			case 104:
				int LA17_239 = input.LA(1);


				int index17_239 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_239);
				if (s >= 0) return s;
				break;

			case 105:
				int LA17_240 = input.LA(1);


				int index17_240 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_240);
				if (s >= 0) return s;
				break;

			case 106:
				int LA17_241 = input.LA(1);


				int index17_241 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_241);
				if (s >= 0) return s;
				break;

			case 107:
				int LA17_242 = input.LA(1);


				int index17_242 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_242);
				if (s >= 0) return s;
				break;

			case 108:
				int LA17_243 = input.LA(1);


				int index17_243 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_243);
				if (s >= 0) return s;
				break;

			case 109:
				int LA17_244 = input.LA(1);


				int index17_244 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_244);
				if (s >= 0) return s;
				break;

			case 110:
				int LA17_245 = input.LA(1);


				int index17_245 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}


				input.Seek(index17_245);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 17, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA20 : DFA
	{
		private const string DFA20_eotS =
			"\x3F\xFFFF";
		private const string DFA20_eofS =
			"\x1\x2\x3E\xFFFF";
		private const string DFA20_minS =
			"\x1\xF\x1\x0\x3D\xFFFF";
		private const string DFA20_maxS =
			"\x1\x101\x1\x0\x3D\xFFFF";
		private const string DFA20_acceptS =
			"\x2\xFFFF\x1\x2\x3B\xFFFF\x1\x1";
		private const string DFA20_specialS =
			"\x1\xFFFF\x1\x0\x3D\xFFFF}>";
		private static readonly string[] DFA20_transitionS =
			{
				"\x1\x2\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x8\xFFFF\x1\x2\x7\xFFFF\x1\x2\x1"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x2"+
				"\x2\x11\xFFFF\x3\x2\x8\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x2"+
				"\x2\x2\xFFFF\x1\x2\x1\x1\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x7\xFFFF\x1\x2"+
				"\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x3\xFFFF\x1\x2\x8\xFFFF"+
				"\x1\x2\x6\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x2\x9\xFFFF\x1\x2\x2\xFFFF\x4\x2\x5\xFFFF\x1"+
				"\x2\x6\xFFFF\x2\x2\x6\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x2\x5\xFFFF\x4\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x6\x2",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA20_eot = DFA.UnpackEncodedString(DFA20_eotS);
		private static readonly short[] DFA20_eof = DFA.UnpackEncodedString(DFA20_eofS);
		private static readonly char[] DFA20_min = DFA.UnpackEncodedStringToUnsignedChars(DFA20_minS);
		private static readonly char[] DFA20_max = DFA.UnpackEncodedStringToUnsignedChars(DFA20_maxS);
		private static readonly short[] DFA20_accept = DFA.UnpackEncodedString(DFA20_acceptS);
		private static readonly short[] DFA20_special = DFA.UnpackEncodedString(DFA20_specialS);
		private static readonly short[][] DFA20_transition;

		static DFA20()
		{
			int numStates = DFA20_transitionS.Length;
			DFA20_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA20_transition[i] = DFA.UnpackEncodedString(DFA20_transitionS[i]);
			}
		}

		public DFA20( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 20;
			this.eot = DFA20_eot;
			this.eof = DFA20_eof;
			this.min = DFA20_min;
			this.max = DFA20_max;
			this.accept = DFA20_accept;
			this.special = DFA20_special;
			this.transition = DFA20_transition;
		}

		public override string Description { get { return "265:1: maybeBlock options {k=1; } : ( ( LCURLY )=> block |);"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition20(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA20_1 = input.LA(1);


				int index20_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred12_AS3_fragment))) {s = 62;}

				else if ((true)) {s = 2;}


				input.Seek(index20_1);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 20, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA43 : DFA
	{
		private const string DFA43_eotS =
			"\x3C\xFFFF";
		private const string DFA43_eofS =
			"\x3C\xFFFF";
		private const string DFA43_minS =
			"\xC\xF\x1\xFFFF\xA\x10\x1\xFFFF\x1\xF\xC\x10\x1\xF\x1\x10\x1\x2F\x9\x10"+
			"\x1\xF\xA\x10";
		private const string DFA43_maxS =
			"\x1\x101\x1\xE7\xA\xFB\x1\xFFFF\xA\xBD\x1\xFFFF\x1\x101\xC\xBD\x1\xE7"+
			"\x1\xBD\x1\x2F\x9\xBD\x1\xE7\xA\xBD";
		private const string DFA43_acceptS =
			"\xC\xFFFF\x1\x2\xA\xFFFF\x1\x1\x24\xFFFF";
		private const string DFA43_specialS =
			"\x3C\xFFFF}>";
		private static readonly string[] DFA43_transitionS =
			{
				"\x1\x8\x5\xFFFF\x1\xC\x14\xFFFF\x1\x1\x5\xFFFF\x2\xC\xA\xFFFF\x1\x5"+
				"\x1\xC\x11\xFFFF\x2\xC\x9\xFFFF\x1\xC\x3\xFFFF\x1\x9\x2\xFFFF\x1\xC"+
				"\x1\x2\x9\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\x7\x2\xFFFF\x2\xC\x7\xFFFF\x1"+
				"\xC\x2\xFFFF\x1\xC\x7\xFFFF\x1\xC\x7\xFFFF\x1\x6\x2\xFFFF\x1\xC\x4\xFFFF"+
				"\x1\xC\x3\xFFFF\x1\xC\x8\xFFFF\x1\xC\x6\xFFFF\x1\xC\x2\xFFFF\x2\xC\x6"+
				"\xFFFF\x1\xC\x5\xFFFF\x1\xC\x1\xA\xC\xFFFF\x2\xC\x1\xB\x6\xFFFF\x1\xC"+
				"\x6\xFFFF\x1\x3\x1\x1\xA\xFFFF\x1\x4\x5\xFFFF\x1\xC\x5\xFFFF\x1\xC\xB"+
				"\xFFFF\x3\xC",
				"\x1\x13\x2C\xFFFF\x1\x10\x21\xFFFF\x1\x14\x3\xFFFF\x1\xD\xE\xFFFF\x1"+
				"\x12\x1E\xFFFF\x1\x11\x2D\xFFFF\x1\x15\xE\xFFFF\x1\x16\xD\xFFFF\x1\xE"+
				"\xB\xFFFF\x1\xF",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x7\xFFFF\x2\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC"+
				"\x8\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF"+
				"\x4\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2"+
				"\xFFFF\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1"+
				"\xC\x1\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7"+
				"\xFFFF\x1\xC\x1\xFFFF\x1\xC",
				"",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"",
				"\x1\x1F\x2C\xFFFF\x1\x1C\x21\xFFFF\x1\x20\x3\xFFFF\x1\x19\xE\xFFFF"+
				"\x1\x1E\x1E\xFFFF\x1\x1D\x2D\xFFFF\x1\x21\x5\xFFFF\x1\x24\x8\xFFFF\x1"+
				"\x22\xD\xFFFF\x1\x1A\xB\xFFFF\x1\x1B\x19\xFFFF\x1\x23",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\x2D\x2C\xFFFF\x1\x2A\x21\xFFFF\x1\x2E\x3\xFFFF\x1\x26\xD\xFFFF"+
				"\x1\x27\x1\x2C\x1E\xFFFF\x1\x2B\x1B\xFFFF\x1\x27\x2\xFFFF\x2\x27\xD"+
				"\xFFFF\x1\x2F\xE\xFFFF\x1\x30\xD\xFFFF\x1\x28\xB\xFFFF\x1\x29",
				"\x1\xC\x16\xFFFF\x1\xC\x7\xFFFF\x1\x31\x9\xFFFF\x1\x25\x31\xFFFF\x1"+
				"\x17\x51\xFFFF\x1\xC",
				"\x1\x31",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\x38\x2C\xFFFF\x1\x35\x21\xFFFF\x1\x39\x3\xFFFF\x1\x32\xE\xFFFF"+
				"\x1\x37\x1E\xFFFF\x1\x36\x2D\xFFFF\x1\x3A\xE\xFFFF\x1\x3B\xD\xFFFF\x1"+
				"\x33\xB\xFFFF\x1\x34",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF"+
				"\x1\xC"
			};

		private static readonly short[] DFA43_eot = DFA.UnpackEncodedString(DFA43_eotS);
		private static readonly short[] DFA43_eof = DFA.UnpackEncodedString(DFA43_eofS);
		private static readonly char[] DFA43_min = DFA.UnpackEncodedStringToUnsignedChars(DFA43_minS);
		private static readonly char[] DFA43_max = DFA.UnpackEncodedStringToUnsignedChars(DFA43_maxS);
		private static readonly short[] DFA43_accept = DFA.UnpackEncodedString(DFA43_acceptS);
		private static readonly short[] DFA43_special = DFA.UnpackEncodedString(DFA43_specialS);
		private static readonly short[][] DFA43_transition;

		static DFA43()
		{
			int numStates = DFA43_transitionS.Length;
			DFA43_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA43_transition[i] = DFA.UnpackEncodedString(DFA43_transitionS[i]);
			}
		}

		public DFA43( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 43;
			this.eot = DFA43_eot;
			this.eof = DFA43_eof;
			this.min = DFA43_min;
			this.max = DFA43_max;
			this.accept = DFA43_accept;
			this.special = DFA43_special;
			this.transition = DFA43_transition;
		}

		public override string Description { get { return "499:3: ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _as2CompilationUnit_in_compilationUnit465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as3CompilationUnit_in_compilationUnit471 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_as2CompilationUnit498 = new BitSet(new ulong[]{0x1000000400000000UL,0x1620400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _as2Type_in_as2CompilationUnit503 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2IncludeDirective_in_as2Type518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2ClassDefinition_in_as2Type531 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2InterfaceDefinition_in_as2Type544 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _packageDecl_in_as3CompilationUnit558 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6481902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _packageBlockEntry_in_as3CompilationUnit562 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6481902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _EOF_in_as3CompilationUnit567 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PACKAGE_in_packageDecl579 = new BitSet(new ulong[]{0x1000000000008000UL,0x22000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _identifierStar_in_packageDecl581 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LCURLY_in_packageDecl586 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _packageBlockEntry_in_packageDecl597 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _RCURLY_in_packageDecl602 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_packageBlockEntry645 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _includeDirective_in_packageBlockEntry653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _useNamespaceDirective_in_packageBlockEntry661 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_packageBlockEntry677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespaceDefinition_in_packageBlockEntry693 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDefinition_in_packageBlockEntry715 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDefinition_in_packageBlockEntry731 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDefinition_in_packageBlockEntry747 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDefinition_in_packageBlockEntry763 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_packageBlockEntry777 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_endOfFile790 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_importDefinition802 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _identifierStar_in_importDefinition804 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_importDefinition808 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMI_in_semi841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_classDefinition853 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_classDefinition857 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_classDefinition868 = new BitSet(new ulong[]{0x0UL,0x20008000002000UL});
		public static readonly BitSet _classExtendsClause_in_classDefinition872 = new BitSet(new ulong[]{0x0UL,0x20008000000000UL});
		public static readonly BitSet _implementsClause_in_classDefinition877 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_classDefinition882 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_as2ClassDefinition919 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_as2ClassDefinition923 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_as2ClassDefinition925 = new BitSet(new ulong[]{0x0UL,0x20008000002000UL});
		public static readonly BitSet _classExtendsClause_in_as2ClassDefinition929 = new BitSet(new ulong[]{0x0UL,0x20008000000000UL});
		public static readonly BitSet _implementsClause_in_as2ClassDefinition934 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_as2ClassDefinition939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_interfaceDefinition970 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_interfaceDefinition974 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_interfaceDefinition976 = new BitSet(new ulong[]{0x0UL,0x20000000002000UL});
		public static readonly BitSet _interfaceExtendsClause_in_interfaceDefinition980 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_interfaceDefinition985 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_as2InterfaceDefinition1015 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_as2InterfaceDefinition1019 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_as2InterfaceDefinition1021 = new BitSet(new ulong[]{0x0UL,0x20000000002000UL});
		public static readonly BitSet _interfaceExtendsClause_in_as2InterfaceDefinition1025 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_as2InterfaceDefinition1030 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_classExtendsClause1058 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_classExtendsClause1060 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_interfaceExtendsClause1089 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_interfaceExtendsClause1091 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_interfaceExtendsClause1095 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_interfaceExtendsClause1097 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _IMPLEMENTS_in_implementsClause1129 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_implementsClause1131 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_implementsClause1135 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_implementsClause1137 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _LCURLY_in_typeBlock1169 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033122644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _typeBlockEntry_in_typeBlock1179 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033122644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _RCURLY_in_typeBlock1184 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _includeDirective_in_typeBlockEntry1226 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_typeBlockEntry1231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_typeBlockEntry1244 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDefinition_in_typeBlockEntry1258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDefinition_in_typeBlockEntry1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_typeBlockEntry1292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INCLUDE_DIRECTIVE_in_as2IncludeDirective1303 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x1800UL});
		public static readonly BitSet _stringLiteral_in_as2IncludeDirective1307 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _248_in_includeDirective1318 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x1800UL});
		public static readonly BitSet _stringLiteral_in_includeDirective1320 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_includeDirective1324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_methodDefinition1358 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_methodDefinition1362 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _accessorRole_in_methodDefinition1372 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _methodName_in_methodDefinition1377 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _parameterDeclarationList_in_methodDefinition1381 = new BitSet(new ulong[]{0x4000000000UL,0x20000000000000UL});
		public static readonly BitSet _typeExpression_in_methodDefinition1385 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _maybeBlock_in_methodDefinition1396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_maybeBlock1490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_methodName1516 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_namespaceDefinition1562 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_namespaceDefinition1564 = new BitSet(new ulong[]{0x0UL,0x1000400000000UL,0x1900000000000UL});
		public static readonly BitSet _namespaceName_in_namespaceDefinition1566 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_useNamespaceDirective1591 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_useNamespaceDirective1593 = new BitSet(new ulong[]{0x0UL,0x1000400000000UL,0x1900000000000UL});
		public static readonly BitSet _namespaceName_in_useNamespaceDirective1595 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_useNamespaceDirective1597 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_variableDefinition1608 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_variableDefinition1614 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_variableDefinition1616 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _COMMA_in_variableDefinition1621 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_variableDefinition1623 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_variableDefinition1631 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varOrConst_in_declaration1660 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_declaration1662 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _declarationTail_in_declaration1664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_declarationTail1711 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_declarationTail1713 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _ASSIGN_in_variableInitializer1726 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_variableInitializer1728 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_variableDeclarator1757 = new BitSet(new ulong[]{0x4000010002UL});
		public static readonly BitSet _typeExpression_in_variableDeclarator1759 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _variableInitializer_in_variableDeclarator1762 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parameterDeclarationList1799 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x5200000000010000UL,0x8008002000UL});
		public static readonly BitSet _parameterDeclaration_in_parameterDeclarationList1805 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _COMMA_in_parameterDeclarationList1811 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x4200000000010000UL,0x8008002000UL});
		public static readonly BitSet _parameterDeclaration_in_parameterDeclarationList1813 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_parameterDeclarationList1824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _basicParameterDeclaration_in_parameterDeclaration1851 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameterRestDeclaration_in_parameterDeclaration1855 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONST_in_basicParameterDeclaration1866 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_basicParameterDeclaration1869 = new BitSet(new ulong[]{0x4000010002UL});
		public static readonly BitSet _typeExpression_in_basicParameterDeclaration1871 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _parameterDefault_in_basicParameterDeclaration1874 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_parameterDefault1908 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_parameterDefault1910 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REST_in_parameterRestDeclaration1921 = new BitSet(new ulong[]{0x1000004000008002UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_parameterRestDeclaration1923 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _typeExpression_in_parameterRestDeclaration1926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_block1953 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6491902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _blockEntry_in_block1955 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6491902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _RCURLY_in_block1958 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_blockEntry1984 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_condition1995 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_condition1997 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_condition1999 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement2026 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declarationStatement_in_statement2032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statement2039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement2045 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forEachStatement_in_statement2051 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement2057 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doWhileStatement_in_statement2063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statement2070 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statement2077 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statement2084 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statement2090 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statement2096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statement2102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statement2109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _defaultXMLNamespaceStatement_in_statement2116 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _semi_in_statement2131 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declarationStatement2147 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_declarationStatement2151 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_expressionStatement2178 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_expressionStatement2182 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement2206 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_ifStatement2208 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_ifStatement2210 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _elseClause_in_ifStatement2219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elseClause2255 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_elseClause2257 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _253_in_throwStatement2287 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_throwStatement2289 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_throwStatement2293 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _254_in_tryStatement2324 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_tryStatement2328 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x84000000000000UL});
		public static readonly BitSet _catchBlock_in_tryStatement2332 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x84000000000000UL});
		public static readonly BitSet _finallyBlock_in_tryStatement2337 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _242_in_catchBlock2373 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_catchBlock2375 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_catchBlock2377 = new BitSet(new ulong[]{0x4000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _typeExpression_in_catchBlock2379 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_catchBlock2382 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_catchBlock2386 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _247_in_finallyBlock2397 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_finallyBlock2399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnStatement2410 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_returnStatement2412 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_returnStatement2417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continueStatement2451 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_continueStatement2455 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_breakStatement2484 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_breakStatement2488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchStatement2517 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_switchStatement2519 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _switchBlock_in_switchStatement2523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_switchBlock2554 = new BitSet(new ulong[]{0x10000100000000UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _caseStatement_in_switchBlock2559 = new BitSet(new ulong[]{0x10000100000000UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _defaultStatement_in_switchBlock2566 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _RCURLY_in_switchBlock2572 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseStatement2597 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_caseStatement2599 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_caseStatement2601 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _switchStatementList_in_caseStatement2606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFAULT_in_defaultStatement2619 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_defaultStatement2621 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _switchStatementList_in_defaultStatement2626 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_switchStatementList2638 = new BitSet(new ulong[]{0x3113140002208002UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _FOR_in_forEachStatement2661 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _EACH_in_forEachStatement2663 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_forEachStatement2667 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8018002000UL});
		public static readonly BitSet _forInClause_in_forEachStatement2671 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forEachStatement2675 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forEachStatement2679 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement2706 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_forStatement2710 = new BitSet(new ulong[]{0x3003040000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208018103800UL,0x3UL});
		public static readonly BitSet _forInClause_in_forStatement2716 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forStatement2718 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forStatement2720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _traditionalForClause_in_forStatement2746 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forStatement2748 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forStatement2750 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInit_in_traditionalForClause2784 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_traditionalForClause2787 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forCond_in_traditionalForClause2792 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_traditionalForClause2795 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forIter_in_traditionalForClause2800 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInClauseDecl_in_forInClause2814 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _IN_in_forInClause2816 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forInClauseTail_in_forInClause2818 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varOrConst_in_forInClauseDecl2829 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_forInClauseDecl2831 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _typeExpression_in_forInClauseDecl2833 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_forInClauseDecl2847 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forInClauseTail2859 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_forInit2873 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forInit2877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forCond2905 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forIter2928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement2951 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_whileStatement2953 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_whileStatement2955 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_doWhileStatement2978 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_doWhileStatement2980 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x800000000UL});
		public static readonly BitSet _WHILE_in_doWhileStatement2982 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_doWhileStatement2984 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_doWhileStatement2986 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withStatement3014 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_withStatement3016 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_withStatement3018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFAULT_in_defaultXMLNamespaceStatement3029 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x8000000000UL});
		public static readonly BitSet _XML_in_defaultXMLNamespaceStatement3031 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_defaultXMLNamespaceStatement3033 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ASSIGN_in_defaultXMLNamespaceStatement3035 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_defaultXMLNamespaceStatement3037 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_defaultXMLNamespaceStatement3039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_typeExpression3064 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002010UL,0x2UL});
		public static readonly BitSet _typeIdentifier_in_typeExpression3067 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _257_in_typeExpression3071 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_typeExpression3075 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_typeIdentifier3116 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _propOrIdent_in_typeIdentifier3119 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _qualifiedIdent_in_identifier3137 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _propOrIdent_in_identifier3145 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _namespaceName_in_qualifiedIdent3185 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _DBL_COLON_in_qualifiedIdent3187 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_qualifiedIdent3189 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_qualifiedIdent3221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_namespaceName3235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _reservedNamespace_in_namespaceName3239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_identifierStar3276 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _dotIdent_in_identifierStar3280 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _DOT_in_identifierStar3286 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x10UL});
		public static readonly BitSet _STAR_in_identifierStar3288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_dotIdent3323 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_dotIdent3325 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_ident3340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_ident3353 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _XML_in_ident3358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DYNAMIC_in_ident3363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAMESPACE_in_ident3368 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IS_in_ident3373 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_ident3378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GET_in_ident3383 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_ident3388 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUPER_in_ident3393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_annotation3404 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_annotation3408 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000001UL});
		public static readonly BitSet _annotationParamList_in_annotation3412 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_annotation3417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_annotationParamList3443 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640018000UL,0x5080000011010000UL,0x208008103800UL});
		public static readonly BitSet _annotationParam_in_annotationParamList3449 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _COMMA_in_annotationParamList3455 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640018000UL,0x4080000011010000UL,0x208008103800UL});
		public static readonly BitSet _annotationParam_in_annotationParamList3457 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_annotationParamList3468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_annotationParam3495 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ASSIGN_in_annotationParam3497 = new BitSet(new ulong[]{0x2000000000000UL,0x200018000UL,0x80000011000000UL,0x200000101800UL});
		public static readonly BitSet _constant_in_annotationParam3499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_annotationParam3514 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_annotationParam3523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifier_in_modifiers3541 = new BitSet(new ulong[]{0x1000000000000002UL,0x1000400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _modifier_in_modifiers3544 = new BitSet(new ulong[]{0x1000000000000002UL,0x1000400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _namespaceName_in_modifier3570 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATIC_in_modifier3575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _246_in_modifier3580 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _244_in_modifier3585 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _245_in_modifier3590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _252_in_modifier3595 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DYNAMIC_in_modifier3600 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _250_in_modifier3605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments3616 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expressionList_in_arguments3618 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_arguments3620 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments3640 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_arguments3642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_arrayLiteral3665 = new BitSet(new ulong[]{0x3003008000208000UL,0x2033100644018000UL,0x4089902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _elementList_in_arrayLiteral3667 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_arrayLiteral3670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_elementList3698 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonemptyElementList_in_elementList3704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_nonemptyElementList3714 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_nonemptyElementList3717 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_nonemptyElementList3720 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _assignmentExpression_in_element3733 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_objectLiteral3755 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640010000UL,0x4010000010010000UL,0x8008002000UL});
		public static readonly BitSet _fieldList_in_objectLiteral3757 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _RCURLY_in_objectLiteral3760 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literalField_in_fieldList3783 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_fieldList3786 = new BitSet(new ulong[]{0x1002008000008002UL,0x2000640010000UL,0x4000000010010000UL,0x8008002000UL});
		public static readonly BitSet _literalField_in_fieldList3789 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _fieldName_in_literalField3806 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_literalField3808 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _element_in_literalField3810 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_fieldName3834 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_fieldName3839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression3851 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expressionList3879 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_expressionList3882 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_expressionList3884 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression3915 = new BitSet(new ulong[]{0x800000A1090002UL,0x8008000000000000UL,0x4000004200UL,0x29UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression3924 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression3926 = new BitSet(new ulong[]{0x800000A1090002UL,0x8008000000000000UL,0x4000004200UL,0x29UL});
		public static readonly BitSet _logicalOrExpression_in_conditionalExpression4019 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4000000000000UL});
		public static readonly BitSet _QUESTION_in_conditionalExpression4033 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _conditionalSubExpression_in_conditionalExpression4038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_conditionalSubExpression4067 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_conditionalSubExpression4069 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_conditionalSubExpression4071 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression4085 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL,0x0UL,0x800000000000000UL});
		public static readonly BitSet _logicalOrOperator_in_logicalOrExpression4090 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression4092 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL,0x0UL,0x800000000000000UL});
		public static readonly BitSet _bitwiseOrExpression_in_logicalAndExpression4121 = new BitSet(new ulong[]{0x2UL,0x4000000000000UL,0x0UL,0x2000000000000UL});
		public static readonly BitSet _logicalAndOperator_in_logicalAndExpression4126 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseOrExpression_in_logicalAndExpression4128 = new BitSet(new ulong[]{0x2UL,0x4000000000000UL,0x0UL,0x2000000000000UL});
		public static readonly BitSet _bitwiseXorExpression_in_bitwiseOrExpression4157 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _BOR_in_bitwiseOrExpression4162 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseXorExpression_in_bitwiseOrExpression4164 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXorExpression4178 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _BXOR_in_bitwiseXorExpression4183 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXorExpression4185 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression4199 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _BAND_in_bitwiseAndExpression4204 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression4206 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4220 = new BitSet(new ulong[]{0x2UL,0x40UL,0x800000UL,0x600UL});
		public static readonly BitSet _equalityOperator_in_equalityExpression4231 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4233 = new BitSet(new ulong[]{0x2UL,0x40UL,0x800000UL,0x600UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4271 = new BitSet(new ulong[]{0x8002UL,0x420000A0000000UL,0x2UL,0x200000000000000UL});
		public static readonly BitSet _relationalOperator_in_relationalExpression4274 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4276 = new BitSet(new ulong[]{0x8002UL,0x420000A0000000UL,0x2UL,0x200000000000000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression4326 = new BitSet(new ulong[]{0x10000002UL,0x0UL,0x8000000000000000UL,0x4UL});
		public static readonly BitSet _shiftOperator_in_shiftExpression4331 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression4333 = new BitSet(new ulong[]{0x10000002UL,0x0UL,0x8000000000000000UL,0x4UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression4366 = new BitSet(new ulong[]{0x2UL,0x0UL,0x2000000100UL});
		public static readonly BitSet _additiveOperator_in_additiveExpression4369 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression4371 = new BitSet(new ulong[]{0x2UL,0x0UL,0x2000000100UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4400 = new BitSet(new ulong[]{0x40000000000002UL,0x0UL,0x800UL,0x10UL});
		public static readonly BitSet _multiplicativeOperator_in_multiplicativeExpression4406 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4411 = new BitSet(new ulong[]{0x40000000000002UL,0x0UL,0x800UL,0x10UL});
		public static readonly BitSet _INC_in_unaryExpression4449 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4451 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_unaryExpression4458 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_unaryExpression4465 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryExpression4472 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpressionNotPlusMinus_in_unaryExpression4479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _243_in_unaryExpressionNotPlusMinus4490 = new BitSet(new ulong[]{0x3002000000008000UL,0x33000644018000UL,0x4081900011090001UL,0x208008103800UL,0x1UL});
		public static readonly BitSet _postfixExpression_in_unaryExpressionNotPlusMinus4492 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _257_in_unaryExpressionNotPlusMinus4505 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4507 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _255_in_unaryExpressionNotPlusMinus4520 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4522 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LNOT_in_unaryExpressionNotPlusMinus4535 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BNOT_in_unaryExpressionNotPlusMinus4550 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4552 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpressionNotPlusMinus4565 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_postfixExpression4579 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _propOrIdent_in_postfixExpression4603 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _DOT_in_postfixExpression4658 = new BitSet(new ulong[]{0x2000000000000000UL,0x0UL,0x1UL,0x10UL});
		public static readonly BitSet _e4xExpression_in_postfixExpression4660 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _E4X_DESC_in_postfixExpression4703 = new BitSet(new ulong[]{0x2000000000000000UL,0x0UL,0x1UL,0x10UL});
		public static readonly BitSet _e4xExpression_in_postfixExpression4705 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _LBRACK_in_postfixExpression4762 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_postfixExpression4764 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_postfixExpression4766 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _arguments_in_postfixExpression4817 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _INC_in_postfixExpression4861 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_postfixExpression4879 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_e4xExpression4908 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xAttributeIdentifier_in_e4xExpression4913 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xFilterPredicate_in_e4xExpression4918 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _E4X_ATTRI_in_e4xAttributeIdentifier4929 = new BitSet(new ulong[]{0x1000000000008000UL,0x13000440000000UL,0x4001900000010000UL,0x8008002010UL});
		public static readonly BitSet _qualifiedIdent_in_e4xAttributeIdentifier4935 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_e4xAttributeIdentifier4941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_e4xAttributeIdentifier4947 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_e4xAttributeIdentifier4949 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_e4xAttributeIdentifier4951 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_e4xFilterPredicate4966 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_e4xFilterPredicate4971 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_e4xFilterPredicate4975 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _256_in_primaryExpression4987 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primaryExpression4992 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression5013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression5018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDefinition_in_primaryExpression5023 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_primaryExpression5028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _encapsulatedExpression_in_primaryExpression5033 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xAttributeIdentifier_in_primaryExpression5038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qualifiedIdent_in_primaryExpression5043 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_propOrIdent5059 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_propOrIdent5061 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xmlLiteral_in_constant5086 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _regexpLiteral_in_constant5091 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_constant5096 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteral_in_constant5109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_constant5122 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_constant5127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_constant5132 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteralDouble_in_stringLiteral5146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteralSingle_in_stringLiteral5150 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_DOUBLE_in_stringLiteralDouble5167 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_SINGLE_in_stringLiteralSingle5192 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _XML_LITERAL_in_xmlLiteral5253 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGEX_LITERAL_in_regexpLiteral5283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression5304 = new BitSet(new ulong[]{0x3002000000008000UL,0x33000644018000UL,0x4081900011090001UL,0x208008103800UL,0x1UL});
		public static readonly BitSet _fullNewSubexpression_in_newExpression5306 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _arguments_in_newExpression5308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_fullNewSubexpression5333 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _DOT_in_fullNewSubexpression5349 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_fullNewSubexpression5351 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _brackets_in_fullNewSubexpression5368 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _DOT_in_propertyOperator5395 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_propertyOperator5397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _brackets_in_propertyOperator5402 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_brackets5413 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expressionList_in_brackets5415 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_brackets5417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_encapsulatedExpression5428 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_encapsulatedExpression5430 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_encapsulatedExpression5432 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionDefinition5456 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _parameterDeclarationList_in_functionDefinition5458 = new BitSet(new ulong[]{0x4000000000UL,0x20000000000000UL});
		public static readonly BitSet _typeExpression_in_functionDefinition5460 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_functionDefinition5463 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred1_AS3524 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_synpred1_AS3526 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred2_AS3537 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_synpred2_AS3539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_synpred3_AS3670 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _IDENT_in_synpred3_AS3672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred4_AS3686 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_synpred4_AS3688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred5_AS3708 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_synpred5_AS3710 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred6_AS3724 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_synpred6_AS3726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred7_AS3740 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_synpred7_AS3742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred8_AS3756 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_synpred8_AS3758 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_synpred9_AS31237 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _IDENT_in_synpred9_AS31239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred10_AS31250 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_synpred10_AS31252 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred11_AS31272 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_synpred11_AS31274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_synpred12_AS31485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_synpred13_AS32021 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_synpred14_AS32216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespaceName_in_synpred15_AS33178 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _DBL_COLON_in_synpred15_AS33180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentOperator_in_synpred16_AS33919 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
