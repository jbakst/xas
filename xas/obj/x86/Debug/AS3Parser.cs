//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 AS3.g 2014-07-20 20:22:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;
using com.redwine.xas;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class AS3Parser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACCESSOR_ROLE", "ADDITIVE_EXP", "ANNOTATION", "ANNOTATIONS", "ANNOTATION_PARAMS", "ARGUMENT", "ARGUMENTS", "ARRAY_ACC", "ARRAY_ACCESS", "ARRAY_LITERAL", "ARRAY_SUBSCRIPT", "AS", "ASSIGN", "ASSIGNMENT_EXPR", "BAND", "BAND_ASSIGN", "BLOCK", "BNOT", "BOM", "BOR", "BOR_ASSIGN", "BREAK", "BREAK_STATEMENT", "BSLASH", "BSR", "BSR_ASSIGN", "BXOR", "BXOR_ASSIGN", "CASE", "CASE_DEFAULT", "CLASS", "CLASS_DEF", "CLASS_MEMBER", "CLASS_NAME", "COLON", "COMMA", "COMPILATION_UNIT", "CONDITION", "CONST", "CONSTANT", "CONTINUE", "CONTINUE_STATEMENT", "CTRLCHAR_ESC", "DBL_COLON", "DEC", "DECIMAL_LITERAL", "DECLARATION", "DECL_STMT", "DEFAULT", "DEFAULT_XML_NAMESPACE", "DIV", "DIV_ASSIGN", "DO", "DOT", "DO_WHILE", "DO_WHILE_LOOP", "DYNAMIC", "E4X_ATTRI", "E4X_DESC", "E4X_EXPRESSION", "EACH", "ELEMENT", "ELIST", "ELSE", "ELSE_CLAUSE", "ENCPS_EXPR", "EQUAL", "ESC", "EXPONENT", "EXPR", "EXPRESSION", "EXPR_LIST", "EXPR_STMNT", "EXTENDS", "EXTENDS_CLAUSE", "FALSE", "FLOAT_LITERAL", "FOR", "FOR_CLAUSE", "FOR_CONDITION", "FOR_EACH_LOOP", "FOR_INIT", "FOR_IN_CLAUSE", "FOR_IN_LOOP", "FOR_ITERATOR", "FOR_LOOP", "FUNCTION", "FUNCTION_CALL", "FUNC_DEF", "GE", "GET", "GT", "HEX_DIGIT", "HEX_LITERAL", "IDENT", "IDENTIFIER", "IDENTIFIER_STAR", "IF", "IF_STMT", "IMPLEMENTS", "IMPLEMENTS_CLAUSE", "IMPORT", "IMPORT_DEF", "IN", "INC", "INCLUDE_DIRECTIVE", "INTERFACE", "INTERFACE_DEF", "INTERNAL", "IS", "LAND", "LAND_ASSIGN", "LBRACK", "LCURLY", "LE", "LITERAL_DOUBLE_STRING", "LITERAL_NUMBER", "LITERAL_REGEX", "LITERAL_SINGLE_STRING", "LITERAL_STRING", "LITERAL_XML", "LNOT", "LOR", "LOR_ASSIGN", "LPAREN", "LT", "METADATA", "METADATA_ITEM", "METHOD", "METHOD_BLOCK", "METHOD_DEF", "METHOD_NAME", "MINUS", "MINUS_ASSIGN", "ML_COMMENT", "MOD", "MODIFIERS", "MODIFIER_LIST", "MOD_ASSIGN", "NAME", "NAMESPACE", "NAMESPACE_DEF", "NAMESPACE_USAGE", "NEW", "NEW_EXPR", "NEW_EXPRESSION", "NL", "NOT_EQUAL", "NULL", "OBJECT_FIELD", "OBJECT_LITERAL", "OCTAL_ESC", "OCTAL_LITERAL", "OCT_DIGIT", "PACKAGE", "PACKAGE_DECL", "PARAM", "PARAMS", "PARAM_DECL", "PARAM_LIST", "PARAM_REST_DECL", "PLUS", "PLUS_ASSIGN", "POST_DEC", "POST_INC", "PRE_DEC", "PRE_INC", "PRIMARY_EXPRESSION", "PRIVATE", "PROP_ACCESS", "PROP_OR_IDENT", "PROTECTED", "PUBLIC", "QUALIFIED_NAME", "QUESTION", "RBRACK", "RCURLY", "REGEX", "REGEX_BODY", "REGEX_LITERAL", "REGEX_POSTFIX", "REST", "RETURN", "RETURN_STATEMENT", "RPAREN", "SEMI", "SET", "SL", "SL_ASSIGN", "SL_COMMENT", "SR", "SR_ASSIGN", "STAR", "STAR_ASSIGN", "STATEMENT", "STATEMENT_BLOCK", "STATIC", "STRICT_EQUAL", "STRICT_NOT_EQUAL", "STRING_LITERAL_DOUBLE", "STRING_LITERAL_SINGLE", "SUPER", "SWITCH", "SWITCH_BLOCK", "SWITCH_STATEMENT", "SWITCH_STATEMENT_LIST", "THROW", "THROW_STATEMENT", "TRUE", "TRY_STATEMENT", "TYPE_BLOCK", "TYPE_SPEC", "UNARY_MINUS", "UNARY_PLUS", "UNICODE_ESC", "USE", "VAR", "VARIABLE_DECLARATOR", "VARIABLE_DEF", "VAR_DEC", "VAR_DECLARATION", "VAR_INIT", "VAR_INITIALIZER", "WHILE", "WHILE_LOOP", "WITH", "WS", "XML", "XML_AS3_EXPRESSION", "XML_ATTRIBUTE", "XML_BINDING", "XML_CDATA", "XML_COMMENT", "XML_LITERAL", "XML_SUBTREE", "XML_TEXTNODE", "XML_WS", "'and'", "'catch'", "'delete'", "'enumerable'", "'explicit'", "'final'", "'finally'", "'include'", "'instanceof'", "'intrinsic'", "'or'", "'override'", "'throw'", "'try'", "'typeof'", "'undefined'", "'void'"
	};
	public const int EOF=-1;
	public const int ACCESSOR_ROLE=4;
	public const int ADDITIVE_EXP=5;
	public const int ANNOTATION=6;
	public const int ANNOTATIONS=7;
	public const int ANNOTATION_PARAMS=8;
	public const int ARGUMENT=9;
	public const int ARGUMENTS=10;
	public const int ARRAY_ACC=11;
	public const int ARRAY_ACCESS=12;
	public const int ARRAY_LITERAL=13;
	public const int ARRAY_SUBSCRIPT=14;
	public const int AS=15;
	public const int ASSIGN=16;
	public const int ASSIGNMENT_EXPR=17;
	public const int BAND=18;
	public const int BAND_ASSIGN=19;
	public const int BLOCK=20;
	public const int BNOT=21;
	public const int BOM=22;
	public const int BOR=23;
	public const int BOR_ASSIGN=24;
	public const int BREAK=25;
	public const int BREAK_STATEMENT=26;
	public const int BSLASH=27;
	public const int BSR=28;
	public const int BSR_ASSIGN=29;
	public const int BXOR=30;
	public const int BXOR_ASSIGN=31;
	public const int CASE=32;
	public const int CASE_DEFAULT=33;
	public const int CLASS=34;
	public const int CLASS_DEF=35;
	public const int CLASS_MEMBER=36;
	public const int CLASS_NAME=37;
	public const int COLON=38;
	public const int COMMA=39;
	public const int COMPILATION_UNIT=40;
	public const int CONDITION=41;
	public const int CONST=42;
	public const int CONSTANT=43;
	public const int CONTINUE=44;
	public const int CONTINUE_STATEMENT=45;
	public const int CTRLCHAR_ESC=46;
	public const int DBL_COLON=47;
	public const int DEC=48;
	public const int DECIMAL_LITERAL=49;
	public const int DECLARATION=50;
	public const int DECL_STMT=51;
	public const int DEFAULT=52;
	public const int DEFAULT_XML_NAMESPACE=53;
	public const int DIV=54;
	public const int DIV_ASSIGN=55;
	public const int DO=56;
	public const int DOT=57;
	public const int DO_WHILE=58;
	public const int DO_WHILE_LOOP=59;
	public const int DYNAMIC=60;
	public const int E4X_ATTRI=61;
	public const int E4X_DESC=62;
	public const int E4X_EXPRESSION=63;
	public const int EACH=64;
	public const int ELEMENT=65;
	public const int ELIST=66;
	public const int ELSE=67;
	public const int ELSE_CLAUSE=68;
	public const int ENCPS_EXPR=69;
	public const int EQUAL=70;
	public const int ESC=71;
	public const int EXPONENT=72;
	public const int EXPR=73;
	public const int EXPRESSION=74;
	public const int EXPR_LIST=75;
	public const int EXPR_STMNT=76;
	public const int EXTENDS=77;
	public const int EXTENDS_CLAUSE=78;
	public const int FALSE=79;
	public const int FLOAT_LITERAL=80;
	public const int FOR=81;
	public const int FOR_CLAUSE=82;
	public const int FOR_CONDITION=83;
	public const int FOR_EACH_LOOP=84;
	public const int FOR_INIT=85;
	public const int FOR_IN_CLAUSE=86;
	public const int FOR_IN_LOOP=87;
	public const int FOR_ITERATOR=88;
	public const int FOR_LOOP=89;
	public const int FUNCTION=90;
	public const int FUNCTION_CALL=91;
	public const int FUNC_DEF=92;
	public const int GE=93;
	public const int GET=94;
	public const int GT=95;
	public const int HEX_DIGIT=96;
	public const int HEX_LITERAL=97;
	public const int IDENT=98;
	public const int IDENTIFIER=99;
	public const int IDENTIFIER_STAR=100;
	public const int IF=101;
	public const int IF_STMT=102;
	public const int IMPLEMENTS=103;
	public const int IMPLEMENTS_CLAUSE=104;
	public const int IMPORT=105;
	public const int IMPORT_DEF=106;
	public const int IN=107;
	public const int INC=108;
	public const int INCLUDE_DIRECTIVE=109;
	public const int INTERFACE=110;
	public const int INTERFACE_DEF=111;
	public const int INTERNAL=112;
	public const int IS=113;
	public const int LAND=114;
	public const int LAND_ASSIGN=115;
	public const int LBRACK=116;
	public const int LCURLY=117;
	public const int LE=118;
	public const int LITERAL_DOUBLE_STRING=119;
	public const int LITERAL_NUMBER=120;
	public const int LITERAL_REGEX=121;
	public const int LITERAL_SINGLE_STRING=122;
	public const int LITERAL_STRING=123;
	public const int LITERAL_XML=124;
	public const int LNOT=125;
	public const int LOR=126;
	public const int LOR_ASSIGN=127;
	public const int LPAREN=128;
	public const int LT=129;
	public const int METADATA=130;
	public const int METADATA_ITEM=131;
	public const int METHOD=132;
	public const int METHOD_BLOCK=133;
	public const int METHOD_DEF=134;
	public const int METHOD_NAME=135;
	public const int MINUS=136;
	public const int MINUS_ASSIGN=137;
	public const int ML_COMMENT=138;
	public const int MOD=139;
	public const int MODIFIERS=140;
	public const int MODIFIER_LIST=141;
	public const int MOD_ASSIGN=142;
	public const int NAME=143;
	public const int NAMESPACE=144;
	public const int NAMESPACE_DEF=145;
	public const int NAMESPACE_USAGE=146;
	public const int NEW=147;
	public const int NEW_EXPR=148;
	public const int NEW_EXPRESSION=149;
	public const int NL=150;
	public const int NOT_EQUAL=151;
	public const int NULL=152;
	public const int OBJECT_FIELD=153;
	public const int OBJECT_LITERAL=154;
	public const int OCTAL_ESC=155;
	public const int OCTAL_LITERAL=156;
	public const int OCT_DIGIT=157;
	public const int PACKAGE=158;
	public const int PACKAGE_DECL=159;
	public const int PARAM=160;
	public const int PARAMS=161;
	public const int PARAM_DECL=162;
	public const int PARAM_LIST=163;
	public const int PARAM_REST_DECL=164;
	public const int PLUS=165;
	public const int PLUS_ASSIGN=166;
	public const int POST_DEC=167;
	public const int POST_INC=168;
	public const int PRE_DEC=169;
	public const int PRE_INC=170;
	public const int PRIMARY_EXPRESSION=171;
	public const int PRIVATE=172;
	public const int PROP_ACCESS=173;
	public const int PROP_OR_IDENT=174;
	public const int PROTECTED=175;
	public const int PUBLIC=176;
	public const int QUALIFIED_NAME=177;
	public const int QUESTION=178;
	public const int RBRACK=179;
	public const int RCURLY=180;
	public const int REGEX=181;
	public const int REGEX_BODY=182;
	public const int REGEX_LITERAL=183;
	public const int REGEX_POSTFIX=184;
	public const int REST=185;
	public const int RETURN=186;
	public const int RETURN_STATEMENT=187;
	public const int RPAREN=188;
	public const int SEMI=189;
	public const int SET=190;
	public const int SL=191;
	public const int SL_ASSIGN=192;
	public const int SL_COMMENT=193;
	public const int SR=194;
	public const int SR_ASSIGN=195;
	public const int STAR=196;
	public const int STAR_ASSIGN=197;
	public const int STATEMENT=198;
	public const int STATEMENT_BLOCK=199;
	public const int STATIC=200;
	public const int STRICT_EQUAL=201;
	public const int STRICT_NOT_EQUAL=202;
	public const int STRING_LITERAL_DOUBLE=203;
	public const int STRING_LITERAL_SINGLE=204;
	public const int SUPER=205;
	public const int SWITCH=206;
	public const int SWITCH_BLOCK=207;
	public const int SWITCH_STATEMENT=208;
	public const int SWITCH_STATEMENT_LIST=209;
	public const int THROW=210;
	public const int THROW_STATEMENT=211;
	public const int TRUE=212;
	public const int TRY_STATEMENT=213;
	public const int TYPE_BLOCK=214;
	public const int TYPE_SPEC=215;
	public const int UNARY_MINUS=216;
	public const int UNARY_PLUS=217;
	public const int UNICODE_ESC=218;
	public const int USE=219;
	public const int VAR=220;
	public const int VARIABLE_DECLARATOR=221;
	public const int VARIABLE_DEF=222;
	public const int VAR_DEC=223;
	public const int VAR_DECLARATION=224;
	public const int VAR_INIT=225;
	public const int VAR_INITIALIZER=226;
	public const int WHILE=227;
	public const int WHILE_LOOP=228;
	public const int WITH=229;
	public const int WS=230;
	public const int XML=231;
	public const int XML_AS3_EXPRESSION=232;
	public const int XML_ATTRIBUTE=233;
	public const int XML_BINDING=234;
	public const int XML_CDATA=235;
	public const int XML_COMMENT=236;
	public const int XML_LITERAL=237;
	public const int XML_SUBTREE=238;
	public const int XML_TEXTNODE=239;
	public const int XML_WS=240;
	public const int T__241=241;
	public const int T__242=242;
	public const int T__243=243;
	public const int T__244=244;
	public const int T__245=245;
	public const int T__246=246;
	public const int T__247=247;
	public const int T__248=248;
	public const int T__249=249;
	public const int T__250=250;
	public const int T__251=251;
	public const int T__252=252;
	public const int T__253=253;
	public const int T__254=254;
	public const int T__255=255;
	public const int T__256=256;
	public const int T__257=257;

	public AS3Parser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public AS3Parser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return AS3Parser.tokenNames; } }
	public override string GrammarFileName { get { return "AS3.g"; } }


	            private AS3Lexer lexer;
	            private ICharStream cs;
	            
	            public void setInput(AS3Lexer lexer, ICharStream cs) {
	                this.lexer = lexer;
	                this.cs = cs;
	            }

	            // Used in tree rewrite rules to insert semicolon tree IF it exists..
	            private CommonTree maybeSemi(AstParserRuleReturnScope<CommonTree, IToken> semi){
	                return (semi.Start.Type == SEMI ? (CommonTree)semi.Tree : null);
	            }



	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_compilationUnit();
	partial void LeaveRule_compilationUnit();
	// $ANTLR start "compilationUnit"
	// AS3.g:114:8: public compilationUnit : ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) ;
	[GrammarRule("compilationUnit")]
	public AstParserRuleReturnScope<CommonTree, IToken> compilationUnit()
	{
		EnterRule_compilationUnit();
		EnterRule("compilationUnit", 1);
		TraceIn("compilationUnit", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> as2CompilationUnit1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> as3CompilationUnit2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_as2CompilationUnit=new RewriteRuleSubtreeStream(adaptor,"rule as2CompilationUnit");
		RewriteRuleSubtreeStream stream_as3CompilationUnit=new RewriteRuleSubtreeStream(adaptor,"rule as3CompilationUnit");
		try { DebugEnterRule(GrammarFileName, "compilationUnit");
		DebugLocation(114, 1);
		try
		{
			// AS3.g:115:2: ( ( as2CompilationUnit | as3CompilationUnit ) -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? ) )
			DebugEnterAlt(1);
			// AS3.g:115:4: ( as2CompilationUnit | as3CompilationUnit )
			{
			DebugLocation(115, 4);
			// AS3.g:115:4: ( as2CompilationUnit | as3CompilationUnit )
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1==CLASS||LA1_1==DYNAMIC||LA1_1==IDENT||LA1_1==IMPORT||(LA1_1>=INCLUDE_DIRECTIVE && LA1_1<=INTERFACE)||LA1_1==INTERNAL||LA1_1==PRIVATE||(LA1_1>=PROTECTED && LA1_1<=PUBLIC)||LA1_1==STATIC||(LA1_1>=244 && LA1_1<=246)||LA1_1==250||LA1_1==252))
			{
				alt1 = 1;
			}
			else if ((LA1_1==PACKAGE))
			{
				alt1 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:115:6: as2CompilationUnit
				{
				DebugLocation(115, 6);
				PushFollow(Follow._as2CompilationUnit_in_compilationUnit476);
				as2CompilationUnit1=as2CompilationUnit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_as2CompilationUnit.Add(as2CompilationUnit1.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:116:5: as3CompilationUnit
				{
				DebugLocation(116, 5);
				PushFollow(Follow._as3CompilationUnit_in_compilationUnit482);
				as3CompilationUnit2=as3CompilationUnit();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_as3CompilationUnit.Add(as3CompilationUnit2.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }



			{
			// AST REWRITE
			// elements: as2CompilationUnit, as3CompilationUnit
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 117:5: -> ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
			{
				DebugLocation(117, 8);
				// AS3.g:117:8: ^( COMPILATION_UNIT ( as2CompilationUnit )? ( as3CompilationUnit )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(117, 10);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(COMPILATION_UNIT, "COMPILATION_UNIT"), root_1);

				DebugLocation(117, 27);
				// AS3.g:117:27: ( as2CompilationUnit )?
				if (stream_as2CompilationUnit.HasNext)
				{
					DebugLocation(117, 27);
					adaptor.AddChild(root_1, stream_as2CompilationUnit.NextTree());

				}
				stream_as2CompilationUnit.Reset();
				DebugLocation(117, 47);
				// AS3.g:117:47: ( as3CompilationUnit )?
				if (stream_as3CompilationUnit.HasNext)
				{
					DebugLocation(117, 47);
					adaptor.AddChild(root_1, stream_as3CompilationUnit.NextTree());

				}
				stream_as3CompilationUnit.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compilationUnit", 1);
			LeaveRule("compilationUnit", 1);
			LeaveRule_compilationUnit();
		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "compilationUnit"); }
		return retval;

	}
	// $ANTLR end "compilationUnit"

	partial void EnterRule_as2CompilationUnit();
	partial void LeaveRule_as2CompilationUnit();
	// $ANTLR start "as2CompilationUnit"
	// AS3.g:120:1: as2CompilationUnit : ( importDefinition )* as2Type ;
	[GrammarRule("as2CompilationUnit")]
	private AstParserRuleReturnScope<CommonTree, IToken> as2CompilationUnit()
	{
		EnterRule_as2CompilationUnit();
		EnterRule("as2CompilationUnit", 2);
		TraceIn("as2CompilationUnit", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> importDefinition3 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> as2Type4 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "as2CompilationUnit");
		DebugLocation(120, 1);
		try
		{
			// AS3.g:121:2: ( ( importDefinition )* as2Type )
			DebugEnterAlt(1);
			// AS3.g:121:4: ( importDefinition )* as2Type
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(121, 4);
			// AS3.g:121:4: ( importDefinition )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==IMPORT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:121:4: importDefinition
					{
					DebugLocation(121, 4);
					PushFollow(Follow._importDefinition_in_as2CompilationUnit509);
					importDefinition3=importDefinition();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition3.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(122, 3);
			PushFollow(Follow._as2Type_in_as2CompilationUnit514);
			as2Type4=as2Type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, as2Type4.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2CompilationUnit", 2);
			LeaveRule("as2CompilationUnit", 2);
			LeaveRule_as2CompilationUnit();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "as2CompilationUnit"); }
		return retval;

	}
	// $ANTLR end "as2CompilationUnit"

	partial void EnterRule_as2Type();
	partial void LeaveRule_as2Type();
	// $ANTLR start "as2Type"
	// AS3.g:125:1: as2Type : ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition ) ;
	[GrammarRule("as2Type")]
	private AstParserRuleReturnScope<CommonTree, IToken> as2Type()
	{
		EnterRule_as2Type();
		EnterRule("as2Type", 3);
		TraceIn("as2Type", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> as2IncludeDirective5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> as2ClassDefinition6 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> as2InterfaceDefinition7 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "as2Type");
		DebugLocation(125, 1);
		try
		{
			// AS3.g:126:2: ( ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition ) )
			DebugEnterAlt(1);
			// AS3.g:127:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(127, 2);
			// AS3.g:127:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )
			int alt3=3;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			try
			{
				alt3 = dfa3.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:127:4: as2IncludeDirective
				{
				DebugLocation(127, 4);
				PushFollow(Follow._as2IncludeDirective_in_as2Type529);
				as2IncludeDirective5=as2IncludeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2IncludeDirective5.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:128:4: ( modifiers CLASS )=> as2ClassDefinition
				{
				DebugLocation(128, 25);
				PushFollow(Follow._as2ClassDefinition_in_as2Type542);
				as2ClassDefinition6=as2ClassDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2ClassDefinition6.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:129:4: ( modifiers INTERFACE )=> as2InterfaceDefinition
				{
				DebugLocation(129, 29);
				PushFollow(Follow._as2InterfaceDefinition_in_as2Type555);
				as2InterfaceDefinition7=as2InterfaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, as2InterfaceDefinition7.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2Type", 3);
			LeaveRule("as2Type", 3);
			LeaveRule_as2Type();
		}
		DebugLocation(131, 1);
		} finally { DebugExitRule(GrammarFileName, "as2Type"); }
		return retval;

	}
	// $ANTLR end "as2Type"

	partial void EnterRule_as3CompilationUnit();
	partial void LeaveRule_as3CompilationUnit();
	// $ANTLR start "as3CompilationUnit"
	// AS3.g:133:1: as3CompilationUnit : packageDecl ( packageBlockEntry )* EOF !;
	[GrammarRule("as3CompilationUnit")]
	private AstParserRuleReturnScope<CommonTree, IToken> as3CompilationUnit()
	{
		EnterRule_as3CompilationUnit();
		EnterRule("as3CompilationUnit", 4);
		TraceIn("as3CompilationUnit", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF10 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> packageDecl8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> packageBlockEntry9 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EOF10_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "as3CompilationUnit");
		DebugLocation(133, 1);
		try
		{
			// AS3.g:134:2: ( packageDecl ( packageBlockEntry )* EOF !)
			DebugEnterAlt(1);
			// AS3.g:134:4: packageDecl ( packageBlockEntry )* EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(134, 4);
			PushFollow(Follow._packageDecl_in_as3CompilationUnit569);
			packageDecl8=packageDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, packageDecl8.Tree);
			DebugLocation(135, 3);
			// AS3.g:135:3: ( packageBlockEntry )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if ((LA4_1==AS||LA4_1==BNOT||LA4_1==BREAK||LA4_1==CLASS||LA4_1==CONST||LA4_1==CONTINUE||(LA4_1>=DEC && LA4_1<=DECIMAL_LITERAL)||LA4_1==DEFAULT||LA4_1==DO||(LA4_1>=DYNAMIC && LA4_1<=E4X_ATTRI)||(LA4_1>=FALSE && LA4_1<=FOR)||LA4_1==FUNCTION||LA4_1==GET||(LA4_1>=HEX_LITERAL && LA4_1<=IDENT)||LA4_1==IF||LA4_1==IMPORT||LA4_1==INC||LA4_1==INTERFACE||(LA4_1>=INTERNAL && LA4_1<=IS)||(LA4_1>=LBRACK && LA4_1<=LCURLY)||LA4_1==LNOT||LA4_1==LPAREN||LA4_1==MINUS||LA4_1==NAMESPACE||LA4_1==NEW||LA4_1==NULL||LA4_1==OCTAL_LITERAL||LA4_1==PLUS||LA4_1==PRIVATE||(LA4_1>=PROTECTED && LA4_1<=PUBLIC)||LA4_1==REGEX_LITERAL||LA4_1==RETURN||(LA4_1>=SEMI && LA4_1<=SET)||LA4_1==STATIC||(LA4_1>=STRING_LITERAL_DOUBLE && LA4_1<=SWITCH)||LA4_1==TRUE||(LA4_1>=USE && LA4_1<=VAR)||LA4_1==WHILE||LA4_1==WITH||LA4_1==XML||LA4_1==XML_LITERAL||(LA4_1>=243 && LA4_1<=246)||LA4_1==248||LA4_1==250||(LA4_1>=252 && LA4_1<=257)))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:135:3: packageBlockEntry
					{
					DebugLocation(135, 3);
					PushFollow(Follow._packageBlockEntry_in_as3CompilationUnit573);
					packageBlockEntry9=packageBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, packageBlockEntry9.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(136, 6);
			EOF10=(IToken)Match(input,EOF,Follow._EOF_in_as3CompilationUnit578); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as3CompilationUnit", 4);
			LeaveRule("as3CompilationUnit", 4);
			LeaveRule_as3CompilationUnit();
		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "as3CompilationUnit"); }
		return retval;

	}
	// $ANTLR end "as3CompilationUnit"

	partial void EnterRule_packageDecl();
	partial void LeaveRule_packageDecl();
	// $ANTLR start "packageDecl"
	// AS3.g:139:1: packageDecl : PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY ) ;
	[GrammarRule("packageDecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> packageDecl()
	{
		EnterRule_packageDecl();
		EnterRule("packageDecl", 5);
		TraceIn("packageDecl", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken PACKAGE11 = default(IToken);
		IToken LCURLY13 = default(IToken);
		IToken RCURLY15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifierStar12 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> packageBlockEntry14 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree PACKAGE11_tree = default(CommonTree);
		CommonTree LCURLY13_tree = default(CommonTree);
		CommonTree RCURLY15_tree = default(CommonTree);
		RewriteRuleITokenStream stream_PACKAGE=new RewriteRuleITokenStream(adaptor,"token PACKAGE");
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_identifierStar=new RewriteRuleSubtreeStream(adaptor,"rule identifierStar");
		RewriteRuleSubtreeStream stream_packageBlockEntry=new RewriteRuleSubtreeStream(adaptor,"rule packageBlockEntry");
		try { DebugEnterRule(GrammarFileName, "packageDecl");
		DebugLocation(139, 1);
		try
		{
			// AS3.g:140:2: ( PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// AS3.g:140:4: PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY
			{
			DebugLocation(140, 4);
			PACKAGE11=(IToken)Match(input,PACKAGE,Follow._PACKAGE_in_packageDecl590); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_PACKAGE.Add(PACKAGE11);

			DebugLocation(140, 12);
			// AS3.g:140:12: ( identifierStar )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==AS||LA5_1==DYNAMIC||LA5_1==GET||LA5_1==IDENT||LA5_1==IS||LA5_1==NAMESPACE||LA5_1==SET||LA5_1==SUPER||LA5_1==USE||LA5_1==XML))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:140:12: identifierStar
				{
				DebugLocation(140, 12);
				PushFollow(Follow._identifierStar_in_packageDecl592);
				identifierStar12=identifierStar();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_identifierStar.Add(identifierStar12.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(141, 3);
			LCURLY13=(IToken)Match(input,LCURLY,Follow._LCURLY_in_packageDecl597); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY13);

			DebugLocation(142, 9);
			// AS3.g:142:9: ( packageBlockEntry )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==AS||LA6_1==BNOT||LA6_1==BREAK||LA6_1==CLASS||LA6_1==CONST||LA6_1==CONTINUE||(LA6_1>=DEC && LA6_1<=DECIMAL_LITERAL)||LA6_1==DEFAULT||LA6_1==DO||(LA6_1>=DYNAMIC && LA6_1<=E4X_ATTRI)||(LA6_1>=FALSE && LA6_1<=FOR)||LA6_1==FUNCTION||LA6_1==GET||(LA6_1>=HEX_LITERAL && LA6_1<=IDENT)||LA6_1==IF||LA6_1==IMPORT||LA6_1==INC||LA6_1==INTERFACE||(LA6_1>=INTERNAL && LA6_1<=IS)||(LA6_1>=LBRACK && LA6_1<=LCURLY)||LA6_1==LNOT||LA6_1==LPAREN||LA6_1==MINUS||LA6_1==NAMESPACE||LA6_1==NEW||LA6_1==NULL||LA6_1==OCTAL_LITERAL||LA6_1==PLUS||LA6_1==PRIVATE||(LA6_1>=PROTECTED && LA6_1<=PUBLIC)||LA6_1==REGEX_LITERAL||LA6_1==RETURN||(LA6_1>=SEMI && LA6_1<=SET)||LA6_1==STATIC||(LA6_1>=STRING_LITERAL_DOUBLE && LA6_1<=SWITCH)||LA6_1==TRUE||(LA6_1>=USE && LA6_1<=VAR)||LA6_1==WHILE||LA6_1==WITH||LA6_1==XML||LA6_1==XML_LITERAL||(LA6_1>=243 && LA6_1<=246)||LA6_1==248||LA6_1==250||(LA6_1>=252 && LA6_1<=257)))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:142:9: packageBlockEntry
					{
					DebugLocation(142, 9);
					PushFollow(Follow._packageBlockEntry_in_packageDecl608);
					packageBlockEntry14=packageBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_packageBlockEntry.Add(packageBlockEntry14.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(143, 3);
			RCURLY15=(IToken)Match(input,RCURLY,Follow._RCURLY_in_packageDecl613); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY15);



			{
			// AST REWRITE
			// elements: PACKAGE, identifierStar, LCURLY, packageBlockEntry, RCURLY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 144:3: -> ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY )
			{
				DebugLocation(144, 6);
				// AS3.g:144:6: ^( PACKAGE_DECL PACKAGE ( identifierStar )? LCURLY ( packageBlockEntry )* RCURLY )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(144, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PACKAGE_DECL, "PACKAGE_DECL"), root_1);

				DebugLocation(144, 21);
				adaptor.AddChild(root_1, stream_PACKAGE.NextNode());
				DebugLocation(144, 29);
				// AS3.g:144:29: ( identifierStar )?
				if (stream_identifierStar.HasNext)
				{
					DebugLocation(144, 29);
					adaptor.AddChild(root_1, stream_identifierStar.NextTree());

				}
				stream_identifierStar.Reset();
				DebugLocation(144, 45);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(144, 52);
				// AS3.g:144:52: ( packageBlockEntry )*
				while ( stream_packageBlockEntry.HasNext )
				{
					DebugLocation(144, 52);
					adaptor.AddChild(root_1, stream_packageBlockEntry.NextTree());

				}
				stream_packageBlockEntry.Reset();
				DebugLocation(144, 71);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("packageDecl", 5);
			LeaveRule("packageDecl", 5);
			LeaveRule_packageDecl();
		}
		DebugLocation(145, 1);
		} finally { DebugExitRule(GrammarFileName, "packageDecl"); }
		return retval;

	}
	// $ANTLR end "packageDecl"

	partial void EnterRule_packageBlockEntry();
	partial void LeaveRule_packageBlockEntry();
	// $ANTLR start "packageBlockEntry"
	// AS3.g:147:2: packageBlockEntry options {k=2; } : ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement );
	[GrammarRule("packageBlockEntry")]
	private AstParserRuleReturnScope<CommonTree, IToken> packageBlockEntry()
	{
		EnterRule_packageBlockEntry();
		EnterRule("packageBlockEntry", 6);
		TraceIn("packageBlockEntry", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> importDefinition16 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> includeDirective17 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> useNamespaceDirective18 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> annotation19 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> namespaceDefinition20 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> classDefinition21 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interfaceDefinition22 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> methodDefinition23 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDefinition24 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement25 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "packageBlockEntry");
		DebugLocation(147, 1);
		try
		{
			// AS3.g:148:2: ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement )
			int alt7=10;
			try { DebugEnterDecision(7, false);
			try
			{
				alt7 = dfa7.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:148:8: importDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(148, 8);
				PushFollow(Follow._importDefinition_in_packageBlockEntry656);
				importDefinition16=importDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition16.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:149:7: includeDirective
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(149, 7);
				PushFollow(Follow._includeDirective_in_packageBlockEntry664);
				includeDirective17=includeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, includeDirective17.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:150:7: useNamespaceDirective
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(150, 7);
				PushFollow(Follow._useNamespaceDirective_in_packageBlockEntry672);
				useNamespaceDirective18=useNamespaceDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, useNamespaceDirective18.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:151:7: ( LBRACK IDENT )=> annotation
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(151, 25);
				PushFollow(Follow._annotation_in_packageBlockEntry688);
				annotation19=annotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, annotation19.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:152:7: ( modifiers NAMESPACE )=> namespaceDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(152, 32);
				PushFollow(Follow._namespaceDefinition_in_packageBlockEntry704);
				namespaceDefinition20=namespaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceDefinition20.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:153:13: ( modifiers CLASS )=> classDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(153, 34);
				PushFollow(Follow._classDefinition_in_packageBlockEntry726);
				classDefinition21=classDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, classDefinition21.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:154:7: ( modifiers INTERFACE )=> interfaceDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(154, 32);
				PushFollow(Follow._interfaceDefinition_in_packageBlockEntry742);
				interfaceDefinition22=interfaceDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, interfaceDefinition22.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// AS3.g:155:7: ( modifiers FUNCTION )=> methodDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(155, 31);
				PushFollow(Follow._methodDefinition_in_packageBlockEntry758);
				methodDefinition23=methodDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, methodDefinition23.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// AS3.g:156:7: ( modifiers varOrConst )=> variableDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(156, 33);
				PushFollow(Follow._variableDefinition_in_packageBlockEntry774);
				variableDefinition24=variableDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableDefinition24.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// AS3.g:157:13: statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(157, 13);
				PushFollow(Follow._statement_in_packageBlockEntry788);
				statement25=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement25.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("packageBlockEntry", 6);
			LeaveRule("packageBlockEntry", 6);
			LeaveRule_packageBlockEntry();
		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "packageBlockEntry"); }
		return retval;

	}
	// $ANTLR end "packageBlockEntry"

	partial void EnterRule_endOfFile();
	partial void LeaveRule_endOfFile();
	// $ANTLR start "endOfFile"
	// AS3.g:162:1: endOfFile : EOF !;
	[GrammarRule("endOfFile")]
	private AstParserRuleReturnScope<CommonTree, IToken> endOfFile()
	{
		EnterRule_endOfFile();
		EnterRule("endOfFile", 7);
		TraceIn("endOfFile", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EOF26 = default(IToken);

		CommonTree EOF26_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "endOfFile");
		DebugLocation(162, 1);
		try
		{
			// AS3.g:163:2: ( EOF !)
			DebugEnterAlt(1);
			// AS3.g:163:4: EOF !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(163, 7);
			EOF26=(IToken)Match(input,EOF,Follow._EOF_in_endOfFile801); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("endOfFile", 7);
			LeaveRule("endOfFile", 7);
			LeaveRule_endOfFile();
		}
		DebugLocation(164, 1);
		} finally { DebugExitRule(GrammarFileName, "endOfFile"); }
		return retval;

	}
	// $ANTLR end "endOfFile"

	partial void EnterRule_importDefinition();
	partial void LeaveRule_importDefinition();
	// $ANTLR start "importDefinition"
	// AS3.g:166:1: importDefinition : IMPORT identifierStar s= semi -> ^( IMPORT_DEF IMPORT identifierStar ) ;
	[GrammarRule("importDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> importDefinition()
	{
		EnterRule_importDefinition();
		EnterRule("importDefinition", 8);
		TraceIn("importDefinition", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IMPORT27 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifierStar28 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IMPORT27_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IMPORT=new RewriteRuleITokenStream(adaptor,"token IMPORT");
		RewriteRuleSubtreeStream stream_identifierStar=new RewriteRuleSubtreeStream(adaptor,"rule identifierStar");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "importDefinition");
		DebugLocation(166, 1);
		try
		{
			// AS3.g:167:2: ( IMPORT identifierStar s= semi -> ^( IMPORT_DEF IMPORT identifierStar ) )
			DebugEnterAlt(1);
			// AS3.g:167:4: IMPORT identifierStar s= semi
			{
			DebugLocation(167, 4);
			IMPORT27=(IToken)Match(input,IMPORT,Follow._IMPORT_in_importDefinition813); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPORT.Add(IMPORT27);

			DebugLocation(167, 11);
			PushFollow(Follow._identifierStar_in_importDefinition815);
			identifierStar28=identifierStar();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifierStar.Add(identifierStar28.Tree);
			DebugLocation(167, 27);
			PushFollow(Follow._semi_in_importDefinition819);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: IMPORT, identifierStar
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 168:10: -> ^( IMPORT_DEF IMPORT identifierStar )
			{
				DebugLocation(168, 13);
				// AS3.g:168:13: ^( IMPORT_DEF IMPORT identifierStar )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(168, 15);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(IMPORT_DEF, "IMPORT_DEF"), root_1);

				DebugLocation(168, 26);
				adaptor.AddChild(root_1, stream_IMPORT.NextNode());
				DebugLocation(168, 33);
				adaptor.AddChild(root_1, stream_identifierStar.NextTree());
				DebugLocation(168, 48);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("importDefinition", 8);
			LeaveRule("importDefinition", 8);
			LeaveRule_importDefinition();
		}
		DebugLocation(169, 1);
		} finally { DebugExitRule(GrammarFileName, "importDefinition"); }
		return retval;

	}
	// $ANTLR end "importDefinition"

	partial void EnterRule_semi();
	partial void LeaveRule_semi();
	// $ANTLR start "semi"
	// AS3.g:171:1: semi : SEMI ;
	[GrammarRule("semi")]
	private AstParserRuleReturnScope<CommonTree, IToken> semi()
	{
		EnterRule_semi();
		EnterRule("semi", 9);
		TraceIn("semi", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SEMI29 = default(IToken);

		CommonTree SEMI29_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "semi");
		DebugLocation(171, 1);
		try
		{
			// AS3.g:172:2: ( SEMI )
			DebugEnterAlt(1);
			// AS3.g:172:4: SEMI
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(172, 4);
			SEMI29=(IToken)Match(input,SEMI,Follow._SEMI_in_semi852); if (state.failed) return retval;
			if (state.backtracking == 0) {
			SEMI29_tree = (CommonTree)adaptor.Create(SEMI29);
			adaptor.AddChild(root_0, SEMI29_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("semi", 9);
			LeaveRule("semi", 9);
			LeaveRule_semi();
		}
		DebugLocation(173, 1);
		} finally { DebugExitRule(GrammarFileName, "semi"); }
		return retval;

	}
	// $ANTLR end "semi"

	partial void EnterRule_classDefinition();
	partial void LeaveRule_classDefinition();
	// $ANTLR start "classDefinition"
	// AS3.g:175:1: classDefinition : modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock ) ;
	[GrammarRule("classDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> classDefinition()
	{
		EnterRule_classDefinition();
		EnterRule("classDefinition", 10);
		TraceIn("classDefinition", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CLASS31 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers30 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident32 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> classExtendsClause33 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> implementsClause34 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeBlock35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CLASS31_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_classExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
		RewriteRuleSubtreeStream stream_implementsClause=new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		try { DebugEnterRule(GrammarFileName, "classDefinition");
		DebugLocation(175, 1);
		try
		{
			// AS3.g:176:2: ( modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// AS3.g:176:4: modifiers CLASS ident ( classExtendsClause )? ( implementsClause )? typeBlock
			{
			DebugLocation(176, 4);
			PushFollow(Follow._modifiers_in_classDefinition864);
			modifiers30=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers30.Tree);
			DebugLocation(177, 3);
			CLASS31=(IToken)Match(input,CLASS,Follow._CLASS_in_classDefinition868); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS31);

			DebugLocation(178, 9);
			PushFollow(Follow._ident_in_classDefinition879);
			ident32=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident32.Tree);
			DebugLocation(179, 3);
			// AS3.g:179:3: ( classExtendsClause )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_1 = input.LA(1);

			if ((LA8_1==EXTENDS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:179:3: classExtendsClause
				{
				DebugLocation(179, 3);
				PushFollow(Follow._classExtendsClause_in_classDefinition883);
				classExtendsClause33=classExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_classExtendsClause.Add(classExtendsClause33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(180, 3);
			// AS3.g:180:3: ( implementsClause )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_1 = input.LA(1);

			if ((LA9_1==IMPLEMENTS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:180:3: implementsClause
				{
				DebugLocation(180, 3);
				PushFollow(Follow._implementsClause_in_classDefinition888);
				implementsClause34=implementsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_implementsClause.Add(implementsClause34.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(181, 3);
			PushFollow(Follow._typeBlock_in_classDefinition893);
			typeBlock35=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock35.Tree);


			{
			// AST REWRITE
			// elements: modifiers, CLASS, ident, classExtendsClause, implementsClause, typeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 182:3: -> ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock )
			{
				DebugLocation(182, 6);
				// AS3.g:182:6: ^( CLASS_DEF modifiers CLASS ^( CLASS_NAME ident ) ( classExtendsClause )? ( implementsClause )? typeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(182, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

				DebugLocation(182, 18);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(182, 28);
				adaptor.AddChild(root_1, stream_CLASS.NextNode());
				DebugLocation(182, 34);
				// AS3.g:182:34: ^( CLASS_NAME ident )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(182, 36);
				root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CLASS_NAME, "CLASS_NAME"), root_2);

				DebugLocation(182, 47);
				adaptor.AddChild(root_2, stream_ident.NextTree());

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(182, 54);
				// AS3.g:182:54: ( classExtendsClause )?
				if (stream_classExtendsClause.HasNext)
				{
					DebugLocation(182, 54);
					adaptor.AddChild(root_1, stream_classExtendsClause.NextTree());

				}
				stream_classExtendsClause.Reset();
				DebugLocation(182, 74);
				// AS3.g:182:74: ( implementsClause )?
				if (stream_implementsClause.HasNext)
				{
					DebugLocation(182, 74);
					adaptor.AddChild(root_1, stream_implementsClause.NextTree());

				}
				stream_implementsClause.Reset();
				DebugLocation(182, 92);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classDefinition", 10);
			LeaveRule("classDefinition", 10);
			LeaveRule_classDefinition();
		}
		DebugLocation(183, 1);
		} finally { DebugExitRule(GrammarFileName, "classDefinition"); }
		return retval;

	}
	// $ANTLR end "classDefinition"

	partial void EnterRule_as2ClassDefinition();
	partial void LeaveRule_as2ClassDefinition();
	// $ANTLR start "as2ClassDefinition"
	// AS3.g:185:1: as2ClassDefinition : modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock ) ;
	[GrammarRule("as2ClassDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> as2ClassDefinition()
	{
		EnterRule_as2ClassDefinition();
		EnterRule("as2ClassDefinition", 11);
		TraceIn("as2ClassDefinition", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CLASS37 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers36 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> classExtendsClause39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> implementsClause40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeBlock41 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CLASS37_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CLASS=new RewriteRuleITokenStream(adaptor,"token CLASS");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_classExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule classExtendsClause");
		RewriteRuleSubtreeStream stream_implementsClause=new RewriteRuleSubtreeStream(adaptor,"rule implementsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		try { DebugEnterRule(GrammarFileName, "as2ClassDefinition");
		DebugLocation(185, 1);
		try
		{
			// AS3.g:186:2: ( modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// AS3.g:186:4: modifiers CLASS identifier ( classExtendsClause )? ( implementsClause )? typeBlock
			{
			DebugLocation(186, 4);
			PushFollow(Follow._modifiers_in_as2ClassDefinition930);
			modifiers36=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers36.Tree);
			DebugLocation(187, 3);
			CLASS37=(IToken)Match(input,CLASS,Follow._CLASS_in_as2ClassDefinition934); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CLASS.Add(CLASS37);

			DebugLocation(187, 9);
			PushFollow(Follow._identifier_in_as2ClassDefinition936);
			identifier38=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier38.Tree);
			DebugLocation(188, 3);
			// AS3.g:188:3: ( classExtendsClause )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==EXTENDS))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:188:3: classExtendsClause
				{
				DebugLocation(188, 3);
				PushFollow(Follow._classExtendsClause_in_as2ClassDefinition940);
				classExtendsClause39=classExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_classExtendsClause.Add(classExtendsClause39.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(189, 3);
			// AS3.g:189:3: ( implementsClause )?
			int alt11=2;
			try { DebugEnterSubRule(11);
			try { DebugEnterDecision(11, false);
			int LA11_1 = input.LA(1);

			if ((LA11_1==IMPLEMENTS))
			{
				alt11 = 1;
			}
			} finally { DebugExitDecision(11); }
			switch (alt11)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:189:3: implementsClause
				{
				DebugLocation(189, 3);
				PushFollow(Follow._implementsClause_in_as2ClassDefinition945);
				implementsClause40=implementsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_implementsClause.Add(implementsClause40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(11); }

			DebugLocation(190, 3);
			PushFollow(Follow._typeBlock_in_as2ClassDefinition950);
			typeBlock41=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock41.Tree);


			{
			// AST REWRITE
			// elements: modifiers, identifier, classExtendsClause, implementsClause, typeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 191:3: -> ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock )
			{
				DebugLocation(191, 6);
				// AS3.g:191:6: ^( CLASS_DEF modifiers identifier ( classExtendsClause )? ( implementsClause )? typeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(191, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CLASS_DEF, "CLASS_DEF"), root_1);

				DebugLocation(191, 18);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(191, 28);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(191, 39);
				// AS3.g:191:39: ( classExtendsClause )?
				if (stream_classExtendsClause.HasNext)
				{
					DebugLocation(191, 39);
					adaptor.AddChild(root_1, stream_classExtendsClause.NextTree());

				}
				stream_classExtendsClause.Reset();
				DebugLocation(191, 59);
				// AS3.g:191:59: ( implementsClause )?
				if (stream_implementsClause.HasNext)
				{
					DebugLocation(191, 59);
					adaptor.AddChild(root_1, stream_implementsClause.NextTree());

				}
				stream_implementsClause.Reset();
				DebugLocation(191, 77);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2ClassDefinition", 11);
			LeaveRule("as2ClassDefinition", 11);
			LeaveRule_as2ClassDefinition();
		}
		DebugLocation(192, 1);
		} finally { DebugExitRule(GrammarFileName, "as2ClassDefinition"); }
		return retval;

	}
	// $ANTLR end "as2ClassDefinition"

	partial void EnterRule_interfaceDefinition();
	partial void LeaveRule_interfaceDefinition();
	// $ANTLR start "interfaceDefinition"
	// AS3.g:194:1: interfaceDefinition : modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock ) ;
	[GrammarRule("interfaceDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> interfaceDefinition()
	{
		EnterRule_interfaceDefinition();
		EnterRule("interfaceDefinition", 12);
		TraceIn("interfaceDefinition", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INTERFACE43 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident44 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interfaceExtendsClause45 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeBlock46 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INTERFACE43_tree = default(CommonTree);
		RewriteRuleITokenStream stream_INTERFACE=new RewriteRuleITokenStream(adaptor,"token INTERFACE");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_interfaceExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		try { DebugEnterRule(GrammarFileName, "interfaceDefinition");
		DebugLocation(194, 1);
		try
		{
			// AS3.g:195:2: ( modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// AS3.g:195:4: modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock
			{
			DebugLocation(195, 4);
			PushFollow(Follow._modifiers_in_interfaceDefinition981);
			modifiers42=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers42.Tree);
			DebugLocation(196, 3);
			INTERFACE43=(IToken)Match(input,INTERFACE,Follow._INTERFACE_in_interfaceDefinition985); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INTERFACE.Add(INTERFACE43);

			DebugLocation(196, 13);
			PushFollow(Follow._ident_in_interfaceDefinition987);
			ident44=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident44.Tree);
			DebugLocation(197, 3);
			// AS3.g:197:3: ( interfaceExtendsClause )?
			int alt12=2;
			try { DebugEnterSubRule(12);
			try { DebugEnterDecision(12, false);
			int LA12_1 = input.LA(1);

			if ((LA12_1==EXTENDS))
			{
				alt12 = 1;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:197:3: interfaceExtendsClause
				{
				DebugLocation(197, 3);
				PushFollow(Follow._interfaceExtendsClause_in_interfaceDefinition991);
				interfaceExtendsClause45=interfaceExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause45.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(12); }

			DebugLocation(198, 3);
			PushFollow(Follow._typeBlock_in_interfaceDefinition996);
			typeBlock46=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock46.Tree);


			{
			// AST REWRITE
			// elements: modifiers, INTERFACE, ident, interfaceExtendsClause, typeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 199:3: -> ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock )
			{
				DebugLocation(199, 6);
				// AS3.g:199:6: ^( INTERFACE_DEF modifiers INTERFACE ident ( interfaceExtendsClause )? typeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(199, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

				DebugLocation(199, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(199, 32);
				adaptor.AddChild(root_1, stream_INTERFACE.NextNode());
				DebugLocation(199, 42);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(199, 48);
				// AS3.g:199:48: ( interfaceExtendsClause )?
				if (stream_interfaceExtendsClause.HasNext)
				{
					DebugLocation(199, 48);
					adaptor.AddChild(root_1, stream_interfaceExtendsClause.NextTree());

				}
				stream_interfaceExtendsClause.Reset();
				DebugLocation(199, 72);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interfaceDefinition", 12);
			LeaveRule("interfaceDefinition", 12);
			LeaveRule_interfaceDefinition();
		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "interfaceDefinition"); }
		return retval;

	}
	// $ANTLR end "interfaceDefinition"

	partial void EnterRule_as2InterfaceDefinition();
	partial void LeaveRule_as2InterfaceDefinition();
	// $ANTLR start "as2InterfaceDefinition"
	// AS3.g:202:1: as2InterfaceDefinition : modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock ) ;
	[GrammarRule("as2InterfaceDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> as2InterfaceDefinition()
	{
		EnterRule_as2InterfaceDefinition();
		EnterRule("as2InterfaceDefinition", 13);
		TraceIn("as2InterfaceDefinition", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INTERFACE48 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers47 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> interfaceExtendsClause50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeBlock51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INTERFACE48_tree = default(CommonTree);
		RewriteRuleITokenStream stream_INTERFACE=new RewriteRuleITokenStream(adaptor,"token INTERFACE");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		RewriteRuleSubtreeStream stream_interfaceExtendsClause=new RewriteRuleSubtreeStream(adaptor,"rule interfaceExtendsClause");
		RewriteRuleSubtreeStream stream_typeBlock=new RewriteRuleSubtreeStream(adaptor,"rule typeBlock");
		try { DebugEnterRule(GrammarFileName, "as2InterfaceDefinition");
		DebugLocation(202, 1);
		try
		{
			// AS3.g:203:2: ( modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock ) )
			DebugEnterAlt(1);
			// AS3.g:203:4: modifiers INTERFACE identifier ( interfaceExtendsClause )? typeBlock
			{
			DebugLocation(203, 4);
			PushFollow(Follow._modifiers_in_as2InterfaceDefinition1026);
			modifiers47=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers47.Tree);
			DebugLocation(204, 3);
			INTERFACE48=(IToken)Match(input,INTERFACE,Follow._INTERFACE_in_as2InterfaceDefinition1030); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INTERFACE.Add(INTERFACE48);

			DebugLocation(204, 13);
			PushFollow(Follow._identifier_in_as2InterfaceDefinition1032);
			identifier49=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier49.Tree);
			DebugLocation(205, 3);
			// AS3.g:205:3: ( interfaceExtendsClause )?
			int alt13=2;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			int LA13_1 = input.LA(1);

			if ((LA13_1==EXTENDS))
			{
				alt13 = 1;
			}
			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:205:3: interfaceExtendsClause
				{
				DebugLocation(205, 3);
				PushFollow(Follow._interfaceExtendsClause_in_as2InterfaceDefinition1036);
				interfaceExtendsClause50=interfaceExtendsClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_interfaceExtendsClause.Add(interfaceExtendsClause50.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(13); }

			DebugLocation(206, 3);
			PushFollow(Follow._typeBlock_in_as2InterfaceDefinition1041);
			typeBlock51=typeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_typeBlock.Add(typeBlock51.Tree);


			{
			// AST REWRITE
			// elements: modifiers, identifier, interfaceExtendsClause, typeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 207:3: -> ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock )
			{
				DebugLocation(207, 6);
				// AS3.g:207:6: ^( INTERFACE_DEF modifiers identifier ( interfaceExtendsClause )? typeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(207, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INTERFACE_DEF, "INTERFACE_DEF"), root_1);

				DebugLocation(207, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(207, 32);
				adaptor.AddChild(root_1, stream_identifier.NextTree());
				DebugLocation(207, 43);
				// AS3.g:207:43: ( interfaceExtendsClause )?
				if (stream_interfaceExtendsClause.HasNext)
				{
					DebugLocation(207, 43);
					adaptor.AddChild(root_1, stream_interfaceExtendsClause.NextTree());

				}
				stream_interfaceExtendsClause.Reset();
				DebugLocation(207, 67);
				adaptor.AddChild(root_1, stream_typeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2InterfaceDefinition", 13);
			LeaveRule("as2InterfaceDefinition", 13);
			LeaveRule_as2InterfaceDefinition();
		}
		DebugLocation(208, 1);
		} finally { DebugExitRule(GrammarFileName, "as2InterfaceDefinition"); }
		return retval;

	}
	// $ANTLR end "as2InterfaceDefinition"

	partial void EnterRule_classExtendsClause();
	partial void LeaveRule_classExtendsClause();
	// $ANTLR start "classExtendsClause"
	// AS3.g:210:1: classExtendsClause : EXTENDS identifier -> ^( EXTENDS_CLAUSE EXTENDS identifier ) ;
	[GrammarRule("classExtendsClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> classExtendsClause()
	{
		EnterRule_classExtendsClause();
		EnterRule("classExtendsClause", 14);
		TraceIn("classExtendsClause", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EXTENDS52 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier53 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EXTENDS52_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "classExtendsClause");
		DebugLocation(210, 1);
		try
		{
			// AS3.g:211:2: ( EXTENDS identifier -> ^( EXTENDS_CLAUSE EXTENDS identifier ) )
			DebugEnterAlt(1);
			// AS3.g:211:4: EXTENDS identifier
			{
			DebugLocation(211, 4);
			EXTENDS52=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_classExtendsClause1069); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS52);

			DebugLocation(211, 12);
			PushFollow(Follow._identifier_in_classExtendsClause1071);
			identifier53=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier53.Tree);


			{
			// AST REWRITE
			// elements: EXTENDS, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 212:9: -> ^( EXTENDS_CLAUSE EXTENDS identifier )
			{
				DebugLocation(212, 12);
				// AS3.g:212:12: ^( EXTENDS_CLAUSE EXTENDS identifier )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(212, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXTENDS_CLAUSE, "EXTENDS_CLAUSE"), root_1);

				DebugLocation(212, 29);
				adaptor.AddChild(root_1, stream_EXTENDS.NextNode());
				DebugLocation(212, 37);
				adaptor.AddChild(root_1, stream_identifier.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("classExtendsClause", 14);
			LeaveRule("classExtendsClause", 14);
			LeaveRule_classExtendsClause();
		}
		DebugLocation(213, 1);
		} finally { DebugExitRule(GrammarFileName, "classExtendsClause"); }
		return retval;

	}
	// $ANTLR end "classExtendsClause"

	partial void EnterRule_interfaceExtendsClause();
	partial void LeaveRule_interfaceExtendsClause();
	// $ANTLR start "interfaceExtendsClause"
	// AS3.g:215:1: interfaceExtendsClause : EXTENDS identifier ( COMMA identifier )* -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ ) ;
	[GrammarRule("interfaceExtendsClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> interfaceExtendsClause()
	{
		EnterRule_interfaceExtendsClause();
		EnterRule("interfaceExtendsClause", 15);
		TraceIn("interfaceExtendsClause", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken EXTENDS54 = default(IToken);
		IToken COMMA56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier55 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier57 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree EXTENDS54_tree = default(CommonTree);
		CommonTree COMMA56_tree = default(CommonTree);
		RewriteRuleITokenStream stream_EXTENDS=new RewriteRuleITokenStream(adaptor,"token EXTENDS");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "interfaceExtendsClause");
		DebugLocation(215, 1);
		try
		{
			// AS3.g:216:2: ( EXTENDS identifier ( COMMA identifier )* -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ ) )
			DebugEnterAlt(1);
			// AS3.g:216:4: EXTENDS identifier ( COMMA identifier )*
			{
			DebugLocation(216, 4);
			EXTENDS54=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_interfaceExtendsClause1100); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EXTENDS.Add(EXTENDS54);

			DebugLocation(216, 12);
			PushFollow(Follow._identifier_in_interfaceExtendsClause1102);
			identifier55=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier55.Tree);
			DebugLocation(216, 23);
			// AS3.g:216:23: ( COMMA identifier )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if ((LA14_1==COMMA))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:216:25: COMMA identifier
					{
					DebugLocation(216, 25);
					COMMA56=(IToken)Match(input,COMMA,Follow._COMMA_in_interfaceExtendsClause1106); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA56);

					DebugLocation(216, 31);
					PushFollow(Follow._identifier_in_interfaceExtendsClause1108);
					identifier57=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier57.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }



			{
			// AST REWRITE
			// elements: EXTENDS, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 217:9: -> ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ )
			{
				DebugLocation(217, 12);
				// AS3.g:217:12: ^( EXTENDS_CLAUSE EXTENDS ( identifier )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(217, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXTENDS_CLAUSE, "EXTENDS_CLAUSE"), root_1);

				DebugLocation(217, 29);
				adaptor.AddChild(root_1, stream_EXTENDS.NextNode());
				DebugLocation(217, 37);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(217, 37);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("interfaceExtendsClause", 15);
			LeaveRule("interfaceExtendsClause", 15);
			LeaveRule_interfaceExtendsClause();
		}
		DebugLocation(218, 1);
		} finally { DebugExitRule(GrammarFileName, "interfaceExtendsClause"); }
		return retval;

	}
	// $ANTLR end "interfaceExtendsClause"

	partial void EnterRule_implementsClause();
	partial void LeaveRule_implementsClause();
	// $ANTLR start "implementsClause"
	// AS3.g:220:1: implementsClause : IMPLEMENTS identifier ( COMMA identifier )* -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ ) ;
	[GrammarRule("implementsClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> implementsClause()
	{
		EnterRule_implementsClause();
		EnterRule("implementsClause", 16);
		TraceIn("implementsClause", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IMPLEMENTS58 = default(IToken);
		IToken COMMA60 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> identifier59 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> identifier61 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IMPLEMENTS58_tree = default(CommonTree);
		CommonTree COMMA60_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IMPLEMENTS=new RewriteRuleITokenStream(adaptor,"token IMPLEMENTS");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "implementsClause");
		DebugLocation(220, 1);
		try
		{
			// AS3.g:221:2: ( IMPLEMENTS identifier ( COMMA identifier )* -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ ) )
			DebugEnterAlt(1);
			// AS3.g:221:4: IMPLEMENTS identifier ( COMMA identifier )*
			{
			DebugLocation(221, 4);
			IMPLEMENTS58=(IToken)Match(input,IMPLEMENTS,Follow._IMPLEMENTS_in_implementsClause1140); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IMPLEMENTS.Add(IMPLEMENTS58);

			DebugLocation(221, 15);
			PushFollow(Follow._identifier_in_implementsClause1142);
			identifier59=identifier();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_identifier.Add(identifier59.Tree);
			DebugLocation(221, 26);
			// AS3.g:221:26: ( COMMA identifier )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_1 = input.LA(1);

				if ((LA15_1==COMMA))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:221:28: COMMA identifier
					{
					DebugLocation(221, 28);
					COMMA60=(IToken)Match(input,COMMA,Follow._COMMA_in_implementsClause1146); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA60);

					DebugLocation(221, 34);
					PushFollow(Follow._identifier_in_implementsClause1148);
					identifier61=identifier();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_identifier.Add(identifier61.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }



			{
			// AST REWRITE
			// elements: IMPLEMENTS, identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 222:9: -> ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ )
			{
				DebugLocation(222, 12);
				// AS3.g:222:12: ^( IMPLEMENTS_CLAUSE IMPLEMENTS ( identifier )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(222, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(IMPLEMENTS_CLAUSE, "IMPLEMENTS_CLAUSE"), root_1);

				DebugLocation(222, 32);
				adaptor.AddChild(root_1, stream_IMPLEMENTS.NextNode());
				DebugLocation(222, 43);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(222, 43);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("implementsClause", 16);
			LeaveRule("implementsClause", 16);
			LeaveRule_implementsClause();
		}
		DebugLocation(223, 1);
		} finally { DebugExitRule(GrammarFileName, "implementsClause"); }
		return retval;

	}
	// $ANTLR end "implementsClause"

	partial void EnterRule_typeBlock();
	partial void LeaveRule_typeBlock();
	// $ANTLR start "typeBlock"
	// AS3.g:225:1: typeBlock : LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY ) ;
	[GrammarRule("typeBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> typeBlock()
	{
		EnterRule_typeBlock();
		EnterRule("typeBlock", 17);
		TraceIn("typeBlock", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY62 = default(IToken);
		IToken RCURLY64 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> typeBlockEntry63 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY62_tree = default(CommonTree);
		CommonTree RCURLY64_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_typeBlockEntry=new RewriteRuleSubtreeStream(adaptor,"rule typeBlockEntry");
		try { DebugEnterRule(GrammarFileName, "typeBlock");
		DebugLocation(225, 1);
		try
		{
			// AS3.g:226:2: ( LCURLY ( typeBlockEntry )* RCURLY -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// AS3.g:226:4: LCURLY ( typeBlockEntry )* RCURLY
			{
			DebugLocation(226, 4);
			LCURLY62=(IToken)Match(input,LCURLY,Follow._LCURLY_in_typeBlock1180); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY62);

			DebugLocation(227, 9);
			// AS3.g:227:9: ( typeBlockEntry )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1==AS||LA16_1==BNOT||LA16_1==BREAK||LA16_1==CONST||LA16_1==CONTINUE||(LA16_1>=DEC && LA16_1<=DECIMAL_LITERAL)||LA16_1==DEFAULT||LA16_1==DO||(LA16_1>=DYNAMIC && LA16_1<=E4X_ATTRI)||(LA16_1>=FALSE && LA16_1<=FOR)||LA16_1==FUNCTION||LA16_1==GET||(LA16_1>=HEX_LITERAL && LA16_1<=IDENT)||LA16_1==IF||LA16_1==IMPORT||LA16_1==INC||(LA16_1>=INTERNAL && LA16_1<=IS)||(LA16_1>=LBRACK && LA16_1<=LCURLY)||LA16_1==LNOT||LA16_1==LPAREN||LA16_1==MINUS||LA16_1==NAMESPACE||LA16_1==NEW||LA16_1==NULL||LA16_1==OCTAL_LITERAL||LA16_1==PLUS||LA16_1==PRIVATE||(LA16_1>=PROTECTED && LA16_1<=PUBLIC)||LA16_1==REGEX_LITERAL||LA16_1==RETURN||(LA16_1>=SEMI && LA16_1<=SET)||LA16_1==STATIC||(LA16_1>=STRING_LITERAL_DOUBLE && LA16_1<=SWITCH)||LA16_1==TRUE||(LA16_1>=USE && LA16_1<=VAR)||LA16_1==WHILE||LA16_1==WITH||LA16_1==XML||LA16_1==XML_LITERAL||(LA16_1>=243 && LA16_1<=246)||LA16_1==248||LA16_1==250||(LA16_1>=252 && LA16_1<=257)))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:227:9: typeBlockEntry
					{
					DebugLocation(227, 9);
					PushFollow(Follow._typeBlockEntry_in_typeBlock1190);
					typeBlockEntry63=typeBlockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_typeBlockEntry.Add(typeBlockEntry63.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(228, 3);
			RCURLY64=(IToken)Match(input,RCURLY,Follow._RCURLY_in_typeBlock1195); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY64);



			{
			// AST REWRITE
			// elements: LCURLY, typeBlockEntry, RCURLY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 229:3: -> ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY )
			{
				DebugLocation(229, 6);
				// AS3.g:229:6: ^( TYPE_BLOCK LCURLY ( typeBlockEntry )* RCURLY )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(229, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE_BLOCK, "TYPE_BLOCK"), root_1);

				DebugLocation(229, 19);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(229, 26);
				// AS3.g:229:26: ( typeBlockEntry )*
				while ( stream_typeBlockEntry.HasNext )
				{
					DebugLocation(229, 26);
					adaptor.AddChild(root_1, stream_typeBlockEntry.NextTree());

				}
				stream_typeBlockEntry.Reset();
				DebugLocation(229, 42);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeBlock", 17);
			LeaveRule("typeBlock", 17);
			LeaveRule_typeBlock();
		}
		DebugLocation(230, 1);
		} finally { DebugExitRule(GrammarFileName, "typeBlock"); }
		return retval;

	}
	// $ANTLR end "typeBlock"

	partial void EnterRule_typeBlockEntry();
	partial void LeaveRule_typeBlockEntry();
	// $ANTLR start "typeBlockEntry"
	// AS3.g:232:1: typeBlockEntry options {k=2; } : ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement );
	[GrammarRule("typeBlockEntry")]
	private AstParserRuleReturnScope<CommonTree, IToken> typeBlockEntry()
	{
		EnterRule_typeBlockEntry();
		EnterRule("typeBlockEntry", 18);
		TraceIn("typeBlockEntry", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> includeDirective65 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> importDefinition66 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> annotation67 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDefinition68 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> methodDefinition69 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement70 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_variableDefinition=new RewriteRuleSubtreeStream(adaptor,"rule variableDefinition");
		RewriteRuleSubtreeStream stream_methodDefinition=new RewriteRuleSubtreeStream(adaptor,"rule methodDefinition");
		try { DebugEnterRule(GrammarFileName, "typeBlockEntry");
		DebugLocation(232, 1);
		try
		{
			// AS3.g:233:2: ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement )
			int alt17=6;
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:234:7: includeDirective
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(234, 7);
				PushFollow(Follow._includeDirective_in_typeBlockEntry1237);
				includeDirective65=includeDirective();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, includeDirective65.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:235:4: importDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(235, 4);
				PushFollow(Follow._importDefinition_in_typeBlockEntry1242);
				importDefinition66=importDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, importDefinition66.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:236:4: ( LBRACK IDENT )=> annotation
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(236, 22);
				PushFollow(Follow._annotation_in_typeBlockEntry1255);
				annotation67=annotation();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, annotation67.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:237:4: ( modifiers varOrConst )=> variableDefinition
				{
				DebugLocation(237, 31);
				PushFollow(Follow._variableDefinition_in_typeBlockEntry1269);
				variableDefinition68=variableDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDefinition.Add(variableDefinition68.Tree);


				{
				// AST REWRITE
				// elements: variableDefinition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 237:50: -> ^( CLASS_MEMBER variableDefinition )
				{
					DebugLocation(237, 53);
					// AS3.g:237:53: ^( CLASS_MEMBER variableDefinition )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(237, 55);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CLASS_MEMBER, "CLASS_MEMBER"), root_1);

					DebugLocation(237, 68);
					adaptor.AddChild(root_1, stream_variableDefinition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:238:4: ( modifiers FUNCTION )=> methodDefinition
				{
				DebugLocation(238, 28);
				PushFollow(Follow._methodDefinition_in_typeBlockEntry1290);
				methodDefinition69=methodDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_methodDefinition.Add(methodDefinition69.Tree);


				{
				// AST REWRITE
				// elements: methodDefinition
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 238:45: -> ^( CLASS_MEMBER methodDefinition )
				{
					DebugLocation(238, 48);
					// AS3.g:238:48: ^( CLASS_MEMBER methodDefinition )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(238, 50);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CLASS_MEMBER, "CLASS_MEMBER"), root_1);

					DebugLocation(238, 63);
					adaptor.AddChild(root_1, stream_methodDefinition.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:239:4: statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(239, 4);
				PushFollow(Follow._statement_in_typeBlockEntry1303);
				statement70=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement70.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeBlockEntry", 18);
			LeaveRule("typeBlockEntry", 18);
			LeaveRule_typeBlockEntry();
		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "typeBlockEntry"); }
		return retval;

	}
	// $ANTLR end "typeBlockEntry"

	partial void EnterRule_as2IncludeDirective();
	partial void LeaveRule_as2IncludeDirective();
	// $ANTLR start "as2IncludeDirective"
	// AS3.g:242:1: as2IncludeDirective : INCLUDE_DIRECTIVE stringLiteral ;
	[GrammarRule("as2IncludeDirective")]
	private AstParserRuleReturnScope<CommonTree, IToken> as2IncludeDirective()
	{
		EnterRule_as2IncludeDirective();
		EnterRule("as2IncludeDirective", 19);
		TraceIn("as2IncludeDirective", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INCLUDE_DIRECTIVE71 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> stringLiteral72 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree INCLUDE_DIRECTIVE71_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "as2IncludeDirective");
		DebugLocation(242, 1);
		try
		{
			// AS3.g:243:2: ( INCLUDE_DIRECTIVE stringLiteral )
			DebugEnterAlt(1);
			// AS3.g:243:4: INCLUDE_DIRECTIVE stringLiteral
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(243, 4);
			INCLUDE_DIRECTIVE71=(IToken)Match(input,INCLUDE_DIRECTIVE,Follow._INCLUDE_DIRECTIVE_in_as2IncludeDirective1314); if (state.failed) return retval;
			if (state.backtracking == 0) {
			INCLUDE_DIRECTIVE71_tree = (CommonTree)adaptor.Create(INCLUDE_DIRECTIVE71);
			adaptor.AddChild(root_0, INCLUDE_DIRECTIVE71_tree);
			}
			DebugLocation(244, 3);
			PushFollow(Follow._stringLiteral_in_as2IncludeDirective1318);
			stringLiteral72=stringLiteral();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteral72.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("as2IncludeDirective", 19);
			LeaveRule("as2IncludeDirective", 19);
			LeaveRule_as2IncludeDirective();
		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "as2IncludeDirective"); }
		return retval;

	}
	// $ANTLR end "as2IncludeDirective"

	partial void EnterRule_includeDirective();
	partial void LeaveRule_includeDirective();
	// $ANTLR start "includeDirective"
	// AS3.g:247:1: includeDirective : 'include' stringLiteral s= semi -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral ) ;
	[GrammarRule("includeDirective")]
	private AstParserRuleReturnScope<CommonTree, IToken> includeDirective()
	{
		EnterRule_includeDirective();
		EnterRule("includeDirective", 20);
		TraceIn("includeDirective", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal73 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stringLiteral74 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_248=new RewriteRuleITokenStream(adaptor,"token 248");
		RewriteRuleSubtreeStream stream_stringLiteral=new RewriteRuleSubtreeStream(adaptor,"rule stringLiteral");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "includeDirective");
		DebugLocation(247, 1);
		try
		{
			// AS3.g:248:2: ( 'include' stringLiteral s= semi -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral ) )
			DebugEnterAlt(1);
			// AS3.g:248:4: 'include' stringLiteral s= semi
			{
			DebugLocation(248, 4);
			string_literal73=(IToken)Match(input,248,Follow._248_in_includeDirective1329); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_248.Add(string_literal73);

			DebugLocation(248, 14);
			PushFollow(Follow._stringLiteral_in_includeDirective1331);
			stringLiteral74=stringLiteral();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_stringLiteral.Add(stringLiteral74.Tree);
			DebugLocation(248, 29);
			PushFollow(Follow._semi_in_includeDirective1335);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: 248, stringLiteral
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 249:9: -> ^( INCLUDE_DIRECTIVE 'include' stringLiteral )
			{
				DebugLocation(249, 12);
				// AS3.g:249:12: ^( INCLUDE_DIRECTIVE 'include' stringLiteral )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(249, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(INCLUDE_DIRECTIVE, "INCLUDE_DIRECTIVE"), root_1);

				DebugLocation(249, 32);
				adaptor.AddChild(root_1, stream_248.NextNode());
				DebugLocation(249, 42);
				adaptor.AddChild(root_1, stream_stringLiteral.NextTree());
				DebugLocation(249, 56);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("includeDirective", 20);
			LeaveRule("includeDirective", 20);
			LeaveRule_includeDirective();
		}
		DebugLocation(250, 1);
		} finally { DebugExitRule(GrammarFileName, "includeDirective"); }
		return retval;

	}
	// $ANTLR end "includeDirective"

	partial void EnterRule_methodDefinition();
	partial void LeaveRule_methodDefinition();
	// $ANTLR start "methodDefinition"
	// AS3.g:253:1: methodDefinition : modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock ) ;
	[GrammarRule("methodDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> methodDefinition()
	{
		EnterRule_methodDefinition();
		EnterRule("methodDefinition", 21);
		TraceIn("methodDefinition", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken FUNCTION76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers75 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> accessorRole77 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> methodName78 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameterDeclarationList79 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression80 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> maybeBlock81 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FUNCTION76_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_accessorRole=new RewriteRuleSubtreeStream(adaptor,"rule accessorRole");
		RewriteRuleSubtreeStream stream_methodName=new RewriteRuleSubtreeStream(adaptor,"rule methodName");
		RewriteRuleSubtreeStream stream_parameterDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_maybeBlock=new RewriteRuleSubtreeStream(adaptor,"rule maybeBlock");
		try { DebugEnterRule(GrammarFileName, "methodDefinition");
		DebugLocation(253, 1);
		try
		{
			// AS3.g:254:2: ( modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock ) )
			DebugEnterAlt(1);
			// AS3.g:255:3: modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock
			{
			DebugLocation(255, 3);
			PushFollow(Follow._modifiers_in_methodDefinition1369);
			modifiers75=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers75.Tree);
			DebugLocation(256, 3);
			FUNCTION76=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_methodDefinition1373); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION76);

			DebugLocation(257, 9);
			// AS3.g:257:9: ( accessorRole )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_1 = input.LA(1);

			if ((LA18_1==GET))
			{
				int LA18_2 = input.LA(2);

				if ((LA18_2==AS||LA18_2==DYNAMIC||LA18_2==GET||LA18_2==IDENT||LA18_2==IS||LA18_2==NAMESPACE||LA18_2==SET||LA18_2==SUPER||LA18_2==USE||LA18_2==XML))
				{
					alt18 = 1;
				}
			}
			else if ((LA18_1==SET))
			{
				int LA18_2 = input.LA(2);

				if ((LA18_2==AS||LA18_2==DYNAMIC||LA18_2==GET||LA18_2==IDENT||LA18_2==IS||LA18_2==NAMESPACE||LA18_2==SET||LA18_2==SUPER||LA18_2==USE||LA18_2==XML))
				{
					alt18 = 1;
				}
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:257:9: accessorRole
				{
				DebugLocation(257, 9);
				PushFollow(Follow._accessorRole_in_methodDefinition1383);
				accessorRole77=accessorRole();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_accessorRole.Add(accessorRole77.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(258, 3);
			PushFollow(Follow._methodName_in_methodDefinition1388);
			methodName78=methodName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_methodName.Add(methodName78.Tree);
			DebugLocation(259, 3);
			PushFollow(Follow._parameterDeclarationList_in_methodDefinition1392);
			parameterDeclarationList79=parameterDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList79.Tree);
			DebugLocation(260, 3);
			// AS3.g:260:3: ( typeExpression )?
			int alt19=2;
			try { DebugEnterSubRule(19);
			try { DebugEnterDecision(19, false);
			int LA19_1 = input.LA(1);

			if ((LA19_1==COLON))
			{
				alt19 = 1;
			}
			} finally { DebugExitDecision(19); }
			switch (alt19)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:260:3: typeExpression
				{
				DebugLocation(260, 3);
				PushFollow(Follow._typeExpression_in_methodDefinition1396);
				typeExpression80=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression80.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(19); }

			DebugLocation(261, 9);
			PushFollow(Follow._maybeBlock_in_methodDefinition1407);
			maybeBlock81=maybeBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_maybeBlock.Add(maybeBlock81.Tree);


			{
			// AST REWRITE
			// elements: modifiers, FUNCTION, accessorRole, methodName, parameterDeclarationList, typeExpression, maybeBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 262:3: -> ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock )
			{
				DebugLocation(262, 6);
				// AS3.g:262:6: ^( METHOD_DEF modifiers FUNCTION ( accessorRole )? methodName parameterDeclarationList ( typeExpression )? maybeBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(262, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(METHOD_DEF, "METHOD_DEF"), root_1);

				DebugLocation(262, 19);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(262, 29);
				adaptor.AddChild(root_1, stream_FUNCTION.NextNode());
				DebugLocation(262, 38);
				// AS3.g:262:38: ( accessorRole )?
				if (stream_accessorRole.HasNext)
				{
					DebugLocation(262, 38);
					adaptor.AddChild(root_1, stream_accessorRole.NextTree());

				}
				stream_accessorRole.Reset();
				DebugLocation(263, 17);
				adaptor.AddChild(root_1, stream_methodName.NextTree());
				DebugLocation(264, 5);
				adaptor.AddChild(root_1, stream_parameterDeclarationList.NextTree());
				DebugLocation(265, 5);
				// AS3.g:265:5: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(265, 5);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(266, 5);
				adaptor.AddChild(root_1, stream_maybeBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodDefinition", 21);
			LeaveRule("methodDefinition", 21);
			LeaveRule_methodDefinition();
		}
		DebugLocation(268, 1);
		} finally { DebugExitRule(GrammarFileName, "methodDefinition"); }
		return retval;

	}
	// $ANTLR end "methodDefinition"

	partial void EnterRule_maybeBlock();
	partial void LeaveRule_maybeBlock();
	// $ANTLR start "maybeBlock"
	// AS3.g:270:1: maybeBlock options {k=1; } : ( ( LCURLY )=> block |);
	[GrammarRule("maybeBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> maybeBlock()
	{
		EnterRule_maybeBlock();
		EnterRule("maybeBlock", 22);
		TraceIn("maybeBlock", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block82 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "maybeBlock");
		DebugLocation(270, 4);
		try
		{
			// AS3.g:271:5: ( ( LCURLY )=> block |)
			int alt20=2;
			try { DebugEnterDecision(20, false);
			try
			{
				alt20 = dfa20.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:272:5: ( LCURLY )=> block
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(272, 17);
				PushFollow(Follow._block_in_maybeBlock1501);
				block82=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block82.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:274:5: 
				{
				root_0 = (CommonTree)adaptor.Nil();

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("maybeBlock", 22);
			LeaveRule("maybeBlock", 22);
			LeaveRule_maybeBlock();
		}
		DebugLocation(274, 4);
		} finally { DebugExitRule(GrammarFileName, "maybeBlock"); }
		return retval;

	}
	// $ANTLR end "maybeBlock"

	partial void EnterRule_methodName();
	partial void LeaveRule_methodName();
	// $ANTLR start "methodName"
	// AS3.g:276:1: methodName : ident -> ^( METHOD_NAME ident ) ;
	[GrammarRule("methodName")]
	private AstParserRuleReturnScope<CommonTree, IToken> methodName()
	{
		EnterRule_methodName();
		EnterRule("methodName", 23);
		TraceIn("methodName", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> ident83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "methodName");
		DebugLocation(276, 4);
		try
		{
			// AS3.g:277:5: ( ident -> ^( METHOD_NAME ident ) )
			DebugEnterAlt(1);
			// AS3.g:277:7: ident
			{
			DebugLocation(277, 7);
			PushFollow(Follow._ident_in_methodName1527);
			ident83=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident83.Tree);


			{
			// AST REWRITE
			// elements: ident
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 278:9: -> ^( METHOD_NAME ident )
			{
				DebugLocation(278, 12);
				// AS3.g:278:12: ^( METHOD_NAME ident )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(278, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(METHOD_NAME, "METHOD_NAME"), root_1);

				DebugLocation(278, 26);
				adaptor.AddChild(root_1, stream_ident.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("methodName", 23);
			LeaveRule("methodName", 23);
			LeaveRule_methodName();
		}
		DebugLocation(279, 4);
		} finally { DebugExitRule(GrammarFileName, "methodName"); }
		return retval;

	}
	// $ANTLR end "methodName"

	partial void EnterRule_accessorRole();
	partial void LeaveRule_accessorRole();
	// $ANTLR start "accessorRole"
	// AS3.g:282:1: accessorRole : ( GET | SET );
	[GrammarRule("accessorRole")]
	private AstParserRuleReturnScope<CommonTree, IToken> accessorRole()
	{
		EnterRule_accessorRole();
		EnterRule("accessorRole", 24);
		TraceIn("accessorRole", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set84 = default(IToken);

		CommonTree set84_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "accessorRole");
		DebugLocation(282, 1);
		try
		{
			// AS3.g:283:2: ( GET | SET )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(283, 2);

			set84=(IToken)input.LT(1);
			if (input.LA(1)==GET||input.LA(1)==SET)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set84));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("accessorRole", 24);
			LeaveRule("accessorRole", 24);
			LeaveRule_accessorRole();
		}
		DebugLocation(284, 1);
		} finally { DebugExitRule(GrammarFileName, "accessorRole"); }
		return retval;

	}
	// $ANTLR end "accessorRole"

	partial void EnterRule_namespaceDefinition();
	partial void LeaveRule_namespaceDefinition();
	// $ANTLR start "namespaceDefinition"
	// AS3.g:286:1: namespaceDefinition : modifiers NAMESPACE namespaceName -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName ) ;
	[GrammarRule("namespaceDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> namespaceDefinition()
	{
		EnterRule_namespaceDefinition();
		EnterRule("namespaceDefinition", 25);
		TraceIn("namespaceDefinition", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NAMESPACE86 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers85 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> namespaceName87 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NAMESPACE86_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NAMESPACE=new RewriteRuleITokenStream(adaptor,"token NAMESPACE");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_namespaceName=new RewriteRuleSubtreeStream(adaptor,"rule namespaceName");
		try { DebugEnterRule(GrammarFileName, "namespaceDefinition");
		DebugLocation(286, 1);
		try
		{
			// AS3.g:287:2: ( modifiers NAMESPACE namespaceName -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName ) )
			DebugEnterAlt(1);
			// AS3.g:287:4: modifiers NAMESPACE namespaceName
			{
			DebugLocation(287, 4);
			PushFollow(Follow._modifiers_in_namespaceDefinition1573);
			modifiers85=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers85.Tree);
			DebugLocation(287, 14);
			NAMESPACE86=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_namespaceDefinition1575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NAMESPACE.Add(NAMESPACE86);

			DebugLocation(287, 24);
			PushFollow(Follow._namespaceName_in_namespaceDefinition1577);
			namespaceName87=namespaceName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_namespaceName.Add(namespaceName87.Tree);


			{
			// AST REWRITE
			// elements: modifiers, NAMESPACE, namespaceName
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 288:3: -> ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName )
			{
				DebugLocation(288, 6);
				// AS3.g:288:6: ^( NAMESPACE_DEF modifiers NAMESPACE namespaceName )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(288, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAMESPACE_DEF, "NAMESPACE_DEF"), root_1);

				DebugLocation(288, 22);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(288, 32);
				adaptor.AddChild(root_1, stream_NAMESPACE.NextNode());
				DebugLocation(288, 42);
				adaptor.AddChild(root_1, stream_namespaceName.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespaceDefinition", 25);
			LeaveRule("namespaceDefinition", 25);
			LeaveRule_namespaceDefinition();
		}
		DebugLocation(289, 1);
		} finally { DebugExitRule(GrammarFileName, "namespaceDefinition"); }
		return retval;

	}
	// $ANTLR end "namespaceDefinition"

	partial void EnterRule_useNamespaceDirective();
	partial void LeaveRule_useNamespaceDirective();
	// $ANTLR start "useNamespaceDirective"
	// AS3.g:291:1: useNamespaceDirective : USE NAMESPACE namespaceName semi ;
	[GrammarRule("useNamespaceDirective")]
	private AstParserRuleReturnScope<CommonTree, IToken> useNamespaceDirective()
	{
		EnterRule_useNamespaceDirective();
		EnterRule("useNamespaceDirective", 26);
		TraceIn("useNamespaceDirective", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken USE88 = default(IToken);
		IToken NAMESPACE89 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> namespaceName90 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi91 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree USE88_tree = default(CommonTree);
		CommonTree NAMESPACE89_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "useNamespaceDirective");
		DebugLocation(291, 1);
		try
		{
			// AS3.g:292:2: ( USE NAMESPACE namespaceName semi )
			DebugEnterAlt(1);
			// AS3.g:292:4: USE NAMESPACE namespaceName semi
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(292, 4);
			USE88=(IToken)Match(input,USE,Follow._USE_in_useNamespaceDirective1602); if (state.failed) return retval;
			if (state.backtracking == 0) {
			USE88_tree = (CommonTree)adaptor.Create(USE88);
			adaptor.AddChild(root_0, USE88_tree);
			}
			DebugLocation(292, 8);
			NAMESPACE89=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_useNamespaceDirective1604); if (state.failed) return retval;
			if (state.backtracking == 0) {
			NAMESPACE89_tree = (CommonTree)adaptor.Create(NAMESPACE89);
			adaptor.AddChild(root_0, NAMESPACE89_tree);
			}
			DebugLocation(292, 18);
			PushFollow(Follow._namespaceName_in_useNamespaceDirective1606);
			namespaceName90=namespaceName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceName90.Tree);
			DebugLocation(292, 32);
			PushFollow(Follow._semi_in_useNamespaceDirective1608);
			semi91=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi91.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("useNamespaceDirective", 26);
			LeaveRule("useNamespaceDirective", 26);
			LeaveRule_useNamespaceDirective();
		}
		DebugLocation(293, 1);
		} finally { DebugExitRule(GrammarFileName, "useNamespaceDirective"); }
		return retval;

	}
	// $ANTLR end "useNamespaceDirective"

	partial void EnterRule_variableDefinition();
	partial void LeaveRule_variableDefinition();
	// $ANTLR start "variableDefinition"
	// AS3.g:295:1: variableDefinition : modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ ) ;
	[GrammarRule("variableDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDefinition()
	{
		EnterRule_variableDefinition();
		EnterRule("variableDefinition", 27);
		TraceIn("variableDefinition", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA94 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> decl = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> modifiers92 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarator93 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarator95 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA94_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_modifiers=new RewriteRuleSubtreeStream(adaptor,"rule modifiers");
		RewriteRuleSubtreeStream stream_varOrConst=new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
		RewriteRuleSubtreeStream stream_variableDeclarator=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "variableDefinition");
		DebugLocation(295, 1);
		try
		{
			// AS3.g:296:2: ( modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ ) )
			DebugEnterAlt(1);
			// AS3.g:296:4: modifiers decl= varOrConst variableDeclarator ( COMMA variableDeclarator )* s= semi
			{
			DebugLocation(296, 4);
			PushFollow(Follow._modifiers_in_variableDefinition1619);
			modifiers92=modifiers();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_modifiers.Add(modifiers92.Tree);
			DebugLocation(297, 7);
			PushFollow(Follow._varOrConst_in_variableDefinition1625);
			decl=varOrConst();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varOrConst.Add(decl.Tree);
			DebugLocation(297, 19);
			PushFollow(Follow._variableDeclarator_in_variableDefinition1627);
			variableDeclarator93=variableDeclarator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator93.Tree);
			DebugLocation(298, 3);
			// AS3.g:298:3: ( COMMA variableDeclarator )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==COMMA))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:298:4: COMMA variableDeclarator
					{
					DebugLocation(298, 4);
					COMMA94=(IToken)Match(input,COMMA,Follow._COMMA_in_variableDefinition1632); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA94);

					DebugLocation(298, 10);
					PushFollow(Follow._variableDeclarator_in_variableDefinition1634);
					variableDeclarator95=variableDeclarator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator95.Tree);

					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(299, 4);
			PushFollow(Follow._semi_in_variableDefinition1642);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: modifiers, decl, variableDeclarator
			// token labels: 
			// rule labels: decl, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl",decl!=null?decl.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 300:3: -> ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ )
			{
				DebugLocation(300, 6);
				// AS3.g:300:6: ^( VARIABLE_DEF modifiers $decl ( variableDeclarator )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(300, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VARIABLE_DEF, "VARIABLE_DEF"), root_1);

				DebugLocation(300, 21);
				adaptor.AddChild(root_1, stream_modifiers.NextTree());
				DebugLocation(300, 32);
				adaptor.AddChild(root_1, stream_decl.NextTree());
				DebugLocation(300, 37);
				if (!(stream_variableDeclarator.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclarator.HasNext )
				{
					DebugLocation(300, 37);
					adaptor.AddChild(root_1, stream_variableDeclarator.NextTree());

				}
				stream_variableDeclarator.Reset();
				DebugLocation(300, 57);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDefinition", 27);
			LeaveRule("variableDefinition", 27);
			LeaveRule_variableDefinition();
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDefinition"); }
		return retval;

	}
	// $ANTLR end "variableDefinition"

	partial void EnterRule_declaration();
	partial void LeaveRule_declaration();
	// $ANTLR start "declaration"
	// AS3.g:303:1: declaration : varOrConst variableDeclarator declarationTail -> ^( DECLARATION varOrConst variableDeclarator declarationTail ) ;
	[GrammarRule("declaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> declaration()
	{
		EnterRule_declaration();
		EnterRule("declaration", 28);
		TraceIn("declaration", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> varOrConst96 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarator97 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> declarationTail98 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_varOrConst=new RewriteRuleSubtreeStream(adaptor,"rule varOrConst");
		RewriteRuleSubtreeStream stream_variableDeclarator=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarator");
		RewriteRuleSubtreeStream stream_declarationTail=new RewriteRuleSubtreeStream(adaptor,"rule declarationTail");
		try { DebugEnterRule(GrammarFileName, "declaration");
		DebugLocation(303, 1);
		try
		{
			// AS3.g:304:2: ( varOrConst variableDeclarator declarationTail -> ^( DECLARATION varOrConst variableDeclarator declarationTail ) )
			DebugEnterAlt(1);
			// AS3.g:304:4: varOrConst variableDeclarator declarationTail
			{
			DebugLocation(304, 4);
			PushFollow(Follow._varOrConst_in_declaration1671);
			varOrConst96=varOrConst();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_varOrConst.Add(varOrConst96.Tree);
			DebugLocation(304, 15);
			PushFollow(Follow._variableDeclarator_in_declaration1673);
			variableDeclarator97=variableDeclarator();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarator.Add(variableDeclarator97.Tree);
			DebugLocation(304, 34);
			PushFollow(Follow._declarationTail_in_declaration1675);
			declarationTail98=declarationTail();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declarationTail.Add(declarationTail98.Tree);


			{
			// AST REWRITE
			// elements: varOrConst, variableDeclarator, declarationTail
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 305:9: -> ^( DECLARATION varOrConst variableDeclarator declarationTail )
			{
				DebugLocation(305, 12);
				// AS3.g:305:12: ^( DECLARATION varOrConst variableDeclarator declarationTail )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(305, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DECLARATION, "DECLARATION"), root_1);

				DebugLocation(305, 26);
				adaptor.AddChild(root_1, stream_varOrConst.NextTree());
				DebugLocation(305, 37);
				adaptor.AddChild(root_1, stream_variableDeclarator.NextTree());
				DebugLocation(305, 56);
				adaptor.AddChild(root_1, stream_declarationTail.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declaration", 28);
			LeaveRule("declaration", 28);
			LeaveRule_declaration();
		}
		DebugLocation(306, 1);
		} finally { DebugExitRule(GrammarFileName, "declaration"); }
		return retval;

	}
	// $ANTLR end "declaration"

	partial void EnterRule_varOrConst();
	partial void LeaveRule_varOrConst();
	// $ANTLR start "varOrConst"
	// AS3.g:308:1: varOrConst : ( VAR | CONST );
	[GrammarRule("varOrConst")]
	private AstParserRuleReturnScope<CommonTree, IToken> varOrConst()
	{
		EnterRule_varOrConst();
		EnterRule("varOrConst", 29);
		TraceIn("varOrConst", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set99 = default(IToken);

		CommonTree set99_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "varOrConst");
		DebugLocation(308, 1);
		try
		{
			// AS3.g:309:2: ( VAR | CONST )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(309, 2);

			set99=(IToken)input.LT(1);
			if (input.LA(1)==CONST||input.LA(1)==VAR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set99));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("varOrConst", 29);
			LeaveRule("varOrConst", 29);
			LeaveRule_varOrConst();
		}
		DebugLocation(310, 1);
		} finally { DebugExitRule(GrammarFileName, "varOrConst"); }
		return retval;

	}
	// $ANTLR end "varOrConst"

	partial void EnterRule_declarationTail();
	partial void LeaveRule_declarationTail();
	// $ANTLR start "declarationTail"
	// AS3.g:312:1: declarationTail : ( COMMA variableDeclarator )* ;
	[GrammarRule("declarationTail")]
	private AstParserRuleReturnScope<CommonTree, IToken> declarationTail()
	{
		EnterRule_declarationTail();
		EnterRule("declarationTail", 30);
		TraceIn("declarationTail", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA100 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarator101 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA100_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "declarationTail");
		DebugLocation(312, 1);
		try
		{
			// AS3.g:313:2: ( ( COMMA variableDeclarator )* )
			DebugEnterAlt(1);
			// AS3.g:313:4: ( COMMA variableDeclarator )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(313, 4);
			// AS3.g:313:4: ( COMMA variableDeclarator )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==COMMA))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:313:5: COMMA variableDeclarator
					{
					DebugLocation(313, 5);
					COMMA100=(IToken)Match(input,COMMA,Follow._COMMA_in_declarationTail1722); if (state.failed) return retval;
					if (state.backtracking == 0) {
					COMMA100_tree = (CommonTree)adaptor.Create(COMMA100);
					adaptor.AddChild(root_0, COMMA100_tree);
					}
					DebugLocation(313, 11);
					PushFollow(Follow._variableDeclarator_in_declarationTail1724);
					variableDeclarator101=variableDeclarator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, variableDeclarator101.Tree);

					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarationTail", 30);
			LeaveRule("declarationTail", 30);
			LeaveRule_declarationTail();
		}
		DebugLocation(314, 1);
		} finally { DebugExitRule(GrammarFileName, "declarationTail"); }
		return retval;

	}
	// $ANTLR end "declarationTail"

	partial void EnterRule_variableInitializer();
	partial void LeaveRule_variableInitializer();
	// $ANTLR start "variableInitializer"
	// AS3.g:316:1: variableInitializer : ASSIGN expression -> ^( VAR_INITIALIZER ASSIGN expression ) ;
	[GrammarRule("variableInitializer")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableInitializer()
	{
		EnterRule_variableInitializer();
		EnterRule("variableInitializer", 31);
		TraceIn("variableInitializer", 31);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ASSIGN102 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression103 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ASSIGN102_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "variableInitializer");
		DebugLocation(316, 1);
		try
		{
			// AS3.g:317:2: ( ASSIGN expression -> ^( VAR_INITIALIZER ASSIGN expression ) )
			DebugEnterAlt(1);
			// AS3.g:317:4: ASSIGN expression
			{
			DebugLocation(317, 4);
			ASSIGN102=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_variableInitializer1737); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN102);

			DebugLocation(317, 11);
			PushFollow(Follow._expression_in_variableInitializer1739);
			expression103=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression103.Tree);


			{
			// AST REWRITE
			// elements: ASSIGN, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 318:9: -> ^( VAR_INITIALIZER ASSIGN expression )
			{
				DebugLocation(318, 12);
				// AS3.g:318:12: ^( VAR_INITIALIZER ASSIGN expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(318, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_INITIALIZER, "VAR_INITIALIZER"), root_1);

				DebugLocation(318, 30);
				adaptor.AddChild(root_1, stream_ASSIGN.NextNode());
				DebugLocation(318, 37);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableInitializer", 31);
			LeaveRule("variableInitializer", 31);
			LeaveRule_variableInitializer();
		}
		DebugLocation(319, 1);
		} finally { DebugExitRule(GrammarFileName, "variableInitializer"); }
		return retval;

	}
	// $ANTLR end "variableInitializer"

	partial void EnterRule_variableDeclarator();
	partial void LeaveRule_variableDeclarator();
	// $ANTLR start "variableDeclarator"
	// AS3.g:321:1: variableDeclarator : ident ( typeExpression )? ( variableInitializer )? -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? ) ;
	[GrammarRule("variableDeclarator")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarator()
	{
		EnterRule_variableDeclarator();
		EnterRule("variableDeclarator", 32);
		TraceIn("variableDeclarator", 32);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> ident104 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression105 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableInitializer106 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_variableInitializer=new RewriteRuleSubtreeStream(adaptor,"rule variableInitializer");
		try { DebugEnterRule(GrammarFileName, "variableDeclarator");
		DebugLocation(321, 1);
		try
		{
			// AS3.g:322:2: ( ident ( typeExpression )? ( variableInitializer )? -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? ) )
			DebugEnterAlt(1);
			// AS3.g:322:4: ident ( typeExpression )? ( variableInitializer )?
			{
			DebugLocation(322, 4);
			PushFollow(Follow._ident_in_variableDeclarator1768);
			ident104=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident104.Tree);
			DebugLocation(322, 10);
			// AS3.g:322:10: ( typeExpression )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==COLON))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:322:10: typeExpression
				{
				DebugLocation(322, 10);
				PushFollow(Follow._typeExpression_in_variableDeclarator1770);
				typeExpression105=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression105.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(322, 26);
			// AS3.g:322:26: ( variableInitializer )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==ASSIGN))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:322:26: variableInitializer
				{
				DebugLocation(322, 26);
				PushFollow(Follow._variableInitializer_in_variableDeclarator1773);
				variableInitializer106=variableInitializer();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableInitializer.Add(variableInitializer106.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }



			{
			// AST REWRITE
			// elements: ident, typeExpression, variableInitializer
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 323:9: -> ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? )
			{
				DebugLocation(323, 12);
				// AS3.g:323:12: ^( VAR_DECLARATION ident ( typeExpression )? ( variableInitializer )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(323, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(VAR_DECLARATION, "VAR_DECLARATION"), root_1);

				DebugLocation(323, 30);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(323, 36);
				// AS3.g:323:36: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(323, 36);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(323, 52);
				// AS3.g:323:52: ( variableInitializer )?
				if (stream_variableInitializer.HasNext)
				{
					DebugLocation(323, 52);
					adaptor.AddChild(root_1, stream_variableInitializer.NextTree());

				}
				stream_variableInitializer.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarator", 32);
			LeaveRule("variableDeclarator", 32);
			LeaveRule_variableDeclarator();
		}
		DebugLocation(324, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarator"); }
		return retval;

	}
	// $ANTLR end "variableDeclarator"

	partial void EnterRule_parameterDeclarationList();
	partial void LeaveRule_parameterDeclarationList();
	// $ANTLR start "parameterDeclarationList"
	// AS3.g:329:1: parameterDeclarationList : LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN ) ;
	[GrammarRule("parameterDeclarationList")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameterDeclarationList()
	{
		EnterRule_parameterDeclarationList();
		EnterRule("parameterDeclarationList", 33);
		TraceIn("parameterDeclarationList", 33);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN107 = default(IToken);
		IToken COMMA109 = default(IToken);
		IToken RPAREN111 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> parameterDeclaration108 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameterDeclaration110 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN107_tree = default(CommonTree);
		CommonTree COMMA109_tree = default(CommonTree);
		CommonTree RPAREN111_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_parameterDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclaration");
		try { DebugEnterRule(GrammarFileName, "parameterDeclarationList");
		DebugLocation(329, 1);
		try
		{
			// AS3.g:330:2: ( LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN ) )
			DebugEnterAlt(1);
			// AS3.g:330:4: LPAREN ( parameterDeclaration ( COMMA parameterDeclaration )* )? RPAREN
			{
			DebugLocation(330, 4);
			LPAREN107=(IToken)Match(input,LPAREN,Follow._LPAREN_in_parameterDeclarationList1810); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN107);

			DebugLocation(331, 3);
			// AS3.g:331:3: ( parameterDeclaration ( COMMA parameterDeclaration )* )?
			int alt26=2;
			try { DebugEnterSubRule(26);
			try { DebugEnterDecision(26, false);
			int LA26_1 = input.LA(1);

			if ((LA26_1==AS||LA26_1==CONST||LA26_1==DYNAMIC||LA26_1==GET||LA26_1==IDENT||LA26_1==IS||LA26_1==NAMESPACE||LA26_1==REST||LA26_1==SET||LA26_1==SUPER||LA26_1==USE||LA26_1==XML))
			{
				alt26 = 1;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:331:5: parameterDeclaration ( COMMA parameterDeclaration )*
				{
				DebugLocation(331, 5);
				PushFollow(Follow._parameterDeclaration_in_parameterDeclarationList1816);
				parameterDeclaration108=parameterDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration108.Tree);
				DebugLocation(332, 4);
				// AS3.g:332:4: ( COMMA parameterDeclaration )*
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_1 = input.LA(1);

					if ((LA25_1==COMMA))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch ( alt25 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:332:5: COMMA parameterDeclaration
						{
						DebugLocation(332, 5);
						COMMA109=(IToken)Match(input,COMMA,Follow._COMMA_in_parameterDeclarationList1822); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA109);

						DebugLocation(332, 11);
						PushFollow(Follow._parameterDeclaration_in_parameterDeclarationList1824);
						parameterDeclaration110=parameterDeclaration();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_parameterDeclaration.Add(parameterDeclaration110.Tree);

						}
						break;

					default:
						goto loop25;
					}
				}

				loop25:
					;

				} finally { DebugExitSubRule(25); }


				}
				break;

			}
			} finally { DebugExitSubRule(26); }

			DebugLocation(334, 3);
			RPAREN111=(IToken)Match(input,RPAREN,Follow._RPAREN_in_parameterDeclarationList1835); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN111);



			{
			// AST REWRITE
			// elements: LPAREN, parameterDeclaration, RPAREN
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 335:3: -> ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN )
			{
				DebugLocation(335, 6);
				// AS3.g:335:6: ^( PARAMS LPAREN ( parameterDeclaration )* RPAREN )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(335, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAMS, "PARAMS"), root_1);

				DebugLocation(335, 15);
				adaptor.AddChild(root_1, stream_LPAREN.NextNode());
				DebugLocation(335, 22);
				// AS3.g:335:22: ( parameterDeclaration )*
				while ( stream_parameterDeclaration.HasNext )
				{
					DebugLocation(335, 22);
					adaptor.AddChild(root_1, stream_parameterDeclaration.NextTree());

				}
				stream_parameterDeclaration.Reset();
				DebugLocation(335, 44);
				adaptor.AddChild(root_1, stream_RPAREN.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDeclarationList", 33);
			LeaveRule("parameterDeclarationList", 33);
			LeaveRule_parameterDeclarationList();
		}
		DebugLocation(336, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDeclarationList"); }
		return retval;

	}
	// $ANTLR end "parameterDeclarationList"

	partial void EnterRule_parameterDeclaration();
	partial void LeaveRule_parameterDeclaration();
	// $ANTLR start "parameterDeclaration"
	// AS3.g:339:1: parameterDeclaration : ( basicParameterDeclaration | parameterRestDeclaration );
	[GrammarRule("parameterDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameterDeclaration()
	{
		EnterRule_parameterDeclaration();
		EnterRule("parameterDeclaration", 34);
		TraceIn("parameterDeclaration", 34);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> basicParameterDeclaration112 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameterRestDeclaration113 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "parameterDeclaration");
		DebugLocation(339, 1);
		try
		{
			// AS3.g:340:2: ( basicParameterDeclaration | parameterRestDeclaration )
			int alt27=2;
			try { DebugEnterDecision(27, false);
			int LA27_1 = input.LA(1);

			if ((LA27_1==AS||LA27_1==CONST||LA27_1==DYNAMIC||LA27_1==GET||LA27_1==IDENT||LA27_1==IS||LA27_1==NAMESPACE||LA27_1==SET||LA27_1==SUPER||LA27_1==USE||LA27_1==XML))
			{
				alt27 = 1;
			}
			else if ((LA27_1==REST))
			{
				alt27 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 27, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:340:4: basicParameterDeclaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(340, 4);
				PushFollow(Follow._basicParameterDeclaration_in_parameterDeclaration1862);
				basicParameterDeclaration112=basicParameterDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, basicParameterDeclaration112.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:340:32: parameterRestDeclaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(340, 32);
				PushFollow(Follow._parameterRestDeclaration_in_parameterDeclaration1866);
				parameterRestDeclaration113=parameterRestDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, parameterRestDeclaration113.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDeclaration", 34);
			LeaveRule("parameterDeclaration", 34);
			LeaveRule_parameterDeclaration();
		}
		DebugLocation(341, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDeclaration"); }
		return retval;

	}
	// $ANTLR end "parameterDeclaration"

	partial void EnterRule_basicParameterDeclaration();
	partial void LeaveRule_basicParameterDeclaration();
	// $ANTLR start "basicParameterDeclaration"
	// AS3.g:343:1: basicParameterDeclaration : ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) ;
	[GrammarRule("basicParameterDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> basicParameterDeclaration()
	{
		EnterRule_basicParameterDeclaration();
		EnterRule("basicParameterDeclaration", 35);
		TraceIn("basicParameterDeclaration", 35);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CONST114 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident115 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression116 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> parameterDefault117 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONST114_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CONST=new RewriteRuleITokenStream(adaptor,"token CONST");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_parameterDefault=new RewriteRuleSubtreeStream(adaptor,"rule parameterDefault");
		try { DebugEnterRule(GrammarFileName, "basicParameterDeclaration");
		DebugLocation(343, 1);
		try
		{
			// AS3.g:344:2: ( ( CONST )? ident ( typeExpression )? ( parameterDefault )? -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? ) )
			DebugEnterAlt(1);
			// AS3.g:344:4: ( CONST )? ident ( typeExpression )? ( parameterDefault )?
			{
			DebugLocation(344, 4);
			// AS3.g:344:4: ( CONST )?
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==CONST))
			{
				alt28 = 1;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:344:4: CONST
				{
				DebugLocation(344, 4);
				CONST114=(IToken)Match(input,CONST,Follow._CONST_in_basicParameterDeclaration1877); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_CONST.Add(CONST114);


				}
				break;

			}
			} finally { DebugExitSubRule(28); }

			DebugLocation(344, 11);
			PushFollow(Follow._ident_in_basicParameterDeclaration1880);
			ident115=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident115.Tree);
			DebugLocation(344, 17);
			// AS3.g:344:17: ( typeExpression )?
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==COLON))
			{
				alt29 = 1;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:344:17: typeExpression
				{
				DebugLocation(344, 17);
				PushFollow(Follow._typeExpression_in_basicParameterDeclaration1882);
				typeExpression116=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression116.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(29); }

			DebugLocation(344, 33);
			// AS3.g:344:33: ( parameterDefault )?
			int alt30=2;
			try { DebugEnterSubRule(30);
			try { DebugEnterDecision(30, false);
			int LA30_1 = input.LA(1);

			if ((LA30_1==ASSIGN))
			{
				alt30 = 1;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:344:33: parameterDefault
				{
				DebugLocation(344, 33);
				PushFollow(Follow._parameterDefault_in_basicParameterDeclaration1885);
				parameterDefault117=parameterDefault();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_parameterDefault.Add(parameterDefault117.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(30); }



			{
			// AST REWRITE
			// elements: CONST, ident, typeExpression, parameterDefault
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 345:3: -> ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
			{
				DebugLocation(345, 6);
				// AS3.g:345:6: ^( PARAM ( CONST )? ident ( typeExpression )? ( parameterDefault )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(345, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(345, 14);
				// AS3.g:345:14: ( CONST )?
				if (stream_CONST.HasNext)
				{
					DebugLocation(345, 14);
					adaptor.AddChild(root_1, stream_CONST.NextNode());

				}
				stream_CONST.Reset();
				DebugLocation(345, 21);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(345, 27);
				// AS3.g:345:27: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(345, 27);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(345, 43);
				// AS3.g:345:43: ( parameterDefault )?
				if (stream_parameterDefault.HasNext)
				{
					DebugLocation(345, 43);
					adaptor.AddChild(root_1, stream_parameterDefault.NextTree());

				}
				stream_parameterDefault.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("basicParameterDeclaration", 35);
			LeaveRule("basicParameterDeclaration", 35);
			LeaveRule_basicParameterDeclaration();
		}
		DebugLocation(346, 1);
		} finally { DebugExitRule(GrammarFileName, "basicParameterDeclaration"); }
		return retval;

	}
	// $ANTLR end "basicParameterDeclaration"

	partial void EnterRule_parameterDefault();
	partial void LeaveRule_parameterDefault();
	// $ANTLR start "parameterDefault"
	// AS3.g:348:1: parameterDefault : ASSIGN assignmentExpression ;
	[GrammarRule("parameterDefault")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameterDefault()
	{
		EnterRule_parameterDefault();
		EnterRule("parameterDefault", 36);
		TraceIn("parameterDefault", 36);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ASSIGN118 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression119 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ASSIGN118_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "parameterDefault");
		DebugLocation(348, 1);
		try
		{
			// AS3.g:350:2: ( ASSIGN assignmentExpression )
			DebugEnterAlt(1);
			// AS3.g:350:4: ASSIGN assignmentExpression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(350, 4);
			ASSIGN118=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_parameterDefault1919); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN118_tree = (CommonTree)adaptor.Create(ASSIGN118);
			adaptor.AddChild(root_0, ASSIGN118_tree);
			}
			DebugLocation(350, 11);
			PushFollow(Follow._assignmentExpression_in_parameterDefault1921);
			assignmentExpression119=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression119.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterDefault", 36);
			LeaveRule("parameterDefault", 36);
			LeaveRule_parameterDefault();
		}
		DebugLocation(351, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterDefault"); }
		return retval;

	}
	// $ANTLR end "parameterDefault"

	partial void EnterRule_parameterRestDeclaration();
	partial void LeaveRule_parameterRestDeclaration();
	// $ANTLR start "parameterRestDeclaration"
	// AS3.g:353:1: parameterRestDeclaration : REST ( ident )? ( typeExpression )? -> ^( PARAM REST ( ident )? ( typeExpression )? ) ;
	[GrammarRule("parameterRestDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> parameterRestDeclaration()
	{
		EnterRule_parameterRestDeclaration();
		EnterRule("parameterRestDeclaration", 37);
		TraceIn("parameterRestDeclaration", 37);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken REST120 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident121 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression122 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree REST120_tree = default(CommonTree);
		RewriteRuleITokenStream stream_REST=new RewriteRuleITokenStream(adaptor,"token REST");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		try { DebugEnterRule(GrammarFileName, "parameterRestDeclaration");
		DebugLocation(353, 1);
		try
		{
			// AS3.g:354:2: ( REST ( ident )? ( typeExpression )? -> ^( PARAM REST ( ident )? ( typeExpression )? ) )
			DebugEnterAlt(1);
			// AS3.g:354:4: REST ( ident )? ( typeExpression )?
			{
			DebugLocation(354, 4);
			REST120=(IToken)Match(input,REST,Follow._REST_in_parameterRestDeclaration1932); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REST.Add(REST120);

			DebugLocation(354, 9);
			// AS3.g:354:9: ( ident )?
			int alt31=2;
			try { DebugEnterSubRule(31);
			try { DebugEnterDecision(31, false);
			int LA31_1 = input.LA(1);

			if ((LA31_1==AS||LA31_1==DYNAMIC||LA31_1==GET||LA31_1==IDENT||LA31_1==IS||LA31_1==NAMESPACE||LA31_1==SET||LA31_1==SUPER||LA31_1==USE||LA31_1==XML))
			{
				alt31 = 1;
			}
			} finally { DebugExitDecision(31); }
			switch (alt31)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:354:9: ident
				{
				DebugLocation(354, 9);
				PushFollow(Follow._ident_in_parameterRestDeclaration1934);
				ident121=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident121.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(31); }

			DebugLocation(354, 16);
			// AS3.g:354:16: ( typeExpression )?
			int alt32=2;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1==COLON))
			{
				alt32 = 1;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:354:16: typeExpression
				{
				DebugLocation(354, 16);
				PushFollow(Follow._typeExpression_in_parameterRestDeclaration1937);
				typeExpression122=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression122.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(32); }



			{
			// AST REWRITE
			// elements: REST, ident, typeExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 355:3: -> ^( PARAM REST ( ident )? ( typeExpression )? )
			{
				DebugLocation(355, 6);
				// AS3.g:355:6: ^( PARAM REST ( ident )? ( typeExpression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(355, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PARAM, "PARAM"), root_1);

				DebugLocation(355, 14);
				adaptor.AddChild(root_1, stream_REST.NextNode());
				DebugLocation(355, 19);
				// AS3.g:355:19: ( ident )?
				if (stream_ident.HasNext)
				{
					DebugLocation(355, 19);
					adaptor.AddChild(root_1, stream_ident.NextTree());

				}
				stream_ident.Reset();
				DebugLocation(355, 26);
				// AS3.g:355:26: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(355, 26);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterRestDeclaration", 37);
			LeaveRule("parameterRestDeclaration", 37);
			LeaveRule_parameterRestDeclaration();
		}
		DebugLocation(356, 1);
		} finally { DebugExitRule(GrammarFileName, "parameterRestDeclaration"); }
		return retval;

	}
	// $ANTLR end "parameterRestDeclaration"

	partial void EnterRule_block();
	partial void LeaveRule_block();
	// $ANTLR start "block"
	// AS3.g:357:1: block : LCURLY ( blockEntry )* RCURLY -> ^( BLOCK LCURLY ( blockEntry )* RCURLY ) ;
	[GrammarRule("block")]
	private AstParserRuleReturnScope<CommonTree, IToken> block()
	{
		EnterRule_block();
		EnterRule("block", 38);
		TraceIn("block", 38);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY123 = default(IToken);
		IToken RCURLY125 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> blockEntry124 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY123_tree = default(CommonTree);
		CommonTree RCURLY125_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_blockEntry=new RewriteRuleSubtreeStream(adaptor,"rule blockEntry");
		try { DebugEnterRule(GrammarFileName, "block");
		DebugLocation(357, 1);
		try
		{
			// AS3.g:358:2: ( LCURLY ( blockEntry )* RCURLY -> ^( BLOCK LCURLY ( blockEntry )* RCURLY ) )
			DebugEnterAlt(1);
			// AS3.g:358:4: LCURLY ( blockEntry )* RCURLY
			{
			DebugLocation(358, 4);
			LCURLY123=(IToken)Match(input,LCURLY,Follow._LCURLY_in_block1964); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY123);

			DebugLocation(358, 11);
			// AS3.g:358:11: ( blockEntry )*
			try { DebugEnterSubRule(33);
			while (true)
			{
				int alt33=2;
				try { DebugEnterDecision(33, false);
				int LA33_1 = input.LA(1);

				if ((LA33_1==AS||LA33_1==BNOT||LA33_1==BREAK||LA33_1==CONST||LA33_1==CONTINUE||(LA33_1>=DEC && LA33_1<=DECIMAL_LITERAL)||LA33_1==DEFAULT||LA33_1==DO||(LA33_1>=DYNAMIC && LA33_1<=E4X_ATTRI)||(LA33_1>=FALSE && LA33_1<=FOR)||LA33_1==FUNCTION||LA33_1==GET||(LA33_1>=HEX_LITERAL && LA33_1<=IDENT)||LA33_1==IF||LA33_1==INC||(LA33_1>=INTERNAL && LA33_1<=IS)||(LA33_1>=LBRACK && LA33_1<=LCURLY)||LA33_1==LNOT||LA33_1==LPAREN||LA33_1==MINUS||LA33_1==NAMESPACE||LA33_1==NEW||LA33_1==NULL||LA33_1==OCTAL_LITERAL||LA33_1==PLUS||LA33_1==PRIVATE||(LA33_1>=PROTECTED && LA33_1<=PUBLIC)||LA33_1==REGEX_LITERAL||LA33_1==RETURN||(LA33_1>=SEMI && LA33_1<=SET)||(LA33_1>=STRING_LITERAL_DOUBLE && LA33_1<=SWITCH)||LA33_1==TRUE||(LA33_1>=USE && LA33_1<=VAR)||LA33_1==WHILE||LA33_1==WITH||LA33_1==XML||LA33_1==XML_LITERAL||LA33_1==243||(LA33_1>=253 && LA33_1<=257)))
				{
					alt33 = 1;
				}


				} finally { DebugExitDecision(33); }
				switch ( alt33 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:358:11: blockEntry
					{
					DebugLocation(358, 11);
					PushFollow(Follow._blockEntry_in_block1966);
					blockEntry124=blockEntry();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_blockEntry.Add(blockEntry124.Tree);

					}
					break;

				default:
					goto loop33;
				}
			}

			loop33:
				;

			} finally { DebugExitSubRule(33); }

			DebugLocation(358, 23);
			RCURLY125=(IToken)Match(input,RCURLY,Follow._RCURLY_in_block1969); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY125);



			{
			// AST REWRITE
			// elements: LCURLY, blockEntry, RCURLY
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 359:3: -> ^( BLOCK LCURLY ( blockEntry )* RCURLY )
			{
				DebugLocation(359, 6);
				// AS3.g:359:6: ^( BLOCK LCURLY ( blockEntry )* RCURLY )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(359, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(359, 14);
				adaptor.AddChild(root_1, stream_LCURLY.NextNode());
				DebugLocation(359, 21);
				// AS3.g:359:21: ( blockEntry )*
				while ( stream_blockEntry.HasNext )
				{
					DebugLocation(359, 21);
					adaptor.AddChild(root_1, stream_blockEntry.NextTree());

				}
				stream_blockEntry.Reset();
				DebugLocation(359, 33);
				adaptor.AddChild(root_1, stream_RCURLY.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("block", 38);
			LeaveRule("block", 38);
			LeaveRule_block();
		}
		DebugLocation(360, 1);
		} finally { DebugExitRule(GrammarFileName, "block"); }
		return retval;

	}
	// $ANTLR end "block"

	partial void EnterRule_blockEntry();
	partial void LeaveRule_blockEntry();
	// $ANTLR start "blockEntry"
	// AS3.g:362:1: blockEntry : statement ;
	[GrammarRule("blockEntry")]
	private AstParserRuleReturnScope<CommonTree, IToken> blockEntry()
	{
		EnterRule_blockEntry();
		EnterRule("blockEntry", 39);
		TraceIn("blockEntry", 39);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> statement126 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "blockEntry");
		DebugLocation(362, 1);
		try
		{
			// AS3.g:363:2: ( statement )
			DebugEnterAlt(1);
			// AS3.g:363:4: statement
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(363, 4);
			PushFollow(Follow._statement_in_blockEntry1995);
			statement126=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement126.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("blockEntry", 39);
			LeaveRule("blockEntry", 39);
			LeaveRule_blockEntry();
		}
		DebugLocation(364, 1);
		} finally { DebugExitRule(GrammarFileName, "blockEntry"); }
		return retval;

	}
	// $ANTLR end "blockEntry"

	partial void EnterRule_condition();
	partial void LeaveRule_condition();
	// $ANTLR start "condition"
	// AS3.g:366:1: condition : LPAREN expression RPAREN -> ^( CONDITION expression ) ;
	[GrammarRule("condition")]
	private AstParserRuleReturnScope<CommonTree, IToken> condition()
	{
		EnterRule_condition();
		EnterRule("condition", 40);
		TraceIn("condition", 40);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN127 = default(IToken);
		IToken RPAREN129 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression128 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN127_tree = default(CommonTree);
		CommonTree RPAREN129_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "condition");
		DebugLocation(366, 1);
		try
		{
			// AS3.g:367:2: ( LPAREN expression RPAREN -> ^( CONDITION expression ) )
			DebugEnterAlt(1);
			// AS3.g:367:4: LPAREN expression RPAREN
			{
			DebugLocation(367, 4);
			LPAREN127=(IToken)Match(input,LPAREN,Follow._LPAREN_in_condition2006); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN127);

			DebugLocation(367, 11);
			PushFollow(Follow._expression_in_condition2008);
			expression128=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression128.Tree);
			DebugLocation(367, 22);
			RPAREN129=(IToken)Match(input,RPAREN,Follow._RPAREN_in_condition2010); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN129);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 368:3: -> ^( CONDITION expression )
			{
				DebugLocation(368, 6);
				// AS3.g:368:6: ^( CONDITION expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(368, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONDITION, "CONDITION"), root_1);

				DebugLocation(368, 18);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("condition", 40);
			LeaveRule("condition", 40);
			LeaveRule_condition();
		}
		DebugLocation(369, 1);
		} finally { DebugExitRule(GrammarFileName, "condition"); }
		return retval;

	}
	// $ANTLR end "condition"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// AS3.g:371:1: statement : ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | semi );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 41);
		TraceIn("statement", 41);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> block130 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> declarationStatement131 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expressionStatement132 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement133 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forEachStatement134 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement135 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement136 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> withStatement137 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchStatement138 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> breakStatement139 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> continueStatement140 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnStatement141 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> throwStatement142 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> tryStatement143 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defaultXMLNamespaceStatement144 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi145 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(371, 1);
		try
		{
			// AS3.g:372:2: ( ( LCURLY )=> block | declarationStatement | expressionStatement | ifStatement | forEachStatement | whileStatement | doWhileStatement | withStatement | switchStatement | breakStatement | continueStatement | returnStatement | throwStatement | tryStatement | defaultXMLNamespaceStatement | semi )
			int alt34=16;
			try { DebugEnterDecision(34, false);
			switch (input.LA(1))
			{
			case LCURLY:
				{
				int LA34_2 = input.LA(2);

				if ((EvaluatePredicate(synpred13_AS3_fragment)))
				{
					alt34 = 1;
				}
				else if ((true))
				{
					alt34 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case CONST:
			case VAR:
				{
				alt34 = 2;
				}
				break;
			case AS:
			case BNOT:
			case DEC:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INC:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LNOT:
			case LPAREN:
			case MINUS:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PLUS:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 243:
			case 255:
			case 256:
			case 257:
				{
				alt34 = 3;
				}
				break;
			case IF:
				{
				alt34 = 4;
				}
				break;
			case FOR:
				{
				alt34 = 5;
				}
				break;
			case WHILE:
				{
				alt34 = 6;
				}
				break;
			case DO:
				{
				alt34 = 7;
				}
				break;
			case WITH:
				{
				alt34 = 8;
				}
				break;
			case SWITCH:
				{
				alt34 = 9;
				}
				break;
			case BREAK:
				{
				alt34 = 10;
				}
				break;
			case CONTINUE:
				{
				alt34 = 11;
				}
				break;
			case RETURN:
				{
				alt34 = 12;
				}
				break;
			case 253:
				{
				alt34 = 13;
				}
				break;
			case 254:
				{
				alt34 = 14;
				}
				break;
			case DEFAULT:
				{
				alt34 = 15;
				}
				break;
			case SEMI:
				{
				alt34 = 16;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 34, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(34); }
			switch (alt34)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:372:4: ( LCURLY )=> block
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(372, 16);
				PushFollow(Follow._block_in_statement2037);
				block130=block();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, block130.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:374:4: declarationStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(374, 4);
				PushFollow(Follow._declarationStatement_in_statement2043);
				declarationStatement131=declarationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, declarationStatement131.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:376:4: expressionStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(376, 4);
				PushFollow(Follow._expressionStatement_in_statement2050);
				expressionStatement132=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement132.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:378:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(378, 4);
				PushFollow(Follow._ifStatement_in_statement2056);
				ifStatement133=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement133.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:380:4: forEachStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(380, 4);
				PushFollow(Follow._forEachStatement_in_statement2062);
				forEachStatement134=forEachStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forEachStatement134.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:382:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(382, 4);
				PushFollow(Follow._whileStatement_in_statement2068);
				whileStatement135=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement135.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:384:4: doWhileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(384, 4);
				PushFollow(Follow._doWhileStatement_in_statement2074);
				doWhileStatement136=doWhileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement136.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// AS3.g:386:4: withStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(386, 4);
				PushFollow(Follow._withStatement_in_statement2081);
				withStatement137=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement137.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// AS3.g:388:4: switchStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(388, 4);
				PushFollow(Follow._switchStatement_in_statement2088);
				switchStatement138=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement138.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// AS3.g:390:4: breakStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(390, 4);
				PushFollow(Follow._breakStatement_in_statement2095);
				breakStatement139=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement139.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// AS3.g:392:4: continueStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(392, 4);
				PushFollow(Follow._continueStatement_in_statement2101);
				continueStatement140=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement140.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// AS3.g:394:4: returnStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(394, 4);
				PushFollow(Follow._returnStatement_in_statement2107);
				returnStatement141=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement141.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// AS3.g:396:4: throwStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(396, 4);
				PushFollow(Follow._throwStatement_in_statement2113);
				throwStatement142=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement142.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// AS3.g:398:4: tryStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(398, 4);
				PushFollow(Follow._tryStatement_in_statement2120);
				tryStatement143=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement143.Tree);

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// AS3.g:400:4: defaultXMLNamespaceStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(400, 4);
				PushFollow(Follow._defaultXMLNamespaceStatement_in_statement2127);
				defaultXMLNamespaceStatement144=defaultXMLNamespaceStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultXMLNamespaceStatement144.Tree);

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// AS3.g:402:9: semi
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(402, 9);
				PushFollow(Follow._semi_in_statement2142);
				semi145=semi();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, semi145.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 41);
			LeaveRule("statement", 41);
			LeaveRule_statement();
		}
		DebugLocation(404, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_declarationStatement();
	partial void LeaveRule_declarationStatement();
	// $ANTLR start "declarationStatement"
	// AS3.g:406:1: declarationStatement : declaration s= semi -> ^( DECL_STMT declaration ) ;
	[GrammarRule("declarationStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> declarationStatement()
	{
		EnterRule_declarationStatement();
		EnterRule("declarationStatement", 42);
		TraceIn("declarationStatement", 42);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> declaration146 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "declarationStatement");
		DebugLocation(406, 1);
		try
		{
			// AS3.g:407:2: ( declaration s= semi -> ^( DECL_STMT declaration ) )
			DebugEnterAlt(1);
			// AS3.g:407:4: declaration s= semi
			{
			DebugLocation(407, 4);
			PushFollow(Follow._declaration_in_declarationStatement2158);
			declaration146=declaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_declaration.Add(declaration146.Tree);
			DebugLocation(407, 17);
			PushFollow(Follow._semi_in_declarationStatement2162);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: declaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 408:7: -> ^( DECL_STMT declaration )
			{
				DebugLocation(408, 10);
				// AS3.g:408:10: ^( DECL_STMT declaration )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(408, 12);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DECL_STMT, "DECL_STMT"), root_1);

				DebugLocation(408, 22);
				adaptor.AddChild(root_1, stream_declaration.NextTree());
				DebugLocation(408, 34);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("declarationStatement", 42);
			LeaveRule("declarationStatement", 42);
			LeaveRule_declarationStatement();
		}
		DebugLocation(409, 1);
		} finally { DebugExitRule(GrammarFileName, "declarationStatement"); }
		return retval;

	}
	// $ANTLR end "declarationStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// AS3.g:411:1: expressionStatement : expressionList s= semi -> ^( EXPR_STMNT expressionList ) ;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 43);
		TraceIn("expressionStatement", 43);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expressionList147 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(411, 1);
		try
		{
			// AS3.g:412:2: ( expressionList s= semi -> ^( EXPR_STMNT expressionList ) )
			DebugEnterAlt(1);
			// AS3.g:412:4: expressionList s= semi
			{
			DebugLocation(412, 4);
			PushFollow(Follow._expressionList_in_expressionStatement2189);
			expressionList147=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expressionList.Add(expressionList147.Tree);
			DebugLocation(412, 20);
			PushFollow(Follow._semi_in_expressionStatement2193);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 413:3: -> ^( EXPR_STMNT expressionList )
			{
				DebugLocation(413, 6);
				// AS3.g:413:6: ^( EXPR_STMNT expressionList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(413, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPR_STMNT, "EXPR_STMNT"), root_1);

				DebugLocation(413, 19);
				adaptor.AddChild(root_1, stream_expressionList.NextTree());
				DebugLocation(413, 34);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 43);
			LeaveRule("expressionStatement", 43);
			LeaveRule_expressionStatement();
		}
		DebugLocation(414, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// AS3.g:417:1: ifStatement : IF condition statement ( ( ELSE )=> elseClause )? -> ^( IF_STMT IF condition statement ( elseClause )? ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 44);
		TraceIn("ifStatement", 44);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IF148 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition149 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement150 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elseClause151 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IF148_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IF=new RewriteRuleITokenStream(adaptor,"token IF");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_elseClause=new RewriteRuleSubtreeStream(adaptor,"rule elseClause");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(417, 1);
		try
		{
			// AS3.g:418:2: ( IF condition statement ( ( ELSE )=> elseClause )? -> ^( IF_STMT IF condition statement ( elseClause )? ) )
			DebugEnterAlt(1);
			// AS3.g:418:4: IF condition statement ( ( ELSE )=> elseClause )?
			{
			DebugLocation(418, 4);
			IF148=(IToken)Match(input,IF,Follow._IF_in_ifStatement2217); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IF.Add(IF148);

			DebugLocation(418, 7);
			PushFollow(Follow._condition_in_ifStatement2219);
			condition149=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition149.Tree);
			DebugLocation(418, 17);
			PushFollow(Follow._statement_in_ifStatement2221);
			statement150=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement150.Tree);
			DebugLocation(419, 3);
			// AS3.g:419:3: ( ( ELSE )=> elseClause )?
			int alt35=2;
			try { DebugEnterSubRule(35);
			try { DebugEnterDecision(35, false);
			int LA35_1 = input.LA(1);

			if ((LA35_1==ELSE))
			{
				int LA35_2 = input.LA(2);

				if ((EvaluatePredicate(synpred14_AS3_fragment)))
				{
					alt35 = 1;
				}
			}
			} finally { DebugExitDecision(35); }
			switch (alt35)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:419:4: ( ELSE )=> elseClause
				{
				DebugLocation(419, 12);
				PushFollow(Follow._elseClause_in_ifStatement2230);
				elseClause151=elseClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_elseClause.Add(elseClause151.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: IF, condition, statement, elseClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 420:9: -> ^( IF_STMT IF condition statement ( elseClause )? )
			{
				DebugLocation(420, 12);
				// AS3.g:420:12: ^( IF_STMT IF condition statement ( elseClause )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(420, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(IF_STMT, "IF_STMT"), root_1);

				DebugLocation(420, 22);
				adaptor.AddChild(root_1, stream_IF.NextNode());
				DebugLocation(420, 25);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(420, 35);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(420, 45);
				// AS3.g:420:45: ( elseClause )?
				if (stream_elseClause.HasNext)
				{
					DebugLocation(420, 45);
					adaptor.AddChild(root_1, stream_elseClause.NextTree());

				}
				stream_elseClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 44);
			LeaveRule("ifStatement", 44);
			LeaveRule_ifStatement();
		}
		DebugLocation(421, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_elseClause();
	partial void LeaveRule_elseClause();
	// $ANTLR start "elseClause"
	// AS3.g:423:1: elseClause : ELSE statement -> ^( ELSE_CLAUSE ELSE statement ) ;
	[GrammarRule("elseClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> elseClause()
	{
		EnterRule_elseClause();
		EnterRule("elseClause", 45);
		TraceIn("elseClause", 45);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ELSE152 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement153 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ELSE152_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ELSE=new RewriteRuleITokenStream(adaptor,"token ELSE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "elseClause");
		DebugLocation(423, 1);
		try
		{
			// AS3.g:424:2: ( ELSE statement -> ^( ELSE_CLAUSE ELSE statement ) )
			DebugEnterAlt(1);
			// AS3.g:424:4: ELSE statement
			{
			DebugLocation(424, 4);
			ELSE152=(IToken)Match(input,ELSE,Follow._ELSE_in_elseClause2266); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ELSE.Add(ELSE152);

			DebugLocation(424, 9);
			PushFollow(Follow._statement_in_elseClause2268);
			statement153=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement153.Tree);


			{
			// AST REWRITE
			// elements: ELSE, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 425:9: -> ^( ELSE_CLAUSE ELSE statement )
			{
				DebugLocation(425, 12);
				// AS3.g:425:12: ^( ELSE_CLAUSE ELSE statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(425, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ELSE_CLAUSE, "ELSE_CLAUSE"), root_1);

				DebugLocation(425, 26);
				adaptor.AddChild(root_1, stream_ELSE.NextNode());
				DebugLocation(425, 31);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elseClause", 45);
			LeaveRule("elseClause", 45);
			LeaveRule_elseClause();
		}
		DebugLocation(426, 1);
		} finally { DebugExitRule(GrammarFileName, "elseClause"); }
		return retval;

	}
	// $ANTLR end "elseClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// AS3.g:428:1: throwStatement : 'throw' expression s= semi -> ^( THROW_STATEMENT 'throw' expression ) ;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 46);
		TraceIn("throwStatement", 46);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal154 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression155 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal154_tree = default(CommonTree);
		RewriteRuleITokenStream stream_253=new RewriteRuleITokenStream(adaptor,"token 253");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(428, 1);
		try
		{
			// AS3.g:429:2: ( 'throw' expression s= semi -> ^( THROW_STATEMENT 'throw' expression ) )
			DebugEnterAlt(1);
			// AS3.g:429:4: 'throw' expression s= semi
			{
			DebugLocation(429, 4);
			string_literal154=(IToken)Match(input,253,Follow._253_in_throwStatement2298); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_253.Add(string_literal154);

			DebugLocation(429, 12);
			PushFollow(Follow._expression_in_throwStatement2300);
			expression155=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression155.Tree);
			DebugLocation(429, 24);
			PushFollow(Follow._semi_in_throwStatement2304);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: 253, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 430:9: -> ^( THROW_STATEMENT 'throw' expression )
			{
				DebugLocation(430, 12);
				// AS3.g:430:12: ^( THROW_STATEMENT 'throw' expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(430, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(THROW_STATEMENT, "THROW_STATEMENT"), root_1);

				DebugLocation(430, 30);
				adaptor.AddChild(root_1, stream_253.NextNode());
				DebugLocation(430, 38);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(430, 49);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 46);
			LeaveRule("throwStatement", 46);
			LeaveRule_throwStatement();
		}
		DebugLocation(431, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// AS3.g:433:1: tryStatement : 'try' block ( catchBlock )* ( finallyBlock )? -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 47);
		TraceIn("tryStatement", 47);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal156 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> block157 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> catchBlock158 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> finallyBlock159 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal156_tree = default(CommonTree);
		RewriteRuleITokenStream stream_254=new RewriteRuleITokenStream(adaptor,"token 254");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		RewriteRuleSubtreeStream stream_catchBlock=new RewriteRuleSubtreeStream(adaptor,"rule catchBlock");
		RewriteRuleSubtreeStream stream_finallyBlock=new RewriteRuleSubtreeStream(adaptor,"rule finallyBlock");
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(433, 1);
		try
		{
			// AS3.g:434:2: ( 'try' block ( catchBlock )* ( finallyBlock )? -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? ) )
			DebugEnterAlt(1);
			// AS3.g:434:4: 'try' block ( catchBlock )* ( finallyBlock )?
			{
			DebugLocation(434, 4);
			string_literal156=(IToken)Match(input,254,Follow._254_in_tryStatement2335); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_254.Add(string_literal156);

			DebugLocation(435, 3);
			PushFollow(Follow._block_in_tryStatement2339);
			block157=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(block157.Tree);
			DebugLocation(436, 3);
			// AS3.g:436:3: ( catchBlock )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==242))
				{
					alt36 = 1;
				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:436:3: catchBlock
					{
					DebugLocation(436, 3);
					PushFollow(Follow._catchBlock_in_tryStatement2343);
					catchBlock158=catchBlock();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_catchBlock.Add(catchBlock158.Tree);

					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(437, 3);
			// AS3.g:437:3: ( finallyBlock )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==247))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:437:3: finallyBlock
				{
				DebugLocation(437, 3);
				PushFollow(Follow._finallyBlock_in_tryStatement2348);
				finallyBlock159=finallyBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_finallyBlock.Add(finallyBlock159.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }



			{
			// AST REWRITE
			// elements: 254, block, catchBlock, finallyBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 438:9: -> ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? )
			{
				DebugLocation(438, 12);
				// AS3.g:438:12: ^( TRY_STATEMENT 'try' block ( catchBlock )* ( finallyBlock )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(438, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TRY_STATEMENT, "TRY_STATEMENT"), root_1);

				DebugLocation(438, 28);
				adaptor.AddChild(root_1, stream_254.NextNode());
				DebugLocation(438, 34);
				adaptor.AddChild(root_1, stream_block.NextTree());
				DebugLocation(438, 40);
				// AS3.g:438:40: ( catchBlock )*
				while ( stream_catchBlock.HasNext )
				{
					DebugLocation(438, 40);
					adaptor.AddChild(root_1, stream_catchBlock.NextTree());

				}
				stream_catchBlock.Reset();
				DebugLocation(438, 52);
				// AS3.g:438:52: ( finallyBlock )?
				if (stream_finallyBlock.HasNext)
				{
					DebugLocation(438, 52);
					adaptor.AddChild(root_1, stream_finallyBlock.NextTree());

				}
				stream_finallyBlock.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 47);
			LeaveRule("tryStatement", 47);
			LeaveRule_tryStatement();
		}
		DebugLocation(439, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchBlock();
	partial void LeaveRule_catchBlock();
	// $ANTLR start "catchBlock"
	// AS3.g:441:1: catchBlock : 'catch' LPAREN ident ( typeExpression )? RPAREN block ;
	[GrammarRule("catchBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> catchBlock()
	{
		EnterRule_catchBlock();
		EnterRule("catchBlock", 48);
		TraceIn("catchBlock", 48);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal160 = default(IToken);
		IToken LPAREN161 = default(IToken);
		IToken RPAREN164 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident162 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression163 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> block165 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal160_tree = default(CommonTree);
		CommonTree LPAREN161_tree = default(CommonTree);
		CommonTree RPAREN164_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "catchBlock");
		DebugLocation(441, 1);
		try
		{
			// AS3.g:442:2: ( 'catch' LPAREN ident ( typeExpression )? RPAREN block )
			DebugEnterAlt(1);
			// AS3.g:442:4: 'catch' LPAREN ident ( typeExpression )? RPAREN block
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(442, 4);
			string_literal160=(IToken)Match(input,242,Follow._242_in_catchBlock2384); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal160_tree = (CommonTree)adaptor.Create(string_literal160);
			adaptor.AddChild(root_0, string_literal160_tree);
			}
			DebugLocation(442, 12);
			LPAREN161=(IToken)Match(input,LPAREN,Follow._LPAREN_in_catchBlock2386); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LPAREN161_tree = (CommonTree)adaptor.Create(LPAREN161);
			adaptor.AddChild(root_0, LPAREN161_tree);
			}
			DebugLocation(442, 19);
			PushFollow(Follow._ident_in_catchBlock2388);
			ident162=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident162.Tree);
			DebugLocation(442, 25);
			// AS3.g:442:25: ( typeExpression )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==COLON))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:442:25: typeExpression
				{
				DebugLocation(442, 25);
				PushFollow(Follow._typeExpression_in_catchBlock2390);
				typeExpression163=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, typeExpression163.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(442, 41);
			RPAREN164=(IToken)Match(input,RPAREN,Follow._RPAREN_in_catchBlock2393); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RPAREN164_tree = (CommonTree)adaptor.Create(RPAREN164);
			adaptor.AddChild(root_0, RPAREN164_tree);
			}
			DebugLocation(443, 3);
			PushFollow(Follow._block_in_catchBlock2397);
			block165=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block165.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchBlock", 48);
			LeaveRule("catchBlock", 48);
			LeaveRule_catchBlock();
		}
		DebugLocation(444, 1);
		} finally { DebugExitRule(GrammarFileName, "catchBlock"); }
		return retval;

	}
	// $ANTLR end "catchBlock"

	partial void EnterRule_finallyBlock();
	partial void LeaveRule_finallyBlock();
	// $ANTLR start "finallyBlock"
	// AS3.g:446:1: finallyBlock : 'finally' block ;
	[GrammarRule("finallyBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> finallyBlock()
	{
		EnterRule_finallyBlock();
		EnterRule("finallyBlock", 49);
		TraceIn("finallyBlock", 49);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal166 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> block167 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal166_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "finallyBlock");
		DebugLocation(446, 1);
		try
		{
			// AS3.g:447:2: ( 'finally' block )
			DebugEnterAlt(1);
			// AS3.g:447:4: 'finally' block
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(447, 4);
			string_literal166=(IToken)Match(input,247,Follow._247_in_finallyBlock2408); if (state.failed) return retval;
			if (state.backtracking == 0) {
			string_literal166_tree = (CommonTree)adaptor.Create(string_literal166);
			adaptor.AddChild(root_0, string_literal166_tree);
			}
			DebugLocation(447, 14);
			PushFollow(Follow._block_in_finallyBlock2410);
			block167=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, block167.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyBlock", 49);
			LeaveRule("finallyBlock", 49);
			LeaveRule_finallyBlock();
		}
		DebugLocation(448, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyBlock"); }
		return retval;

	}
	// $ANTLR end "finallyBlock"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// AS3.g:450:1: returnStatement : RETURN ( expression )? s= semi -> ^( RETURN_STATEMENT RETURN ( expression )? ) ;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 50);
		TraceIn("returnStatement", 50);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken RETURN168 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression169 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree RETURN168_tree = default(CommonTree);
		RewriteRuleITokenStream stream_RETURN=new RewriteRuleITokenStream(adaptor,"token RETURN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(450, 1);
		try
		{
			// AS3.g:451:2: ( RETURN ( expression )? s= semi -> ^( RETURN_STATEMENT RETURN ( expression )? ) )
			DebugEnterAlt(1);
			// AS3.g:451:4: RETURN ( expression )? s= semi
			{
			DebugLocation(451, 4);
			RETURN168=(IToken)Match(input,RETURN,Follow._RETURN_in_returnStatement2421); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RETURN.Add(RETURN168);

			DebugLocation(451, 11);
			// AS3.g:451:11: ( expression )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==AS||LA39_1==BNOT||(LA39_1>=DEC && LA39_1<=DECIMAL_LITERAL)||(LA39_1>=DYNAMIC && LA39_1<=E4X_ATTRI)||(LA39_1>=FALSE && LA39_1<=FLOAT_LITERAL)||LA39_1==FUNCTION||LA39_1==GET||(LA39_1>=HEX_LITERAL && LA39_1<=IDENT)||LA39_1==INC||(LA39_1>=INTERNAL && LA39_1<=IS)||(LA39_1>=LBRACK && LA39_1<=LCURLY)||LA39_1==LNOT||LA39_1==LPAREN||LA39_1==MINUS||LA39_1==NAMESPACE||LA39_1==NEW||LA39_1==NULL||LA39_1==OCTAL_LITERAL||LA39_1==PLUS||LA39_1==PRIVATE||(LA39_1>=PROTECTED && LA39_1<=PUBLIC)||LA39_1==REGEX_LITERAL||LA39_1==SET||(LA39_1>=STRING_LITERAL_DOUBLE && LA39_1<=SUPER)||LA39_1==TRUE||LA39_1==USE||LA39_1==XML||LA39_1==XML_LITERAL||LA39_1==243||(LA39_1>=255 && LA39_1<=257)))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:451:11: expression
				{
				DebugLocation(451, 11);
				PushFollow(Follow._expression_in_returnStatement2423);
				expression169=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression169.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }

			DebugLocation(451, 24);
			PushFollow(Follow._semi_in_returnStatement2428);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: RETURN, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 452:9: -> ^( RETURN_STATEMENT RETURN ( expression )? )
			{
				DebugLocation(452, 12);
				// AS3.g:452:12: ^( RETURN_STATEMENT RETURN ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(452, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(RETURN_STATEMENT, "RETURN_STATEMENT"), root_1);

				DebugLocation(452, 31);
				adaptor.AddChild(root_1, stream_RETURN.NextNode());
				DebugLocation(452, 38);
				// AS3.g:452:38: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(452, 38);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();
				DebugLocation(452, 50);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 50);
			LeaveRule("returnStatement", 50);
			LeaveRule_returnStatement();
		}
		DebugLocation(453, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// AS3.g:455:1: continueStatement : CONTINUE s= semi -> ^( CONTINUE_STATEMENT CONTINUE ) ;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 51);
		TraceIn("continueStatement", 51);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CONTINUE170 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CONTINUE170_tree = default(CommonTree);
		RewriteRuleITokenStream stream_CONTINUE=new RewriteRuleITokenStream(adaptor,"token CONTINUE");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(455, 1);
		try
		{
			// AS3.g:456:2: ( CONTINUE s= semi -> ^( CONTINUE_STATEMENT CONTINUE ) )
			DebugEnterAlt(1);
			// AS3.g:456:4: CONTINUE s= semi
			{
			DebugLocation(456, 4);
			CONTINUE170=(IToken)Match(input,CONTINUE,Follow._CONTINUE_in_continueStatement2462); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_CONTINUE.Add(CONTINUE170);

			DebugLocation(456, 14);
			PushFollow(Follow._semi_in_continueStatement2466);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: CONTINUE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 457:9: -> ^( CONTINUE_STATEMENT CONTINUE )
			{
				DebugLocation(457, 12);
				// AS3.g:457:12: ^( CONTINUE_STATEMENT CONTINUE )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(457, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONTINUE_STATEMENT, "CONTINUE_STATEMENT"), root_1);

				DebugLocation(457, 33);
				adaptor.AddChild(root_1, stream_CONTINUE.NextNode());
				DebugLocation(457, 42);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 51);
			LeaveRule("continueStatement", 51);
			LeaveRule_continueStatement();
		}
		DebugLocation(458, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// AS3.g:460:1: breakStatement : BREAK s= semi -> ^( BREAK_STATEMENT BREAK ) ;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 52);
		TraceIn("breakStatement", 52);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken BREAK171 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> s = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BREAK171_tree = default(CommonTree);
		RewriteRuleITokenStream stream_BREAK=new RewriteRuleITokenStream(adaptor,"token BREAK");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(460, 1);
		try
		{
			// AS3.g:461:2: ( BREAK s= semi -> ^( BREAK_STATEMENT BREAK ) )
			DebugEnterAlt(1);
			// AS3.g:461:4: BREAK s= semi
			{
			DebugLocation(461, 4);
			BREAK171=(IToken)Match(input,BREAK,Follow._BREAK_in_breakStatement2495); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_BREAK.Add(BREAK171);

			DebugLocation(461, 11);
			PushFollow(Follow._semi_in_breakStatement2499);
			s=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(s.Tree);


			{
			// AST REWRITE
			// elements: BREAK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 462:9: -> ^( BREAK_STATEMENT BREAK )
			{
				DebugLocation(462, 12);
				// AS3.g:462:12: ^( BREAK_STATEMENT BREAK )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(462, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BREAK_STATEMENT, "BREAK_STATEMENT"), root_1);

				DebugLocation(462, 30);
				adaptor.AddChild(root_1, stream_BREAK.NextNode());
				DebugLocation(462, 36);
				adaptor.AddChild(root_1, maybeSemi(s));

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 52);
			LeaveRule("breakStatement", 52);
			LeaveRule_breakStatement();
		}
		DebugLocation(463, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// AS3.g:465:1: switchStatement : SWITCH condition switchBlock -> ^( SWITCH_STATEMENT SWITCH condition switchBlock ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 53);
		TraceIn("switchStatement", 53);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken SWITCH172 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition173 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchBlock174 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree SWITCH172_tree = default(CommonTree);
		RewriteRuleITokenStream stream_SWITCH=new RewriteRuleITokenStream(adaptor,"token SWITCH");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_switchBlock=new RewriteRuleSubtreeStream(adaptor,"rule switchBlock");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(465, 1);
		try
		{
			// AS3.g:466:2: ( SWITCH condition switchBlock -> ^( SWITCH_STATEMENT SWITCH condition switchBlock ) )
			DebugEnterAlt(1);
			// AS3.g:466:4: SWITCH condition switchBlock
			{
			DebugLocation(466, 4);
			SWITCH172=(IToken)Match(input,SWITCH,Follow._SWITCH_in_switchStatement2528); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_SWITCH.Add(SWITCH172);

			DebugLocation(466, 11);
			PushFollow(Follow._condition_in_switchStatement2530);
			condition173=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition173.Tree);
			DebugLocation(467, 3);
			PushFollow(Follow._switchBlock_in_switchStatement2534);
			switchBlock174=switchBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_switchBlock.Add(switchBlock174.Tree);


			{
			// AST REWRITE
			// elements: SWITCH, condition, switchBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 468:9: -> ^( SWITCH_STATEMENT SWITCH condition switchBlock )
			{
				DebugLocation(468, 12);
				// AS3.g:468:12: ^( SWITCH_STATEMENT SWITCH condition switchBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(468, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SWITCH_STATEMENT, "SWITCH_STATEMENT"), root_1);

				DebugLocation(468, 31);
				adaptor.AddChild(root_1, stream_SWITCH.NextNode());
				DebugLocation(468, 38);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(468, 48);
				adaptor.AddChild(root_1, stream_switchBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 53);
			LeaveRule("switchStatement", 53);
			LeaveRule_switchStatement();
		}
		DebugLocation(469, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_switchBlock();
	partial void LeaveRule_switchBlock();
	// $ANTLR start "switchBlock"
	// AS3.g:471:1: switchBlock : LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) ;
	[GrammarRule("switchBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> switchBlock()
	{
		EnterRule_switchBlock();
		EnterRule("switchBlock", 54);
		TraceIn("switchBlock", 54);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY175 = default(IToken);
		IToken RCURLY178 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> caseStatement176 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defaultStatement177 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY175_tree = default(CommonTree);
		CommonTree RCURLY178_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_caseStatement=new RewriteRuleSubtreeStream(adaptor,"rule caseStatement");
		RewriteRuleSubtreeStream stream_defaultStatement=new RewriteRuleSubtreeStream(adaptor,"rule defaultStatement");
		try { DebugEnterRule(GrammarFileName, "switchBlock");
		DebugLocation(471, 1);
		try
		{
			// AS3.g:472:2: ( LCURLY ( caseStatement )* ( defaultStatement )? RCURLY -> ^( BLOCK ( caseStatement )* ( defaultStatement )? ) )
			DebugEnterAlt(1);
			// AS3.g:472:4: LCURLY ( caseStatement )* ( defaultStatement )? RCURLY
			{
			DebugLocation(472, 4);
			LCURLY175=(IToken)Match(input,LCURLY,Follow._LCURLY_in_switchBlock2565); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY175);

			DebugLocation(473, 3);
			// AS3.g:473:3: ( caseStatement )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==CASE))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:473:4: caseStatement
					{
					DebugLocation(473, 4);
					PushFollow(Follow._caseStatement_in_switchBlock2570);
					caseStatement176=caseStatement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_caseStatement.Add(caseStatement176.Tree);

					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(474, 3);
			// AS3.g:474:3: ( defaultStatement )?
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==DEFAULT))
			{
				alt41 = 1;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:474:4: defaultStatement
				{
				DebugLocation(474, 4);
				PushFollow(Follow._defaultStatement_in_switchBlock2577);
				defaultStatement177=defaultStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_defaultStatement.Add(defaultStatement177.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(41); }

			DebugLocation(475, 3);
			RCURLY178=(IToken)Match(input,RCURLY,Follow._RCURLY_in_switchBlock2583); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY178);



			{
			// AST REWRITE
			// elements: caseStatement, defaultStatement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 476:3: -> ^( BLOCK ( caseStatement )* ( defaultStatement )? )
			{
				DebugLocation(476, 6);
				// AS3.g:476:6: ^( BLOCK ( caseStatement )* ( defaultStatement )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(476, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(476, 14);
				// AS3.g:476:14: ( caseStatement )*
				while ( stream_caseStatement.HasNext )
				{
					DebugLocation(476, 14);
					adaptor.AddChild(root_1, stream_caseStatement.NextTree());

				}
				stream_caseStatement.Reset();
				DebugLocation(476, 29);
				// AS3.g:476:29: ( defaultStatement )?
				if (stream_defaultStatement.HasNext)
				{
					DebugLocation(476, 29);
					adaptor.AddChild(root_1, stream_defaultStatement.NextTree());

				}
				stream_defaultStatement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchBlock", 54);
			LeaveRule("switchBlock", 54);
			LeaveRule_switchBlock();
		}
		DebugLocation(477, 1);
		} finally { DebugExitRule(GrammarFileName, "switchBlock"); }
		return retval;

	}
	// $ANTLR end "switchBlock"

	partial void EnterRule_caseStatement();
	partial void LeaveRule_caseStatement();
	// $ANTLR start "caseStatement"
	// AS3.g:479:1: caseStatement : CASE expression COLON !l= switchStatementList ;
	[GrammarRule("caseStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> caseStatement()
	{
		EnterRule_caseStatement();
		EnterRule("caseStatement", 55);
		TraceIn("caseStatement", 55);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken CASE179 = default(IToken);
		IToken COLON181 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> l = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression180 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree CASE179_tree = default(CommonTree);
		CommonTree COLON181_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "caseStatement");
		DebugLocation(479, 1);
		try
		{
			// AS3.g:480:2: ( CASE expression COLON !l= switchStatementList )
			DebugEnterAlt(1);
			// AS3.g:480:4: CASE expression COLON !l= switchStatementList
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(480, 4);
			CASE179=(IToken)Match(input,CASE,Follow._CASE_in_caseStatement2608); if (state.failed) return retval;
			if (state.backtracking == 0) {
			CASE179_tree = (CommonTree)adaptor.Create(CASE179);
			adaptor.AddChild(root_0, CASE179_tree);
			}
			DebugLocation(480, 9);
			PushFollow(Follow._expression_in_caseStatement2610);
			expression180=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression180.Tree);
			DebugLocation(480, 25);
			COLON181=(IToken)Match(input,COLON,Follow._COLON_in_caseStatement2612); if (state.failed) return retval;
			DebugLocation(480, 28);
			PushFollow(Follow._switchStatementList_in_caseStatement2617);
			l=switchStatementList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, l.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseStatement", 55);
			LeaveRule("caseStatement", 55);
			LeaveRule_caseStatement();
		}
		DebugLocation(481, 1);
		} finally { DebugExitRule(GrammarFileName, "caseStatement"); }
		return retval;

	}
	// $ANTLR end "caseStatement"

	partial void EnterRule_defaultStatement();
	partial void LeaveRule_defaultStatement();
	// $ANTLR start "defaultStatement"
	// AS3.g:483:1: defaultStatement : DEFAULT COLON !l= switchStatementList ;
	[GrammarRule("defaultStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> defaultStatement()
	{
		EnterRule_defaultStatement();
		EnterRule("defaultStatement", 56);
		TraceIn("defaultStatement", 56);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DEFAULT182 = default(IToken);
		IToken COLON183 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> l = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DEFAULT182_tree = default(CommonTree);
		CommonTree COLON183_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "defaultStatement");
		DebugLocation(483, 1);
		try
		{
			// AS3.g:484:2: ( DEFAULT COLON !l= switchStatementList )
			DebugEnterAlt(1);
			// AS3.g:484:4: DEFAULT COLON !l= switchStatementList
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(484, 4);
			DEFAULT182=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultStatement2630); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DEFAULT182_tree = (CommonTree)adaptor.Create(DEFAULT182);
			adaptor.AddChild(root_0, DEFAULT182_tree);
			}
			DebugLocation(484, 17);
			COLON183=(IToken)Match(input,COLON,Follow._COLON_in_defaultStatement2632); if (state.failed) return retval;
			DebugLocation(484, 20);
			PushFollow(Follow._switchStatementList_in_defaultStatement2637);
			l=switchStatementList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, l.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultStatement", 56);
			LeaveRule("defaultStatement", 56);
			LeaveRule_defaultStatement();
		}
		DebugLocation(485, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultStatement"); }
		return retval;

	}
	// $ANTLR end "defaultStatement"

	partial void EnterRule_switchStatementList();
	partial void LeaveRule_switchStatementList();
	// $ANTLR start "switchStatementList"
	// AS3.g:487:1: switchStatementList : ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) ;
	[GrammarRule("switchStatementList")]
	private AstParserRuleReturnScope<CommonTree, IToken> switchStatementList()
	{
		EnterRule_switchStatementList();
		EnterRule("switchStatementList", 57);
		TraceIn("switchStatementList", 57);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> statement184 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "switchStatementList");
		DebugLocation(487, 1);
		try
		{
			// AS3.g:488:2: ( ( statement )* -> ^( SWITCH_STATEMENT_LIST ( statement )* ) )
			DebugEnterAlt(1);
			// AS3.g:488:4: ( statement )*
			{
			DebugLocation(488, 4);
			// AS3.g:488:4: ( statement )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==DEFAULT))
				{
					int LA42_2 = input.LA(2);

					if ((LA42_2==XML))
					{
						alt42 = 1;
					}


				}
				else if ((LA42_1==AS||LA42_1==BNOT||LA42_1==BREAK||LA42_1==CONST||LA42_1==CONTINUE||(LA42_1>=DEC && LA42_1<=DECIMAL_LITERAL)||LA42_1==DO||(LA42_1>=DYNAMIC && LA42_1<=E4X_ATTRI)||(LA42_1>=FALSE && LA42_1<=FOR)||LA42_1==FUNCTION||LA42_1==GET||(LA42_1>=HEX_LITERAL && LA42_1<=IDENT)||LA42_1==IF||LA42_1==INC||(LA42_1>=INTERNAL && LA42_1<=IS)||(LA42_1>=LBRACK && LA42_1<=LCURLY)||LA42_1==LNOT||LA42_1==LPAREN||LA42_1==MINUS||LA42_1==NAMESPACE||LA42_1==NEW||LA42_1==NULL||LA42_1==OCTAL_LITERAL||LA42_1==PLUS||LA42_1==PRIVATE||(LA42_1>=PROTECTED && LA42_1<=PUBLIC)||LA42_1==REGEX_LITERAL||LA42_1==RETURN||(LA42_1>=SEMI && LA42_1<=SET)||(LA42_1>=STRING_LITERAL_DOUBLE && LA42_1<=SWITCH)||LA42_1==TRUE||(LA42_1>=USE && LA42_1<=VAR)||LA42_1==WHILE||LA42_1==WITH||LA42_1==XML||LA42_1==XML_LITERAL||LA42_1==243||(LA42_1>=253 && LA42_1<=257)))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:488:4: statement
					{
					DebugLocation(488, 4);
					PushFollow(Follow._statement_in_switchStatementList2649);
					statement184=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_statement.Add(statement184.Tree);

					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }



			{
			// AST REWRITE
			// elements: statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 488:15: -> ^( SWITCH_STATEMENT_LIST ( statement )* )
			{
				DebugLocation(488, 18);
				// AS3.g:488:18: ^( SWITCH_STATEMENT_LIST ( statement )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(488, 20);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(SWITCH_STATEMENT_LIST, "SWITCH_STATEMENT_LIST"), root_1);

				DebugLocation(488, 42);
				// AS3.g:488:42: ( statement )*
				while ( stream_statement.HasNext )
				{
					DebugLocation(488, 42);
					adaptor.AddChild(root_1, stream_statement.NextTree());

				}
				stream_statement.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatementList", 57);
			LeaveRule("switchStatementList", 57);
			LeaveRule_switchStatementList();
		}
		DebugLocation(489, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatementList"); }
		return retval;

	}
	// $ANTLR end "switchStatementList"

	partial void EnterRule_forEachStatement();
	partial void LeaveRule_forEachStatement();
	// $ANTLR start "forEachStatement"
	// AS3.g:491:1: forEachStatement : f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH_LOOP $f forInClause statement ) ;
	[GrammarRule("forEachStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forEachStatement()
	{
		EnterRule_forEachStatement();
		EnterRule("forEachStatement", 58);
		TraceIn("forEachStatement", 58);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken f = default(IToken);
		IToken EACH185 = default(IToken);
		IToken LPAREN186 = default(IToken);
		IToken RPAREN188 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> forInClause187 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement189 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree f_tree = default(CommonTree);
		CommonTree EACH185_tree = default(CommonTree);
		CommonTree LPAREN186_tree = default(CommonTree);
		CommonTree RPAREN188_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_EACH=new RewriteRuleITokenStream(adaptor,"token EACH");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_forInClause=new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "forEachStatement");
		DebugLocation(491, 1);
		try
		{
			// AS3.g:492:2: (f= FOR EACH LPAREN forInClause RPAREN statement -> ^( FOR_EACH_LOOP $f forInClause statement ) )
			DebugEnterAlt(1);
			// AS3.g:492:4: f= FOR EACH LPAREN forInClause RPAREN statement
			{
			DebugLocation(492, 5);
			f=(IToken)Match(input,FOR,Follow._FOR_in_forEachStatement2672); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(f);

			DebugLocation(492, 10);
			EACH185=(IToken)Match(input,EACH,Follow._EACH_in_forEachStatement2674); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EACH.Add(EACH185);

			DebugLocation(493, 3);
			LPAREN186=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forEachStatement2678); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN186);

			DebugLocation(494, 3);
			PushFollow(Follow._forInClause_in_forEachStatement2682);
			forInClause187=forInClause();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_forInClause.Add(forInClause187.Tree);
			DebugLocation(495, 3);
			RPAREN188=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forEachStatement2686); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN188);

			DebugLocation(496, 3);
			PushFollow(Follow._statement_in_forEachStatement2690);
			statement189=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement189.Tree);


			{
			// AST REWRITE
			// elements: f, forInClause, statement
			// token labels: f
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleITokenStream stream_f=new RewriteRuleITokenStream(adaptor,"token f",f);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 497:3: -> ^( FOR_EACH_LOOP $f forInClause statement )
			{
				DebugLocation(497, 6);
				// AS3.g:497:6: ^( FOR_EACH_LOOP $f forInClause statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(497, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_EACH_LOOP, "FOR_EACH_LOOP"), root_1);

				DebugLocation(497, 23);
				adaptor.AddChild(root_1, stream_f.NextNode());
				DebugLocation(497, 25);
				adaptor.AddChild(root_1, stream_forInClause.NextTree());
				DebugLocation(497, 37);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forEachStatement", 58);
			LeaveRule("forEachStatement", 58);
			LeaveRule_forEachStatement();
		}
		DebugLocation(498, 1);
		} finally { DebugExitRule(GrammarFileName, "forEachStatement"); }
		return retval;

	}
	// $ANTLR end "forEachStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// AS3.g:500:1: forStatement : FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) ) ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 59);
		TraceIn("forStatement", 59);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken FOR190 = default(IToken);
		IToken LPAREN191 = default(IToken);
		IToken RPAREN193 = default(IToken);
		IToken RPAREN196 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> forInClause192 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement194 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> traditionalForClause195 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement197 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FOR190_tree = default(CommonTree);
		CommonTree LPAREN191_tree = default(CommonTree);
		CommonTree RPAREN193_tree = default(CommonTree);
		CommonTree RPAREN196_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FOR=new RewriteRuleITokenStream(adaptor,"token FOR");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_forInClause=new RewriteRuleSubtreeStream(adaptor,"rule forInClause");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_traditionalForClause=new RewriteRuleSubtreeStream(adaptor,"rule traditionalForClause");
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(500, 1);
		try
		{
			// AS3.g:502:2: ( FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) ) )
			DebugEnterAlt(1);
			// AS3.g:502:4: FOR LPAREN ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )
			{
			DebugLocation(502, 4);
			FOR190=(IToken)Match(input,FOR,Follow._FOR_in_forStatement2717); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FOR.Add(FOR190);

			DebugLocation(503, 3);
			LPAREN191=(IToken)Match(input,LPAREN,Follow._LPAREN_in_forStatement2721); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN191);

			DebugLocation(504, 3);
			// AS3.g:504:3: ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )
			int alt43=2;
			try { DebugEnterSubRule(43);
			try { DebugEnterDecision(43, false);
			try
			{
				alt43 = dfa43.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(43); }
			switch (alt43)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:504:5: forInClause RPAREN statement
				{
				DebugLocation(504, 5);
				PushFollow(Follow._forInClause_in_forStatement2727);
				forInClause192=forInClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_forInClause.Add(forInClause192.Tree);
				DebugLocation(504, 17);
				RPAREN193=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement2729); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN193);

				DebugLocation(504, 24);
				PushFollow(Follow._statement_in_forStatement2731);
				statement194=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement194.Tree);


				{
				// AST REWRITE
				// elements: FOR, LPAREN, forInClause, RPAREN, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 505:4: -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement )
				{
					DebugLocation(505, 7);
					// AS3.g:505:7: ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(505, 9);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_IN_LOOP, "FOR_IN_LOOP"), root_1);

					DebugLocation(505, 21);
					adaptor.AddChild(root_1, stream_FOR.NextNode());
					DebugLocation(505, 25);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(505, 32);
					adaptor.AddChild(root_1, stream_forInClause.NextTree());
					DebugLocation(505, 44);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());
					DebugLocation(505, 51);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:507:5: traditionalForClause RPAREN statement
				{
				DebugLocation(507, 5);
				PushFollow(Follow._traditionalForClause_in_forStatement2757);
				traditionalForClause195=traditionalForClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_traditionalForClause.Add(traditionalForClause195.Tree);
				DebugLocation(507, 26);
				RPAREN196=(IToken)Match(input,RPAREN,Follow._RPAREN_in_forStatement2759); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN196);

				DebugLocation(507, 33);
				PushFollow(Follow._statement_in_forStatement2761);
				statement197=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(statement197.Tree);


				{
				// AST REWRITE
				// elements: FOR, LPAREN, traditionalForClause, RPAREN, statement
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 508:4: -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement )
				{
					DebugLocation(508, 7);
					// AS3.g:508:7: ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(508, 9);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_LOOP, "FOR_LOOP"), root_1);

					DebugLocation(508, 18);
					adaptor.AddChild(root_1, stream_FOR.NextNode());
					DebugLocation(508, 22);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(508, 29);
					adaptor.AddChild(root_1, stream_traditionalForClause.NextTree());
					DebugLocation(508, 50);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());
					DebugLocation(508, 57);
					adaptor.AddChild(root_1, stream_statement.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(43); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 59);
			LeaveRule("forStatement", 59);
			LeaveRule_forStatement();
		}
		DebugLocation(510, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_traditionalForClause();
	partial void LeaveRule_traditionalForClause();
	// $ANTLR start "traditionalForClause"
	// AS3.g:512:1: traditionalForClause : forInit semi forCond semi forIter ;
	[GrammarRule("traditionalForClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> traditionalForClause()
	{
		EnterRule_traditionalForClause();
		EnterRule("traditionalForClause", 60);
		TraceIn("traditionalForClause", 60);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> forInit198 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi199 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forCond200 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi201 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forIter202 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "traditionalForClause");
		DebugLocation(512, 1);
		try
		{
			// AS3.g:513:2: ( forInit semi forCond semi forIter )
			DebugEnterAlt(1);
			// AS3.g:513:4: forInit semi forCond semi forIter
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(513, 4);
			PushFollow(Follow._forInit_in_traditionalForClause2795);
			forInit198=forInit();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInit198.Tree);
			DebugLocation(513, 13);
			PushFollow(Follow._semi_in_traditionalForClause2798);
			semi199=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi199.Tree);
			DebugLocation(514, 3);
			PushFollow(Follow._forCond_in_traditionalForClause2803);
			forCond200=forCond();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forCond200.Tree);
			DebugLocation(514, 12);
			PushFollow(Follow._semi_in_traditionalForClause2806);
			semi201=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, semi201.Tree);
			DebugLocation(515, 3);
			PushFollow(Follow._forIter_in_traditionalForClause2811);
			forIter202=forIter();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forIter202.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("traditionalForClause", 60);
			LeaveRule("traditionalForClause", 60);
			LeaveRule_traditionalForClause();
		}
		DebugLocation(516, 1);
		} finally { DebugExitRule(GrammarFileName, "traditionalForClause"); }
		return retval;

	}
	// $ANTLR end "traditionalForClause"

	partial void EnterRule_forInClause();
	partial void LeaveRule_forInClause();
	// $ANTLR start "forInClause"
	// AS3.g:518:1: forInClause : forInClauseDecl IN forInClauseTail ;
	[GrammarRule("forInClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInClause()
	{
		EnterRule_forInClause();
		EnterRule("forInClause", 61);
		TraceIn("forInClause", 61);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IN204 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> forInClauseDecl203 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forInClauseTail205 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IN204_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "forInClause");
		DebugLocation(518, 1);
		try
		{
			// AS3.g:519:2: ( forInClauseDecl IN forInClauseTail )
			DebugEnterAlt(1);
			// AS3.g:519:4: forInClauseDecl IN forInClauseTail
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(519, 4);
			PushFollow(Follow._forInClauseDecl_in_forInClause2825);
			forInClauseDecl203=forInClauseDecl();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInClauseDecl203.Tree);
			DebugLocation(519, 20);
			IN204=(IToken)Match(input,IN,Follow._IN_in_forInClause2827); if (state.failed) return retval;
			if (state.backtracking == 0) {
			IN204_tree = (CommonTree)adaptor.Create(IN204);
			adaptor.AddChild(root_0, IN204_tree);
			}
			DebugLocation(519, 23);
			PushFollow(Follow._forInClauseTail_in_forInClause2829);
			forInClauseTail205=forInClauseTail();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, forInClauseTail205.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClause", 61);
			LeaveRule("forInClause", 61);
			LeaveRule_forInClause();
		}
		DebugLocation(520, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClause"); }
		return retval;

	}
	// $ANTLR end "forInClause"

	partial void EnterRule_forInClauseDecl();
	partial void LeaveRule_forInClauseDecl();
	// $ANTLR start "forInClauseDecl"
	// AS3.g:522:1: forInClauseDecl : ( varOrConst ident ( typeExpression )? | ident );
	[GrammarRule("forInClauseDecl")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInClauseDecl()
	{
		EnterRule_forInClauseDecl();
		EnterRule("forInClauseDecl", 62);
		TraceIn("forInClauseDecl", 62);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> varOrConst206 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident207 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression208 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident209 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "forInClauseDecl");
		DebugLocation(522, 1);
		try
		{
			// AS3.g:523:2: ( varOrConst ident ( typeExpression )? | ident )
			int alt45=2;
			try { DebugEnterDecision(45, false);
			int LA45_1 = input.LA(1);

			if ((LA45_1==CONST||LA45_1==VAR))
			{
				alt45 = 1;
			}
			else if ((LA45_1==AS||LA45_1==DYNAMIC||LA45_1==GET||LA45_1==IDENT||LA45_1==IS||LA45_1==NAMESPACE||LA45_1==SET||LA45_1==SUPER||LA45_1==USE||LA45_1==XML))
			{
				alt45 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 45, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(45); }
			switch (alt45)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:523:4: varOrConst ident ( typeExpression )?
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(523, 4);
				PushFollow(Follow._varOrConst_in_forInClauseDecl2840);
				varOrConst206=varOrConst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, varOrConst206.Tree);
				DebugLocation(523, 15);
				PushFollow(Follow._ident_in_forInClauseDecl2842);
				ident207=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident207.Tree);
				DebugLocation(523, 21);
				// AS3.g:523:21: ( typeExpression )?
				int alt44=2;
				try { DebugEnterSubRule(44);
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==COLON))
				{
					alt44 = 1;
				}
				} finally { DebugExitDecision(44); }
				switch (alt44)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:523:21: typeExpression
					{
					DebugLocation(523, 21);
					PushFollow(Follow._typeExpression_in_forInClauseDecl2844);
					typeExpression208=typeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, typeExpression208.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(44); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:524:11: ident
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(524, 11);
				PushFollow(Follow._ident_in_forInClauseDecl2858);
				ident209=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident209.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClauseDecl", 62);
			LeaveRule("forInClauseDecl", 62);
			LeaveRule_forInClauseDecl();
		}
		DebugLocation(525, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClauseDecl"); }
		return retval;

	}
	// $ANTLR end "forInClauseDecl"

	partial void EnterRule_forInClauseTail();
	partial void LeaveRule_forInClauseTail();
	// $ANTLR start "forInClauseTail"
	// AS3.g:528:1: forInClauseTail : expressionList ;
	[GrammarRule("forInClauseTail")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInClauseTail()
	{
		EnterRule_forInClauseTail();
		EnterRule("forInClauseTail", 63);
		TraceIn("forInClauseTail", 63);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> expressionList210 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "forInClauseTail");
		DebugLocation(528, 1);
		try
		{
			// AS3.g:529:2: ( expressionList )
			DebugEnterAlt(1);
			// AS3.g:529:4: expressionList
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(529, 4);
			PushFollow(Follow._expressionList_in_forInClauseTail2870);
			expressionList210=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expressionList210.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInClauseTail", 63);
			LeaveRule("forInClauseTail", 63);
			LeaveRule_forInClauseTail();
		}
		DebugLocation(530, 1);
		} finally { DebugExitRule(GrammarFileName, "forInClauseTail"); }
		return retval;

	}
	// $ANTLR end "forInClauseTail"

	partial void EnterRule_forInit();
	partial void LeaveRule_forInit();
	// $ANTLR start "forInit"
	// AS3.g:533:1: forInit : ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) ;
	[GrammarRule("forInit")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInit()
	{
		EnterRule_forInit();
		EnterRule("forInit", 64);
		TraceIn("forInit", 64);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> declaration211 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expressionList212 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_declaration=new RewriteRuleSubtreeStream(adaptor,"rule declaration");
		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forInit");
		DebugLocation(533, 1);
		try
		{
			// AS3.g:534:2: ( ( declaration | expressionList )? -> ^( FOR_INIT ( declaration )? ( expressionList )? ) )
			DebugEnterAlt(1);
			// AS3.g:534:4: ( declaration | expressionList )?
			{
			DebugLocation(534, 4);
			// AS3.g:534:4: ( declaration | expressionList )?
			int alt46=3;
			try { DebugEnterSubRule(46);
			try { DebugEnterDecision(46, false);
			int LA46_1 = input.LA(1);

			if ((LA46_1==CONST||LA46_1==VAR))
			{
				alt46 = 1;
			}
			else if ((LA46_1==AS||LA46_1==BNOT||(LA46_1>=DEC && LA46_1<=DECIMAL_LITERAL)||(LA46_1>=DYNAMIC && LA46_1<=E4X_ATTRI)||(LA46_1>=FALSE && LA46_1<=FLOAT_LITERAL)||LA46_1==FUNCTION||LA46_1==GET||(LA46_1>=HEX_LITERAL && LA46_1<=IDENT)||LA46_1==INC||(LA46_1>=INTERNAL && LA46_1<=IS)||(LA46_1>=LBRACK && LA46_1<=LCURLY)||LA46_1==LNOT||LA46_1==LPAREN||LA46_1==MINUS||LA46_1==NAMESPACE||LA46_1==NEW||LA46_1==NULL||LA46_1==OCTAL_LITERAL||LA46_1==PLUS||LA46_1==PRIVATE||(LA46_1>=PROTECTED && LA46_1<=PUBLIC)||LA46_1==REGEX_LITERAL||LA46_1==SET||(LA46_1>=STRING_LITERAL_DOUBLE && LA46_1<=SUPER)||LA46_1==TRUE||LA46_1==USE||LA46_1==XML||LA46_1==XML_LITERAL||LA46_1==243||(LA46_1>=255 && LA46_1<=257)))
			{
				alt46 = 2;
			}
			} finally { DebugExitDecision(46); }
			switch (alt46)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:534:5: declaration
				{
				DebugLocation(534, 5);
				PushFollow(Follow._declaration_in_forInit2884);
				declaration211=declaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_declaration.Add(declaration211.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:534:19: expressionList
				{
				DebugLocation(534, 19);
				PushFollow(Follow._expressionList_in_forInit2888);
				expressionList212=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList212.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(46); }



			{
			// AST REWRITE
			// elements: declaration, expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 535:3: -> ^( FOR_INIT ( declaration )? ( expressionList )? )
			{
				DebugLocation(535, 6);
				// AS3.g:535:6: ^( FOR_INIT ( declaration )? ( expressionList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(535, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_INIT, "FOR_INIT"), root_1);

				DebugLocation(535, 17);
				// AS3.g:535:17: ( declaration )?
				if (stream_declaration.HasNext)
				{
					DebugLocation(535, 17);
					adaptor.AddChild(root_1, stream_declaration.NextTree());

				}
				stream_declaration.Reset();
				DebugLocation(535, 30);
				// AS3.g:535:30: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(535, 30);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInit", 64);
			LeaveRule("forInit", 64);
			LeaveRule_forInit();
		}
		DebugLocation(536, 1);
		} finally { DebugExitRule(GrammarFileName, "forInit"); }
		return retval;

	}
	// $ANTLR end "forInit"

	partial void EnterRule_forCond();
	partial void LeaveRule_forCond();
	// $ANTLR start "forCond"
	// AS3.g:538:1: forCond : ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) ;
	[GrammarRule("forCond")]
	private AstParserRuleReturnScope<CommonTree, IToken> forCond()
	{
		EnterRule_forCond();
		EnterRule("forCond", 65);
		TraceIn("forCond", 65);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> expressionList213 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forCond");
		DebugLocation(538, 1);
		try
		{
			// AS3.g:539:2: ( ( expressionList )? -> ^( FOR_CONDITION ( expressionList )? ) )
			DebugEnterAlt(1);
			// AS3.g:539:4: ( expressionList )?
			{
			DebugLocation(539, 4);
			// AS3.g:539:4: ( expressionList )?
			int alt47=2;
			try { DebugEnterSubRule(47);
			try { DebugEnterDecision(47, false);
			int LA47_1 = input.LA(1);

			if ((LA47_1==AS||LA47_1==BNOT||(LA47_1>=DEC && LA47_1<=DECIMAL_LITERAL)||(LA47_1>=DYNAMIC && LA47_1<=E4X_ATTRI)||(LA47_1>=FALSE && LA47_1<=FLOAT_LITERAL)||LA47_1==FUNCTION||LA47_1==GET||(LA47_1>=HEX_LITERAL && LA47_1<=IDENT)||LA47_1==INC||(LA47_1>=INTERNAL && LA47_1<=IS)||(LA47_1>=LBRACK && LA47_1<=LCURLY)||LA47_1==LNOT||LA47_1==LPAREN||LA47_1==MINUS||LA47_1==NAMESPACE||LA47_1==NEW||LA47_1==NULL||LA47_1==OCTAL_LITERAL||LA47_1==PLUS||LA47_1==PRIVATE||(LA47_1>=PROTECTED && LA47_1<=PUBLIC)||LA47_1==REGEX_LITERAL||LA47_1==SET||(LA47_1>=STRING_LITERAL_DOUBLE && LA47_1<=SUPER)||LA47_1==TRUE||LA47_1==USE||LA47_1==XML||LA47_1==XML_LITERAL||LA47_1==243||(LA47_1>=255 && LA47_1<=257)))
			{
				alt47 = 1;
			}
			} finally { DebugExitDecision(47); }
			switch (alt47)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:539:4: expressionList
				{
				DebugLocation(539, 4);
				PushFollow(Follow._expressionList_in_forCond2916);
				expressionList213=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList213.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(47); }



			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 540:3: -> ^( FOR_CONDITION ( expressionList )? )
			{
				DebugLocation(540, 6);
				// AS3.g:540:6: ^( FOR_CONDITION ( expressionList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(540, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_CONDITION, "FOR_CONDITION"), root_1);

				DebugLocation(540, 22);
				// AS3.g:540:22: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(540, 22);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forCond", 65);
			LeaveRule("forCond", 65);
			LeaveRule_forCond();
		}
		DebugLocation(541, 1);
		} finally { DebugExitRule(GrammarFileName, "forCond"); }
		return retval;

	}
	// $ANTLR end "forCond"

	partial void EnterRule_forIter();
	partial void LeaveRule_forIter();
	// $ANTLR start "forIter"
	// AS3.g:543:1: forIter : ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) ;
	[GrammarRule("forIter")]
	private AstParserRuleReturnScope<CommonTree, IToken> forIter()
	{
		EnterRule_forIter();
		EnterRule("forIter", 66);
		TraceIn("forIter", 66);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> expressionList214 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "forIter");
		DebugLocation(543, 1);
		try
		{
			// AS3.g:544:2: ( ( expressionList )? -> ^( FOR_ITERATOR ( expressionList )? ) )
			DebugEnterAlt(1);
			// AS3.g:544:4: ( expressionList )?
			{
			DebugLocation(544, 4);
			// AS3.g:544:4: ( expressionList )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==AS||LA48_1==BNOT||(LA48_1>=DEC && LA48_1<=DECIMAL_LITERAL)||(LA48_1>=DYNAMIC && LA48_1<=E4X_ATTRI)||(LA48_1>=FALSE && LA48_1<=FLOAT_LITERAL)||LA48_1==FUNCTION||LA48_1==GET||(LA48_1>=HEX_LITERAL && LA48_1<=IDENT)||LA48_1==INC||(LA48_1>=INTERNAL && LA48_1<=IS)||(LA48_1>=LBRACK && LA48_1<=LCURLY)||LA48_1==LNOT||LA48_1==LPAREN||LA48_1==MINUS||LA48_1==NAMESPACE||LA48_1==NEW||LA48_1==NULL||LA48_1==OCTAL_LITERAL||LA48_1==PLUS||LA48_1==PRIVATE||(LA48_1>=PROTECTED && LA48_1<=PUBLIC)||LA48_1==REGEX_LITERAL||LA48_1==SET||(LA48_1>=STRING_LITERAL_DOUBLE && LA48_1<=SUPER)||LA48_1==TRUE||LA48_1==USE||LA48_1==XML||LA48_1==XML_LITERAL||LA48_1==243||(LA48_1>=255 && LA48_1<=257)))
			{
				alt48 = 1;
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:544:4: expressionList
				{
				DebugLocation(544, 4);
				PushFollow(Follow._expressionList_in_forIter2939);
				expressionList214=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList214.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }



			{
			// AST REWRITE
			// elements: expressionList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 545:3: -> ^( FOR_ITERATOR ( expressionList )? )
			{
				DebugLocation(545, 6);
				// AS3.g:545:6: ^( FOR_ITERATOR ( expressionList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(545, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FOR_ITERATOR, "FOR_ITERATOR"), root_1);

				DebugLocation(545, 21);
				// AS3.g:545:21: ( expressionList )?
				if (stream_expressionList.HasNext)
				{
					DebugLocation(545, 21);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());

				}
				stream_expressionList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forIter", 66);
			LeaveRule("forIter", 66);
			LeaveRule_forIter();
		}
		DebugLocation(546, 1);
		} finally { DebugExitRule(GrammarFileName, "forIter"); }
		return retval;

	}
	// $ANTLR end "forIter"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// AS3.g:548:1: whileStatement : WHILE condition statement -> ^( WHILE_LOOP condition statement ) ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 67);
		TraceIn("whileStatement", 67);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WHILE215 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition216 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement217 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WHILE215_tree = default(CommonTree);
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(548, 1);
		try
		{
			// AS3.g:549:2: ( WHILE condition statement -> ^( WHILE_LOOP condition statement ) )
			DebugEnterAlt(1);
			// AS3.g:549:4: WHILE condition statement
			{
			DebugLocation(549, 4);
			WHILE215=(IToken)Match(input,WHILE,Follow._WHILE_in_whileStatement2962); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE215);

			DebugLocation(549, 10);
			PushFollow(Follow._condition_in_whileStatement2964);
			condition216=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition216.Tree);
			DebugLocation(549, 20);
			PushFollow(Follow._statement_in_whileStatement2966);
			statement217=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement217.Tree);


			{
			// AST REWRITE
			// elements: condition, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 550:3: -> ^( WHILE_LOOP condition statement )
			{
				DebugLocation(550, 6);
				// AS3.g:550:6: ^( WHILE_LOOP condition statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(550, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(WHILE_LOOP, "WHILE_LOOP"), root_1);

				DebugLocation(550, 19);
				adaptor.AddChild(root_1, stream_condition.NextTree());
				DebugLocation(550, 29);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 67);
			LeaveRule("whileStatement", 67);
			LeaveRule_whileStatement();
		}
		DebugLocation(551, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_doWhileStatement();
	partial void LeaveRule_doWhileStatement();
	// $ANTLR start "doWhileStatement"
	// AS3.g:553:1: doWhileStatement : DO statement WHILE condition semi -> ^( DO_WHILE_LOOP DO statement WHILE condition ) ;
	[GrammarRule("doWhileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement()
	{
		EnterRule_doWhileStatement();
		EnterRule("doWhileStatement", 68);
		TraceIn("doWhileStatement", 68);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DO218 = default(IToken);
		IToken WHILE220 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement219 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> condition221 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi222 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DO218_tree = default(CommonTree);
		CommonTree WHILE220_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DO=new RewriteRuleITokenStream(adaptor,"token DO");
		RewriteRuleITokenStream stream_WHILE=new RewriteRuleITokenStream(adaptor,"token WHILE");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "doWhileStatement");
		DebugLocation(553, 1);
		try
		{
			// AS3.g:554:2: ( DO statement WHILE condition semi -> ^( DO_WHILE_LOOP DO statement WHILE condition ) )
			DebugEnterAlt(1);
			// AS3.g:554:4: DO statement WHILE condition semi
			{
			DebugLocation(554, 4);
			DO218=(IToken)Match(input,DO,Follow._DO_in_doWhileStatement2989); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DO.Add(DO218);

			DebugLocation(554, 7);
			PushFollow(Follow._statement_in_doWhileStatement2991);
			statement219=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement219.Tree);
			DebugLocation(554, 17);
			WHILE220=(IToken)Match(input,WHILE,Follow._WHILE_in_doWhileStatement2993); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILE.Add(WHILE220);

			DebugLocation(554, 23);
			PushFollow(Follow._condition_in_doWhileStatement2995);
			condition221=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_condition.Add(condition221.Tree);
			DebugLocation(554, 33);
			PushFollow(Follow._semi_in_doWhileStatement2997);
			semi222=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(semi222.Tree);


			{
			// AST REWRITE
			// elements: DO, statement, WHILE, condition
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 555:3: -> ^( DO_WHILE_LOOP DO statement WHILE condition )
			{
				DebugLocation(555, 6);
				// AS3.g:555:6: ^( DO_WHILE_LOOP DO statement WHILE condition )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(555, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DO_WHILE_LOOP, "DO_WHILE_LOOP"), root_1);

				DebugLocation(555, 22);
				adaptor.AddChild(root_1, stream_DO.NextNode());
				DebugLocation(555, 25);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(555, 35);
				adaptor.AddChild(root_1, stream_WHILE.NextNode());
				DebugLocation(555, 41);
				adaptor.AddChild(root_1, stream_condition.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doWhileStatement", 68);
			LeaveRule("doWhileStatement", 68);
			LeaveRule_doWhileStatement();
		}
		DebugLocation(556, 1);
		} finally { DebugExitRule(GrammarFileName, "doWhileStatement"); }
		return retval;

	}
	// $ANTLR end "doWhileStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// AS3.g:558:1: withStatement : WITH condition statement ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 69);
		TraceIn("withStatement", 69);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken WITH223 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition224 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement225 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree WITH223_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(558, 1);
		try
		{
			// AS3.g:559:2: ( WITH condition statement )
			DebugEnterAlt(1);
			// AS3.g:559:4: WITH condition statement
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(559, 4);
			WITH223=(IToken)Match(input,WITH,Follow._WITH_in_withStatement3025); if (state.failed) return retval;
			if (state.backtracking == 0) {
			WITH223_tree = (CommonTree)adaptor.Create(WITH223);
			adaptor.AddChild(root_0, WITH223_tree);
			}
			DebugLocation(559, 9);
			PushFollow(Follow._condition_in_withStatement3027);
			condition224=condition();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, condition224.Tree);
			DebugLocation(559, 19);
			PushFollow(Follow._statement_in_withStatement3029);
			statement225=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement225.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 69);
			LeaveRule("withStatement", 69);
			LeaveRule_withStatement();
		}
		DebugLocation(560, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_defaultXMLNamespaceStatement();
	partial void LeaveRule_defaultXMLNamespaceStatement();
	// $ANTLR start "defaultXMLNamespaceStatement"
	// AS3.g:562:1: defaultXMLNamespaceStatement : DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) ;
	[GrammarRule("defaultXMLNamespaceStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> defaultXMLNamespaceStatement()
	{
		EnterRule_defaultXMLNamespaceStatement();
		EnterRule("defaultXMLNamespaceStatement", 70);
		TraceIn("defaultXMLNamespaceStatement", 70);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DEFAULT226 = default(IToken);
		IToken XML227 = default(IToken);
		IToken NAMESPACE228 = default(IToken);
		IToken ASSIGN229 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression230 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> semi231 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DEFAULT226_tree = default(CommonTree);
		CommonTree XML227_tree = default(CommonTree);
		CommonTree NAMESPACE228_tree = default(CommonTree);
		CommonTree ASSIGN229_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DEFAULT=new RewriteRuleITokenStream(adaptor,"token DEFAULT");
		RewriteRuleITokenStream stream_XML=new RewriteRuleITokenStream(adaptor,"token XML");
		RewriteRuleITokenStream stream_NAMESPACE=new RewriteRuleITokenStream(adaptor,"token NAMESPACE");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_semi=new RewriteRuleSubtreeStream(adaptor,"rule semi");
		try { DebugEnterRule(GrammarFileName, "defaultXMLNamespaceStatement");
		DebugLocation(562, 1);
		try
		{
			// AS3.g:563:2: ( DEFAULT XML NAMESPACE ASSIGN expression semi -> ^( DEFAULT_XML_NAMESPACE expression ) )
			DebugEnterAlt(1);
			// AS3.g:563:4: DEFAULT XML NAMESPACE ASSIGN expression semi
			{
			DebugLocation(563, 4);
			DEFAULT226=(IToken)Match(input,DEFAULT,Follow._DEFAULT_in_defaultXMLNamespaceStatement3040); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DEFAULT.Add(DEFAULT226);

			DebugLocation(563, 12);
			XML227=(IToken)Match(input,XML,Follow._XML_in_defaultXMLNamespaceStatement3042); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_XML.Add(XML227);

			DebugLocation(563, 16);
			NAMESPACE228=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_defaultXMLNamespaceStatement3044); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NAMESPACE.Add(NAMESPACE228);

			DebugLocation(563, 26);
			ASSIGN229=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_defaultXMLNamespaceStatement3046); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN229);

			DebugLocation(563, 33);
			PushFollow(Follow._expression_in_defaultXMLNamespaceStatement3048);
			expression230=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression230.Tree);
			DebugLocation(563, 44);
			PushFollow(Follow._semi_in_defaultXMLNamespaceStatement3050);
			semi231=semi();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_semi.Add(semi231.Tree);


			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 564:3: -> ^( DEFAULT_XML_NAMESPACE expression )
			{
				DebugLocation(564, 6);
				// AS3.g:564:6: ^( DEFAULT_XML_NAMESPACE expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(564, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(DEFAULT_XML_NAMESPACE, "DEFAULT_XML_NAMESPACE"), root_1);

				DebugLocation(564, 30);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultXMLNamespaceStatement", 70);
			LeaveRule("defaultXMLNamespaceStatement", 70);
			LeaveRule_defaultXMLNamespaceStatement();
		}
		DebugLocation(565, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultXMLNamespaceStatement"); }
		return retval;

	}
	// $ANTLR end "defaultXMLNamespaceStatement"

	partial void EnterRule_typeExpression();
	partial void LeaveRule_typeExpression();
	// $ANTLR start "typeExpression"
	// AS3.g:567:1: typeExpression : COLON ( typeIdentifier | 'void' | STAR ) -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? ) ;
	[GrammarRule("typeExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> typeExpression()
	{
		EnterRule_typeExpression();
		EnterRule("typeExpression", 71);
		TraceIn("typeExpression", 71);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COLON232 = default(IToken);
		IToken string_literal234 = default(IToken);
		IToken STAR235 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> typeIdentifier233 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON232_tree = default(CommonTree);
		CommonTree string_literal234_tree = default(CommonTree);
		CommonTree STAR235_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_257=new RewriteRuleITokenStream(adaptor,"token 257");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleSubtreeStream stream_typeIdentifier=new RewriteRuleSubtreeStream(adaptor,"rule typeIdentifier");
		try { DebugEnterRule(GrammarFileName, "typeExpression");
		DebugLocation(567, 4);
		try
		{
			// AS3.g:568:2: ( COLON ( typeIdentifier | 'void' | STAR ) -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? ) )
			DebugEnterAlt(1);
			// AS3.g:569:3: COLON ( typeIdentifier | 'void' | STAR )
			{
			DebugLocation(569, 3);
			COLON232=(IToken)Match(input,COLON,Follow._COLON_in_typeExpression3075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON232);

			DebugLocation(569, 9);
			// AS3.g:569:9: ( typeIdentifier | 'void' | STAR )
			int alt49=3;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case IS:
			case NAMESPACE:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt49 = 1;
				}
				break;
			case 257:
				{
				alt49 = 2;
				}
				break;
			case STAR:
				{
				alt49 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:569:10: typeIdentifier
				{
				DebugLocation(569, 10);
				PushFollow(Follow._typeIdentifier_in_typeExpression3078);
				typeIdentifier233=typeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeIdentifier.Add(typeIdentifier233.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:569:27: 'void'
				{
				DebugLocation(569, 27);
				string_literal234=(IToken)Match(input,257,Follow._257_in_typeExpression3082); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_257.Add(string_literal234);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:569:36: STAR
				{
				DebugLocation(569, 36);
				STAR235=(IToken)Match(input,STAR,Follow._STAR_in_typeExpression3086); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR235);


				}
				break;

			}
			} finally { DebugExitSubRule(49); }



			{
			// AST REWRITE
			// elements: COLON, typeIdentifier, 257, STAR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 570:3: -> ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? )
			{
				DebugLocation(570, 6);
				// AS3.g:570:6: ^( TYPE_SPEC COLON ( typeIdentifier )? ( 'void' )? ( STAR )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(570, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(TYPE_SPEC, "TYPE_SPEC"), root_1);

				DebugLocation(570, 18);
				adaptor.AddChild(root_1, stream_COLON.NextNode());
				DebugLocation(570, 24);
				// AS3.g:570:24: ( typeIdentifier )?
				if (stream_typeIdentifier.HasNext)
				{
					DebugLocation(570, 24);
					adaptor.AddChild(root_1, stream_typeIdentifier.NextTree());

				}
				stream_typeIdentifier.Reset();
				DebugLocation(570, 40);
				// AS3.g:570:40: ( 'void' )?
				if (stream_257.HasNext)
				{
					DebugLocation(570, 40);
					adaptor.AddChild(root_1, stream_257.NextNode());

				}
				stream_257.Reset();
				DebugLocation(570, 48);
				// AS3.g:570:48: ( STAR )?
				if (stream_STAR.HasNext)
				{
					DebugLocation(570, 48);
					adaptor.AddChild(root_1, stream_STAR.NextNode());

				}
				stream_STAR.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeExpression", 71);
			LeaveRule("typeExpression", 71);
			LeaveRule_typeExpression();
		}
		DebugLocation(571, 4);
		} finally { DebugExitRule(GrammarFileName, "typeExpression"); }
		return retval;

	}
	// $ANTLR end "typeExpression"

	partial void EnterRule_typeIdentifier();
	partial void LeaveRule_typeIdentifier();
	// $ANTLR start "typeIdentifier"
	// AS3.g:573:1: typeIdentifier : ident ( propOrIdent )* ;
	[GrammarRule("typeIdentifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> typeIdentifier()
	{
		EnterRule_typeIdentifier();
		EnterRule("typeIdentifier", 72);
		TraceIn("typeIdentifier", 72);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> ident236 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propOrIdent237 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "typeIdentifier");
		DebugLocation(573, 4);
		try
		{
			// AS3.g:574:5: ( ident ( propOrIdent )* )
			DebugEnterAlt(1);
			// AS3.g:575:5: ident ( propOrIdent )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(575, 5);
			PushFollow(Follow._ident_in_typeIdentifier3127);
			ident236=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident236.Tree);
			DebugLocation(575, 11);
			// AS3.g:575:11: ( propOrIdent )*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_1 = input.LA(1);

				if ((LA50_1==DOT))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:575:12: propOrIdent
					{
					DebugLocation(575, 12);
					PushFollow(Follow._propOrIdent_in_typeIdentifier3130);
					propOrIdent237=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, propOrIdent237.Tree);

					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("typeIdentifier", 72);
			LeaveRule("typeIdentifier", 72);
			LeaveRule_typeIdentifier();
		}
		DebugLocation(576, 4);
		} finally { DebugExitRule(GrammarFileName, "typeIdentifier"); }
		return retval;

	}
	// $ANTLR end "typeIdentifier"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();
	// $ANTLR start "identifier"
	// AS3.g:578:1: identifier : ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )* ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 73);
		TraceIn("identifier", 73);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent238 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propOrIdent239 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		RewriteRuleSubtreeStream stream_propOrIdent=new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(578, 1);
		try
		{
			// AS3.g:579:2: ( ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )* )
			DebugEnterAlt(1);
			// AS3.g:579:4: ( qualifiedIdent -> qualifiedIdent ) ( propOrIdent -> propOrIdent )*
			{
			DebugLocation(579, 4);
			// AS3.g:579:4: ( qualifiedIdent -> qualifiedIdent )
			DebugEnterAlt(1);
			// AS3.g:579:5: qualifiedIdent
			{
			DebugLocation(579, 5);
			PushFollow(Follow._qualifiedIdent_in_identifier3148);
			qualifiedIdent238=qualifiedIdent();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent238.Tree);


			{
			// AST REWRITE
			// elements: qualifiedIdent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 579:20: -> qualifiedIdent
			{
				DebugLocation(579, 23);
				adaptor.AddChild(root_0, stream_qualifiedIdent.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(579, 39);
			// AS3.g:579:39: ( propOrIdent -> propOrIdent )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==DOT))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:579:40: propOrIdent
					{
					DebugLocation(579, 40);
					PushFollow(Follow._propOrIdent_in_identifier3156);
					propOrIdent239=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propOrIdent.Add(propOrIdent239.Tree);


					{
					// AST REWRITE
					// elements: propOrIdent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 579:52: -> propOrIdent
					{
						DebugLocation(579, 55);
						adaptor.AddChild(root_0, stream_propOrIdent.NextTree());

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 73);
			LeaveRule("identifier", 73);
			LeaveRule_identifier();
		}
		DebugLocation(580, 1);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_qualifiedIdent();
	partial void LeaveRule_qualifiedIdent();
	// $ANTLR start "qualifiedIdent"
	// AS3.g:582:1: qualifiedIdent options {k=1; } : ( ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident ) | ident );
	[GrammarRule("qualifiedIdent")]
	private AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent()
	{
		EnterRule_qualifiedIdent();
		EnterRule("qualifiedIdent", 74);
		TraceIn("qualifiedIdent", 74);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DBL_COLON241 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> namespaceName240 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident242 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident243 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DBL_COLON241_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DBL_COLON=new RewriteRuleITokenStream(adaptor,"token DBL_COLON");
		RewriteRuleSubtreeStream stream_namespaceName=new RewriteRuleSubtreeStream(adaptor,"rule namespaceName");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		try { DebugEnterRule(GrammarFileName, "qualifiedIdent");
		DebugLocation(582, 4);
		try
		{
			// AS3.g:584:5: ( ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident ) | ident )
			int alt52=2;
			try { DebugEnterDecision(52, false);
			int LA52_1 = input.LA(1);

			if ((LA52_1==IDENT))
			{
				int LA52_2 = input.LA(2);

				if ((EvaluatePredicate(synpred15_AS3_fragment)))
				{
					alt52 = 1;
				}
				else if ((true))
				{
					alt52 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 52, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA52_1==INTERNAL||LA52_1==PRIVATE||(LA52_1>=PROTECTED && LA52_1<=PUBLIC)) && (EvaluatePredicate(synpred15_AS3_fragment)))
			{
				alt52 = 1;
			}
			else if ((LA52_1==AS||LA52_1==DYNAMIC||LA52_1==GET||LA52_1==IS||LA52_1==NAMESPACE||LA52_1==SET||LA52_1==SUPER||LA52_1==USE||LA52_1==XML))
			{
				alt52 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 52, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(52); }
			switch (alt52)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:584:10: ( namespaceName DBL_COLON )=> namespaceName DBL_COLON ident
				{
				DebugLocation(584, 39);
				PushFollow(Follow._namespaceName_in_qualifiedIdent3196);
				namespaceName240=namespaceName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_namespaceName.Add(namespaceName240.Tree);
				DebugLocation(584, 53);
				DBL_COLON241=(IToken)Match(input,DBL_COLON,Follow._DBL_COLON_in_qualifiedIdent3198); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DBL_COLON.Add(DBL_COLON241);

				DebugLocation(584, 63);
				PushFollow(Follow._ident_in_qualifiedIdent3200);
				ident242=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident242.Tree);


				{
				// AST REWRITE
				// elements: namespaceName, DBL_COLON, ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 585:9: -> ^( QUALIFIED_NAME namespaceName DBL_COLON ident )
				{
					DebugLocation(585, 12);
					// AS3.g:585:12: ^( QUALIFIED_NAME namespaceName DBL_COLON ident )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(585, 14);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(QUALIFIED_NAME, "QUALIFIED_NAME"), root_1);

					DebugLocation(585, 29);
					adaptor.AddChild(root_1, stream_namespaceName.NextTree());
					DebugLocation(585, 43);
					adaptor.AddChild(root_1, stream_DBL_COLON.NextNode());
					DebugLocation(585, 53);
					adaptor.AddChild(root_1, stream_ident.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:586:11: ident
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(586, 11);
				PushFollow(Follow._ident_in_qualifiedIdent3232);
				ident243=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident243.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qualifiedIdent", 74);
			LeaveRule("qualifiedIdent", 74);
			LeaveRule_qualifiedIdent();
		}
		DebugLocation(587, 4);
		} finally { DebugExitRule(GrammarFileName, "qualifiedIdent"); }
		return retval;

	}
	// $ANTLR end "qualifiedIdent"

	partial void EnterRule_namespaceName();
	partial void LeaveRule_namespaceName();
	// $ANTLR start "namespaceName"
	// AS3.g:589:1: namespaceName : ( IDENT | reservedNamespace );
	[GrammarRule("namespaceName")]
	private AstParserRuleReturnScope<CommonTree, IToken> namespaceName()
	{
		EnterRule_namespaceName();
		EnterRule("namespaceName", 75);
		TraceIn("namespaceName", 75);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT244 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> reservedNamespace245 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree IDENT244_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "namespaceName");
		DebugLocation(589, 1);
		try
		{
			// AS3.g:590:2: ( IDENT | reservedNamespace )
			int alt53=2;
			try { DebugEnterDecision(53, false);
			int LA53_1 = input.LA(1);

			if ((LA53_1==IDENT))
			{
				alt53 = 1;
			}
			else if ((LA53_1==INTERNAL||LA53_1==PRIVATE||(LA53_1>=PROTECTED && LA53_1<=PUBLIC)))
			{
				alt53 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:590:4: IDENT
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(590, 4);
				IDENT244=(IToken)Match(input,IDENT,Follow._IDENT_in_namespaceName3246); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IDENT244_tree = (CommonTree)adaptor.Create(IDENT244);
				adaptor.AddChild(root_0, IDENT244_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:590:12: reservedNamespace
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(590, 12);
				PushFollow(Follow._reservedNamespace_in_namespaceName3250);
				reservedNamespace245=reservedNamespace();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, reservedNamespace245.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespaceName", 75);
			LeaveRule("namespaceName", 75);
			LeaveRule_namespaceName();
		}
		DebugLocation(591, 1);
		} finally { DebugExitRule(GrammarFileName, "namespaceName"); }
		return retval;

	}
	// $ANTLR end "namespaceName"

	partial void EnterRule_reservedNamespace();
	partial void LeaveRule_reservedNamespace();
	// $ANTLR start "reservedNamespace"
	// AS3.g:593:1: reservedNamespace : ( PUBLIC | PRIVATE | PROTECTED | INTERNAL );
	[GrammarRule("reservedNamespace")]
	private AstParserRuleReturnScope<CommonTree, IToken> reservedNamespace()
	{
		EnterRule_reservedNamespace();
		EnterRule("reservedNamespace", 76);
		TraceIn("reservedNamespace", 76);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set246 = default(IToken);

		CommonTree set246_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "reservedNamespace");
		DebugLocation(593, 1);
		try
		{
			// AS3.g:594:2: ( PUBLIC | PRIVATE | PROTECTED | INTERNAL )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(594, 2);

			set246=(IToken)input.LT(1);
			if (input.LA(1)==INTERNAL||input.LA(1)==PRIVATE||(input.LA(1)>=PROTECTED && input.LA(1)<=PUBLIC))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set246));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("reservedNamespace", 76);
			LeaveRule("reservedNamespace", 76);
			LeaveRule_reservedNamespace();
		}
		DebugLocation(598, 1);
		} finally { DebugExitRule(GrammarFileName, "reservedNamespace"); }
		return retval;

	}
	// $ANTLR end "reservedNamespace"

	partial void EnterRule_identifierStar();
	partial void LeaveRule_identifierStar();
	// $ANTLR start "identifierStar"
	// AS3.g:600:1: identifierStar : ident ( dotIdent )* ( DOT STAR )? -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? ) ;
	[GrammarRule("identifierStar")]
	private AstParserRuleReturnScope<CommonTree, IToken> identifierStar()
	{
		EnterRule_identifierStar();
		EnterRule("identifierStar", 77);
		TraceIn("identifierStar", 77);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DOT249 = default(IToken);
		IToken STAR250 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident247 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> dotIdent248 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT249_tree = default(CommonTree);
		CommonTree STAR250_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_STAR=new RewriteRuleITokenStream(adaptor,"token STAR");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_dotIdent=new RewriteRuleSubtreeStream(adaptor,"rule dotIdent");
		try { DebugEnterRule(GrammarFileName, "identifierStar");
		DebugLocation(600, 1);
		try
		{
			// AS3.g:601:2: ( ident ( dotIdent )* ( DOT STAR )? -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? ) )
			DebugEnterAlt(1);
			// AS3.g:601:4: ident ( dotIdent )* ( DOT STAR )?
			{
			DebugLocation(601, 4);
			PushFollow(Follow._ident_in_identifierStar3287);
			ident247=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident247.Tree);
			DebugLocation(602, 3);
			// AS3.g:602:3: ( dotIdent )*
			try { DebugEnterSubRule(54);
			while (true)
			{
				int alt54=2;
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==DOT))
				{
					int LA54_2 = input.LA(2);

					if ((LA54_2==AS||LA54_2==DYNAMIC||LA54_2==GET||LA54_2==IDENT||LA54_2==IS||LA54_2==NAMESPACE||LA54_2==SET||LA54_2==SUPER||LA54_2==USE||LA54_2==XML))
					{
						alt54 = 1;
					}


				}


				} finally { DebugExitDecision(54); }
				switch ( alt54 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:602:3: dotIdent
					{
					DebugLocation(602, 3);
					PushFollow(Follow._dotIdent_in_identifierStar3291);
					dotIdent248=dotIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_dotIdent.Add(dotIdent248.Tree);

					}
					break;

				default:
					goto loop54;
				}
			}

			loop54:
				;

			} finally { DebugExitSubRule(54); }

			DebugLocation(603, 3);
			// AS3.g:603:3: ( DOT STAR )?
			int alt55=2;
			try { DebugEnterSubRule(55);
			try { DebugEnterDecision(55, false);
			int LA55_1 = input.LA(1);

			if ((LA55_1==DOT))
			{
				alt55 = 1;
			}
			} finally { DebugExitDecision(55); }
			switch (alt55)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:603:4: DOT STAR
				{
				DebugLocation(603, 4);
				DOT249=(IToken)Match(input,DOT,Follow._DOT_in_identifierStar3297); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOT.Add(DOT249);

				DebugLocation(603, 8);
				STAR250=(IToken)Match(input,STAR,Follow._STAR_in_identifierStar3299); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_STAR.Add(STAR250);


				}
				break;

			}
			} finally { DebugExitSubRule(55); }



			{
			// AST REWRITE
			// elements: ident, dotIdent, DOT, STAR
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 604:3: -> ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? )
			{
				DebugLocation(604, 6);
				// AS3.g:604:6: ^( IDENTIFIER_STAR ident ( dotIdent )* ( DOT )? ( STAR )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(604, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(IDENTIFIER_STAR, "IDENTIFIER_STAR"), root_1);

				DebugLocation(604, 24);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(604, 30);
				// AS3.g:604:30: ( dotIdent )*
				while ( stream_dotIdent.HasNext )
				{
					DebugLocation(604, 30);
					adaptor.AddChild(root_1, stream_dotIdent.NextTree());

				}
				stream_dotIdent.Reset();
				DebugLocation(604, 40);
				// AS3.g:604:40: ( DOT )?
				if (stream_DOT.HasNext)
				{
					DebugLocation(604, 40);
					adaptor.AddChild(root_1, stream_DOT.NextNode());

				}
				stream_DOT.Reset();
				DebugLocation(604, 45);
				// AS3.g:604:45: ( STAR )?
				if (stream_STAR.HasNext)
				{
					DebugLocation(604, 45);
					adaptor.AddChild(root_1, stream_STAR.NextNode());

				}
				stream_STAR.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifierStar", 77);
			LeaveRule("identifierStar", 77);
			LeaveRule_identifierStar();
		}
		DebugLocation(605, 1);
		} finally { DebugExitRule(GrammarFileName, "identifierStar"); }
		return retval;

	}
	// $ANTLR end "identifierStar"

	partial void EnterRule_dotIdent();
	partial void LeaveRule_dotIdent();
	// $ANTLR start "dotIdent"
	// AS3.g:607:1: dotIdent : DOT ident ;
	[GrammarRule("dotIdent")]
	private AstParserRuleReturnScope<CommonTree, IToken> dotIdent()
	{
		EnterRule_dotIdent();
		EnterRule("dotIdent", 78);
		TraceIn("dotIdent", 78);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DOT251 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident252 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT251_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "dotIdent");
		DebugLocation(607, 4);
		try
		{
			// AS3.g:608:5: ( DOT ident )
			DebugEnterAlt(1);
			// AS3.g:608:7: DOT ident
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(608, 7);
			DOT251=(IToken)Match(input,DOT,Follow._DOT_in_dotIdent3334); if (state.failed) return retval;
			if (state.backtracking == 0) {
			DOT251_tree = (CommonTree)adaptor.Create(DOT251);
			adaptor.AddChild(root_0, DOT251_tree);
			}
			DebugLocation(608, 11);
			PushFollow(Follow._ident_in_dotIdent3336);
			ident252=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, ident252.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("dotIdent", 78);
			LeaveRule("dotIdent", 78);
			LeaveRule_dotIdent();
		}
		DebugLocation(609, 4);
		} finally { DebugExitRule(GrammarFileName, "dotIdent"); }
		return retval;

	}
	// $ANTLR end "dotIdent"

	partial void EnterRule_ident();
	partial void LeaveRule_ident();
	// $ANTLR start "ident"
	// AS3.g:611:1: ident : ( IDENT -> ^( NAME IDENT ) | USE | XML | DYNAMIC | NAMESPACE | IS | AS | GET | SET | SUPER );
	[GrammarRule("ident")]
	private AstParserRuleReturnScope<CommonTree, IToken> ident()
	{
		EnterRule_ident();
		EnterRule("ident", 79);
		TraceIn("ident", 79);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken IDENT253 = default(IToken);
		IToken USE254 = default(IToken);
		IToken XML255 = default(IToken);
		IToken DYNAMIC256 = default(IToken);
		IToken NAMESPACE257 = default(IToken);
		IToken IS258 = default(IToken);
		IToken AS259 = default(IToken);
		IToken GET260 = default(IToken);
		IToken SET261 = default(IToken);
		IToken SUPER262 = default(IToken);

		CommonTree IDENT253_tree = default(CommonTree);
		CommonTree USE254_tree = default(CommonTree);
		CommonTree XML255_tree = default(CommonTree);
		CommonTree DYNAMIC256_tree = default(CommonTree);
		CommonTree NAMESPACE257_tree = default(CommonTree);
		CommonTree IS258_tree = default(CommonTree);
		CommonTree AS259_tree = default(CommonTree);
		CommonTree GET260_tree = default(CommonTree);
		CommonTree SET261_tree = default(CommonTree);
		CommonTree SUPER262_tree = default(CommonTree);
		RewriteRuleITokenStream stream_IDENT=new RewriteRuleITokenStream(adaptor,"token IDENT");
		try { DebugEnterRule(GrammarFileName, "ident");
		DebugLocation(611, 1);
		try
		{
			// AS3.g:615:2: ( IDENT -> ^( NAME IDENT ) | USE | XML | DYNAMIC | NAMESPACE | IS | AS | GET | SET | SUPER )
			int alt56=10;
			try { DebugEnterDecision(56, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt56 = 1;
				}
				break;
			case USE:
				{
				alt56 = 2;
				}
				break;
			case XML:
				{
				alt56 = 3;
				}
				break;
			case DYNAMIC:
				{
				alt56 = 4;
				}
				break;
			case NAMESPACE:
				{
				alt56 = 5;
				}
				break;
			case IS:
				{
				alt56 = 6;
				}
				break;
			case AS:
				{
				alt56 = 7;
				}
				break;
			case GET:
				{
				alt56 = 8;
				}
				break;
			case SET:
				{
				alt56 = 9;
				}
				break;
			case SUPER:
				{
				alt56 = 10;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 56, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(56); }
			switch (alt56)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:615:4: IDENT
				{
				DebugLocation(615, 4);
				IDENT253=(IToken)Match(input,IDENT,Follow._IDENT_in_ident3356); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_IDENT.Add(IDENT253);



				{
				// AST REWRITE
				// elements: IDENT
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 615:10: -> ^( NAME IDENT )
				{
					DebugLocation(615, 13);
					// AS3.g:615:13: ^( NAME IDENT )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(615, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NAME, "NAME"), root_1);

					DebugLocation(615, 20);
					adaptor.AddChild(root_1, stream_IDENT.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:616:4: USE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(616, 4);
				USE254=(IToken)Match(input,USE,Follow._USE_in_ident3369); if (state.failed) return retval;
				if (state.backtracking == 0) {
				USE254_tree = (CommonTree)adaptor.Create(USE254);
				adaptor.AddChild(root_0, USE254_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:617:4: XML
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(617, 4);
				XML255=(IToken)Match(input,XML,Follow._XML_in_ident3374); if (state.failed) return retval;
				if (state.backtracking == 0) {
				XML255_tree = (CommonTree)adaptor.Create(XML255);
				adaptor.AddChild(root_0, XML255_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:618:4: DYNAMIC
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(618, 4);
				DYNAMIC256=(IToken)Match(input,DYNAMIC,Follow._DYNAMIC_in_ident3379); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DYNAMIC256_tree = (CommonTree)adaptor.Create(DYNAMIC256);
				adaptor.AddChild(root_0, DYNAMIC256_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:619:4: NAMESPACE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(619, 4);
				NAMESPACE257=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_ident3384); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NAMESPACE257_tree = (CommonTree)adaptor.Create(NAMESPACE257);
				adaptor.AddChild(root_0, NAMESPACE257_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:620:4: IS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(620, 4);
				IS258=(IToken)Match(input,IS,Follow._IS_in_ident3389); if (state.failed) return retval;
				if (state.backtracking == 0) {
				IS258_tree = (CommonTree)adaptor.Create(IS258);
				adaptor.AddChild(root_0, IS258_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:621:4: AS
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(621, 4);
				AS259=(IToken)Match(input,AS,Follow._AS_in_ident3394); if (state.failed) return retval;
				if (state.backtracking == 0) {
				AS259_tree = (CommonTree)adaptor.Create(AS259);
				adaptor.AddChild(root_0, AS259_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// AS3.g:622:4: GET
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(622, 4);
				GET260=(IToken)Match(input,GET,Follow._GET_in_ident3399); if (state.failed) return retval;
				if (state.backtracking == 0) {
				GET260_tree = (CommonTree)adaptor.Create(GET260);
				adaptor.AddChild(root_0, GET260_tree);
				}

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// AS3.g:623:4: SET
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(623, 4);
				SET261=(IToken)Match(input,SET,Follow._SET_in_ident3404); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SET261_tree = (CommonTree)adaptor.Create(SET261);
				adaptor.AddChild(root_0, SET261_tree);
				}

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// AS3.g:624:4: SUPER
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(624, 4);
				SUPER262=(IToken)Match(input,SUPER,Follow._SUPER_in_ident3409); if (state.failed) return retval;
				if (state.backtracking == 0) {
				SUPER262_tree = (CommonTree)adaptor.Create(SUPER262);
				adaptor.AddChild(root_0, SUPER262_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
			if (state.backtracking == 0)
			{

					Console.WriteLine("ident {0}", input.ToString(retval.Start,input.LT(-1)));

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ident", 79);
			LeaveRule("ident", 79);
			LeaveRule_ident();
		}
		DebugLocation(625, 1);
		} finally { DebugExitRule(GrammarFileName, "ident"); }
		return retval;

	}
	// $ANTLR end "ident"

	partial void EnterRule_annotation();
	partial void LeaveRule_annotation();
	// $ANTLR start "annotation"
	// AS3.g:627:1: annotation : LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) ;
	[GrammarRule("annotation")]
	private AstParserRuleReturnScope<CommonTree, IToken> annotation()
	{
		EnterRule_annotation();
		EnterRule("annotation", 80);
		TraceIn("annotation", 80);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LBRACK263 = default(IToken);
		IToken RBRACK266 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident264 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> annotationParamList265 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LBRACK263_tree = default(CommonTree);
		CommonTree RBRACK266_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_annotationParamList=new RewriteRuleSubtreeStream(adaptor,"rule annotationParamList");
		try { DebugEnterRule(GrammarFileName, "annotation");
		DebugLocation(627, 1);
		try
		{
			// AS3.g:628:2: ( LBRACK ident ( annotationParamList )? RBRACK -> ^( ANNOTATION ident ( annotationParamList )? ) )
			DebugEnterAlt(1);
			// AS3.g:628:4: LBRACK ident ( annotationParamList )? RBRACK
			{
			DebugLocation(628, 4);
			LBRACK263=(IToken)Match(input,LBRACK,Follow._LBRACK_in_annotation3420); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK263);

			DebugLocation(629, 3);
			PushFollow(Follow._ident_in_annotation3424);
			ident264=ident();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_ident.Add(ident264.Tree);
			DebugLocation(630, 3);
			// AS3.g:630:3: ( annotationParamList )?
			int alt57=2;
			try { DebugEnterSubRule(57);
			try { DebugEnterDecision(57, false);
			int LA57_1 = input.LA(1);

			if ((LA57_1==LPAREN))
			{
				alt57 = 1;
			}
			} finally { DebugExitDecision(57); }
			switch (alt57)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:630:3: annotationParamList
				{
				DebugLocation(630, 3);
				PushFollow(Follow._annotationParamList_in_annotation3428);
				annotationParamList265=annotationParamList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationParamList.Add(annotationParamList265.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(57); }

			DebugLocation(631, 3);
			RBRACK266=(IToken)Match(input,RBRACK,Follow._RBRACK_in_annotation3433); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK266);



			{
			// AST REWRITE
			// elements: ident, annotationParamList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 632:3: -> ^( ANNOTATION ident ( annotationParamList )? )
			{
				DebugLocation(632, 6);
				// AS3.g:632:6: ^( ANNOTATION ident ( annotationParamList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(632, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ANNOTATION, "ANNOTATION"), root_1);

				DebugLocation(632, 19);
				adaptor.AddChild(root_1, stream_ident.NextTree());
				DebugLocation(632, 25);
				// AS3.g:632:25: ( annotationParamList )?
				if (stream_annotationParamList.HasNext)
				{
					DebugLocation(632, 25);
					adaptor.AddChild(root_1, stream_annotationParamList.NextTree());

				}
				stream_annotationParamList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotation", 80);
			LeaveRule("annotation", 80);
			LeaveRule_annotation();
		}
		DebugLocation(633, 1);
		} finally { DebugExitRule(GrammarFileName, "annotation"); }
		return retval;

	}
	// $ANTLR end "annotation"

	partial void EnterRule_annotationParamList();
	partial void LeaveRule_annotationParamList();
	// $ANTLR start "annotationParamList"
	// AS3.g:635:1: annotationParamList : LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) ;
	[GrammarRule("annotationParamList")]
	private AstParserRuleReturnScope<CommonTree, IToken> annotationParamList()
	{
		EnterRule_annotationParamList();
		EnterRule("annotationParamList", 81);
		TraceIn("annotationParamList", 81);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN267 = default(IToken);
		IToken COMMA269 = default(IToken);
		IToken RPAREN271 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> annotationParam268 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> annotationParam270 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN267_tree = default(CommonTree);
		CommonTree COMMA269_tree = default(CommonTree);
		CommonTree RPAREN271_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_annotationParam=new RewriteRuleSubtreeStream(adaptor,"rule annotationParam");
		try { DebugEnterRule(GrammarFileName, "annotationParamList");
		DebugLocation(635, 1);
		try
		{
			// AS3.g:636:2: ( LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN -> ^( ANNOTATION_PARAMS ( annotationParam )* ) )
			DebugEnterAlt(1);
			// AS3.g:637:3: LPAREN ( annotationParam ( COMMA annotationParam )* )? RPAREN
			{
			DebugLocation(637, 3);
			LPAREN267=(IToken)Match(input,LPAREN,Follow._LPAREN_in_annotationParamList3459); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN267);

			DebugLocation(638, 3);
			// AS3.g:638:3: ( annotationParam ( COMMA annotationParam )* )?
			int alt59=2;
			try { DebugEnterSubRule(59);
			try { DebugEnterDecision(59, false);
			int LA59_1 = input.LA(1);

			if ((LA59_1==AS||LA59_1==DECIMAL_LITERAL||LA59_1==DYNAMIC||(LA59_1>=FALSE && LA59_1<=FLOAT_LITERAL)||LA59_1==GET||(LA59_1>=HEX_LITERAL && LA59_1<=IDENT)||LA59_1==IS||LA59_1==NAMESPACE||LA59_1==NULL||LA59_1==OCTAL_LITERAL||LA59_1==REGEX_LITERAL||LA59_1==SET||(LA59_1>=STRING_LITERAL_DOUBLE && LA59_1<=SUPER)||LA59_1==TRUE||LA59_1==USE||LA59_1==XML||LA59_1==XML_LITERAL))
			{
				alt59 = 1;
			}
			} finally { DebugExitDecision(59); }
			switch (alt59)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:638:5: annotationParam ( COMMA annotationParam )*
				{
				DebugLocation(638, 5);
				PushFollow(Follow._annotationParam_in_annotationParamList3465);
				annotationParam268=annotationParam();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_annotationParam.Add(annotationParam268.Tree);
				DebugLocation(639, 4);
				// AS3.g:639:4: ( COMMA annotationParam )*
				try { DebugEnterSubRule(58);
				while (true)
				{
					int alt58=2;
					try { DebugEnterDecision(58, false);
					int LA58_1 = input.LA(1);

					if ((LA58_1==COMMA))
					{
						alt58 = 1;
					}


					} finally { DebugExitDecision(58); }
					switch ( alt58 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:639:5: COMMA annotationParam
						{
						DebugLocation(639, 5);
						COMMA269=(IToken)Match(input,COMMA,Follow._COMMA_in_annotationParamList3471); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_COMMA.Add(COMMA269);

						DebugLocation(639, 11);
						PushFollow(Follow._annotationParam_in_annotationParamList3473);
						annotationParam270=annotationParam();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_annotationParam.Add(annotationParam270.Tree);

						}
						break;

					default:
						goto loop58;
					}
				}

				loop58:
					;

				} finally { DebugExitSubRule(58); }


				}
				break;

			}
			} finally { DebugExitSubRule(59); }

			DebugLocation(641, 3);
			RPAREN271=(IToken)Match(input,RPAREN,Follow._RPAREN_in_annotationParamList3484); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN271);



			{
			// AST REWRITE
			// elements: annotationParam
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 642:3: -> ^( ANNOTATION_PARAMS ( annotationParam )* )
			{
				DebugLocation(642, 6);
				// AS3.g:642:6: ^( ANNOTATION_PARAMS ( annotationParam )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(642, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ANNOTATION_PARAMS, "ANNOTATION_PARAMS"), root_1);

				DebugLocation(642, 26);
				// AS3.g:642:26: ( annotationParam )*
				while ( stream_annotationParam.HasNext )
				{
					DebugLocation(642, 26);
					adaptor.AddChild(root_1, stream_annotationParam.NextTree());

				}
				stream_annotationParam.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotationParamList", 81);
			LeaveRule("annotationParamList", 81);
			LeaveRule_annotationParamList();
		}
		DebugLocation(643, 1);
		} finally { DebugExitRule(GrammarFileName, "annotationParamList"); }
		return retval;

	}
	// $ANTLR end "annotationParamList"

	partial void EnterRule_annotationParam();
	partial void LeaveRule_annotationParam();
	// $ANTLR start "annotationParam"
	// AS3.g:656:1: annotationParam : ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident );
	[GrammarRule("annotationParam")]
	private AstParserRuleReturnScope<CommonTree, IToken> annotationParam()
	{
		EnterRule_annotationParam();
		EnterRule("annotationParam", 82);
		TraceIn("annotationParam", 82);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken ASSIGN273 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ident272 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant274 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> constant275 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ident276 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree ASSIGN273_tree = default(CommonTree);
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_ident=new RewriteRuleSubtreeStream(adaptor,"rule ident");
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		try { DebugEnterRule(GrammarFileName, "annotationParam");
		DebugLocation(656, 1);
		try
		{
			// AS3.g:657:2: ( ident ASSIGN constant -> ^( ASSIGN ident constant ) | constant -> constant | ident -> ident )
			int alt60=3;
			try { DebugEnterDecision(60, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case USE:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case XML:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DYNAMIC:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NAMESPACE:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IS:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case AS:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case GET:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SET:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case SUPER:
				{
				int LA60_2 = input.LA(2);

				if ((LA60_2==ASSIGN))
				{
					alt60 = 1;
				}
				else if ((LA60_2==COMMA||LA60_2==RPAREN))
				{
					alt60 = 3;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case DECIMAL_LITERAL:
			case FALSE:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case NULL:
			case OCTAL_LITERAL:
			case REGEX_LITERAL:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case TRUE:
			case XML_LITERAL:
				{
				alt60 = 2;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 60, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:658:3: ident ASSIGN constant
				{
				DebugLocation(658, 3);
				PushFollow(Follow._ident_in_annotationParam3511);
				ident272=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident272.Tree);
				DebugLocation(658, 9);
				ASSIGN273=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_annotationParam3513); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN273);

				DebugLocation(658, 16);
				PushFollow(Follow._constant_in_annotationParam3515);
				constant274=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant274.Tree);


				{
				// AST REWRITE
				// elements: ASSIGN, ident, constant
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 658:25: -> ^( ASSIGN ident constant )
				{
					DebugLocation(658, 28);
					// AS3.g:658:28: ^( ASSIGN ident constant )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(658, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_ASSIGN.NextNode(), root_1);

					DebugLocation(658, 37);
					adaptor.AddChild(root_1, stream_ident.NextTree());
					DebugLocation(658, 43);
					adaptor.AddChild(root_1, stream_constant.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:659:4: constant
				{
				DebugLocation(659, 4);
				PushFollow(Follow._constant_in_annotationParam3530);
				constant275=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant275.Tree);


				{
				// AST REWRITE
				// elements: constant
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 659:13: -> constant
				{
					DebugLocation(659, 16);
					adaptor.AddChild(root_0, stream_constant.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:660:4: ident
				{
				DebugLocation(660, 4);
				PushFollow(Follow._ident_in_annotationParam3539);
				ident276=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_ident.Add(ident276.Tree);


				{
				// AST REWRITE
				// elements: ident
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 660:10: -> ident
				{
					DebugLocation(660, 13);
					adaptor.AddChild(root_0, stream_ident.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("annotationParam", 82);
			LeaveRule("annotationParam", 82);
			LeaveRule_annotationParam();
		}
		DebugLocation(661, 1);
		} finally { DebugExitRule(GrammarFileName, "annotationParam"); }
		return retval;

	}
	// $ANTLR end "annotationParam"

	partial void EnterRule_modifiers();
	partial void LeaveRule_modifiers();
	// $ANTLR start "modifiers"
	// AS3.g:664:1: modifiers : ( modifier ( modifier )* )? -> ^( MODIFIER_LIST ( modifier )* ) ;
	[GrammarRule("modifiers")]
	private AstParserRuleReturnScope<CommonTree, IToken> modifiers()
	{
		EnterRule_modifiers();
		EnterRule("modifiers", 83);
		TraceIn("modifiers", 83);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> modifier277 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> modifier278 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_modifier=new RewriteRuleSubtreeStream(adaptor,"rule modifier");
		try { DebugEnterRule(GrammarFileName, "modifiers");
		DebugLocation(664, 1);
		try
		{
			// AS3.g:665:2: ( ( modifier ( modifier )* )? -> ^( MODIFIER_LIST ( modifier )* ) )
			DebugEnterAlt(1);
			// AS3.g:665:4: ( modifier ( modifier )* )?
			{
			DebugLocation(665, 4);
			// AS3.g:665:4: ( modifier ( modifier )* )?
			int alt62=2;
			try { DebugEnterSubRule(62);
			try { DebugEnterDecision(62, false);
			int LA62_1 = input.LA(1);

			if ((LA62_1==DYNAMIC||LA62_1==IDENT||LA62_1==INTERNAL||LA62_1==PRIVATE||(LA62_1>=PROTECTED && LA62_1<=PUBLIC)||LA62_1==STATIC||(LA62_1>=244 && LA62_1<=246)||LA62_1==250||LA62_1==252))
			{
				alt62 = 1;
			}
			} finally { DebugExitDecision(62); }
			switch (alt62)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:665:6: modifier ( modifier )*
				{
				DebugLocation(665, 6);
				PushFollow(Follow._modifier_in_modifiers3557);
				modifier277=modifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_modifier.Add(modifier277.Tree);
				DebugLocation(665, 15);
				// AS3.g:665:15: ( modifier )*
				try { DebugEnterSubRule(61);
				while (true)
				{
					int alt61=2;
					try { DebugEnterDecision(61, false);
					int LA61_1 = input.LA(1);

					if ((LA61_1==DYNAMIC||LA61_1==IDENT||LA61_1==INTERNAL||LA61_1==PRIVATE||(LA61_1>=PROTECTED && LA61_1<=PUBLIC)||LA61_1==STATIC||(LA61_1>=244 && LA61_1<=246)||LA61_1==250||LA61_1==252))
					{
						alt61 = 1;
					}


					} finally { DebugExitDecision(61); }
					switch ( alt61 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:665:16: modifier
						{
						DebugLocation(665, 16);
						PushFollow(Follow._modifier_in_modifiers3560);
						modifier278=modifier();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_modifier.Add(modifier278.Tree);

						}
						break;

					default:
						goto loop61;
					}
				}

				loop61:
					;

				} finally { DebugExitSubRule(61); }


				}
				break;

			}
			} finally { DebugExitSubRule(62); }



			{
			// AST REWRITE
			// elements: modifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 666:2: -> ^( MODIFIER_LIST ( modifier )* )
			{
				DebugLocation(666, 5);
				// AS3.g:666:5: ^( MODIFIER_LIST ( modifier )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(666, 7);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(MODIFIER_LIST, "MODIFIER_LIST"), root_1);

				DebugLocation(666, 21);
				// AS3.g:666:21: ( modifier )*
				while ( stream_modifier.HasNext )
				{
					DebugLocation(666, 21);
					adaptor.AddChild(root_1, stream_modifier.NextTree());

				}
				stream_modifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modifiers", 83);
			LeaveRule("modifiers", 83);
			LeaveRule_modifiers();
		}
		DebugLocation(667, 1);
		} finally { DebugExitRule(GrammarFileName, "modifiers"); }
		return retval;

	}
	// $ANTLR end "modifiers"

	partial void EnterRule_modifier();
	partial void LeaveRule_modifier();
	// $ANTLR start "modifier"
	// AS3.g:669:1: modifier : ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' );
	[GrammarRule("modifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> modifier()
	{
		EnterRule_modifier();
		EnterRule("modifier", 84);
		TraceIn("modifier", 84);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken STATIC280 = default(IToken);
		IToken string_literal281 = default(IToken);
		IToken string_literal282 = default(IToken);
		IToken string_literal283 = default(IToken);
		IToken string_literal284 = default(IToken);
		IToken DYNAMIC285 = default(IToken);
		IToken string_literal286 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> namespaceName279 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree STATIC280_tree = default(CommonTree);
		CommonTree string_literal281_tree = default(CommonTree);
		CommonTree string_literal282_tree = default(CommonTree);
		CommonTree string_literal283_tree = default(CommonTree);
		CommonTree string_literal284_tree = default(CommonTree);
		CommonTree DYNAMIC285_tree = default(CommonTree);
		CommonTree string_literal286_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "modifier");
		DebugLocation(669, 1);
		try
		{
			// AS3.g:670:2: ( namespaceName | STATIC | 'final' | 'enumerable' | 'explicit' | 'override' | DYNAMIC | 'intrinsic' )
			int alt63=8;
			try { DebugEnterDecision(63, false);
			switch (input.LA(1))
			{
			case IDENT:
			case INTERNAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
				{
				alt63 = 1;
				}
				break;
			case STATIC:
				{
				alt63 = 2;
				}
				break;
			case 246:
				{
				alt63 = 3;
				}
				break;
			case 244:
				{
				alt63 = 4;
				}
				break;
			case 245:
				{
				alt63 = 5;
				}
				break;
			case 252:
				{
				alt63 = 6;
				}
				break;
			case DYNAMIC:
				{
				alt63 = 7;
				}
				break;
			case 250:
				{
				alt63 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 63, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:670:4: namespaceName
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(670, 4);
				PushFollow(Follow._namespaceName_in_modifier3586);
				namespaceName279=namespaceName();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, namespaceName279.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:671:4: STATIC
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(671, 4);
				STATIC280=(IToken)Match(input,STATIC,Follow._STATIC_in_modifier3591); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STATIC280_tree = (CommonTree)adaptor.Create(STATIC280);
				adaptor.AddChild(root_0, STATIC280_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:672:4: 'final'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(672, 4);
				string_literal281=(IToken)Match(input,246,Follow._246_in_modifier3596); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal281_tree = (CommonTree)adaptor.Create(string_literal281);
				adaptor.AddChild(root_0, string_literal281_tree);
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:673:4: 'enumerable'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(673, 4);
				string_literal282=(IToken)Match(input,244,Follow._244_in_modifier3601); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal282_tree = (CommonTree)adaptor.Create(string_literal282);
				adaptor.AddChild(root_0, string_literal282_tree);
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:674:4: 'explicit'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(674, 4);
				string_literal283=(IToken)Match(input,245,Follow._245_in_modifier3606); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal283_tree = (CommonTree)adaptor.Create(string_literal283);
				adaptor.AddChild(root_0, string_literal283_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:675:4: 'override'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(675, 4);
				string_literal284=(IToken)Match(input,252,Follow._252_in_modifier3611); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal284_tree = (CommonTree)adaptor.Create(string_literal284);
				adaptor.AddChild(root_0, string_literal284_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:676:4: DYNAMIC
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(676, 4);
				DYNAMIC285=(IToken)Match(input,DYNAMIC,Follow._DYNAMIC_in_modifier3616); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DYNAMIC285_tree = (CommonTree)adaptor.Create(DYNAMIC285);
				adaptor.AddChild(root_0, DYNAMIC285_tree);
				}

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// AS3.g:677:4: 'intrinsic'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(677, 4);
				string_literal286=(IToken)Match(input,250,Follow._250_in_modifier3621); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal286_tree = (CommonTree)adaptor.Create(string_literal286);
				adaptor.AddChild(root_0, string_literal286_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("modifier", 84);
			LeaveRule("modifier", 84);
			LeaveRule_modifier();
		}
		DebugLocation(678, 1);
		} finally { DebugExitRule(GrammarFileName, "modifier"); }
		return retval;

	}
	// $ANTLR end "modifier"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// AS3.g:680:1: arguments : ( LPAREN expressionList RPAREN -> ^( ARGUMENTS LPAREN expressionList RPAREN ) | LPAREN RPAREN -> ^( ARGUMENTS LPAREN RPAREN ) );
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<CommonTree, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 85);
		TraceIn("arguments", 85);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN287 = default(IToken);
		IToken RPAREN289 = default(IToken);
		IToken LPAREN290 = default(IToken);
		IToken RPAREN291 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expressionList288 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN287_tree = default(CommonTree);
		CommonTree RPAREN289_tree = default(CommonTree);
		CommonTree LPAREN290_tree = default(CommonTree);
		CommonTree RPAREN291_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_expressionList=new RewriteRuleSubtreeStream(adaptor,"rule expressionList");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(680, 1);
		try
		{
			// AS3.g:681:2: ( LPAREN expressionList RPAREN -> ^( ARGUMENTS LPAREN expressionList RPAREN ) | LPAREN RPAREN -> ^( ARGUMENTS LPAREN RPAREN ) )
			int alt64=2;
			try { DebugEnterDecision(64, false);
			int LA64_1 = input.LA(1);

			if ((LA64_1==LPAREN))
			{
				int LA64_2 = input.LA(2);

				if ((LA64_2==RPAREN))
				{
					alt64 = 2;
				}
				else if ((LA64_2==AS||LA64_2==BNOT||(LA64_2>=DEC && LA64_2<=DECIMAL_LITERAL)||(LA64_2>=DYNAMIC && LA64_2<=E4X_ATTRI)||(LA64_2>=FALSE && LA64_2<=FLOAT_LITERAL)||LA64_2==FUNCTION||LA64_2==GET||(LA64_2>=HEX_LITERAL && LA64_2<=IDENT)||LA64_2==INC||(LA64_2>=INTERNAL && LA64_2<=IS)||(LA64_2>=LBRACK && LA64_2<=LCURLY)||LA64_2==LNOT||LA64_2==LPAREN||LA64_2==MINUS||LA64_2==NAMESPACE||LA64_2==NEW||LA64_2==NULL||LA64_2==OCTAL_LITERAL||LA64_2==PLUS||LA64_2==PRIVATE||(LA64_2>=PROTECTED && LA64_2<=PUBLIC)||LA64_2==REGEX_LITERAL||LA64_2==SET||(LA64_2>=STRING_LITERAL_DOUBLE && LA64_2<=SUPER)||LA64_2==TRUE||LA64_2==USE||LA64_2==XML||LA64_2==XML_LITERAL||LA64_2==243||(LA64_2>=255 && LA64_2<=257)))
				{
					alt64 = 1;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 64, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 64, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:681:4: LPAREN expressionList RPAREN
				{
				DebugLocation(681, 4);
				LPAREN287=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments3632); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN287);

				DebugLocation(681, 11);
				PushFollow(Follow._expressionList_in_arguments3634);
				expressionList288=expressionList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expressionList.Add(expressionList288.Tree);
				DebugLocation(681, 26);
				RPAREN289=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments3636); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN289);



				{
				// AST REWRITE
				// elements: LPAREN, expressionList, RPAREN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 682:3: -> ^( ARGUMENTS LPAREN expressionList RPAREN )
				{
					DebugLocation(682, 6);
					// AS3.g:682:6: ^( ARGUMENTS LPAREN expressionList RPAREN )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(682, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

					DebugLocation(682, 18);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(682, 25);
					adaptor.AddChild(root_1, stream_expressionList.NextTree());
					DebugLocation(682, 40);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:684:4: LPAREN RPAREN
				{
				DebugLocation(684, 4);
				LPAREN290=(IToken)Match(input,LPAREN,Follow._LPAREN_in_arguments3656); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN290);

				DebugLocation(684, 11);
				RPAREN291=(IToken)Match(input,RPAREN,Follow._RPAREN_in_arguments3658); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN291);



				{
				// AST REWRITE
				// elements: LPAREN, RPAREN
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 685:3: -> ^( ARGUMENTS LPAREN RPAREN )
				{
					DebugLocation(685, 6);
					// AS3.g:685:6: ^( ARGUMENTS LPAREN RPAREN )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(685, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARGUMENTS, "ARGUMENTS"), root_1);

					DebugLocation(685, 18);
					adaptor.AddChild(root_1, stream_LPAREN.NextNode());
					DebugLocation(685, 25);
					adaptor.AddChild(root_1, stream_RPAREN.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 85);
			LeaveRule("arguments", 85);
			LeaveRule_arguments();
		}
		DebugLocation(686, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// AS3.g:688:1: arrayLiteral : LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 86);
		TraceIn("arrayLiteral", 86);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LBRACK292 = default(IToken);
		IToken RBRACK294 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> elementList293 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LBRACK292_tree = default(CommonTree);
		CommonTree RBRACK294_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleSubtreeStream stream_elementList=new RewriteRuleSubtreeStream(adaptor,"rule elementList");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(688, 1);
		try
		{
			// AS3.g:689:2: ( LBRACK ( elementList )? RBRACK -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK ) )
			DebugEnterAlt(1);
			// AS3.g:689:4: LBRACK ( elementList )? RBRACK
			{
			DebugLocation(689, 4);
			LBRACK292=(IToken)Match(input,LBRACK,Follow._LBRACK_in_arrayLiteral3681); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACK.Add(LBRACK292);

			DebugLocation(689, 11);
			// AS3.g:689:11: ( elementList )?
			int alt65=2;
			try { DebugEnterSubRule(65);
			try { DebugEnterDecision(65, false);
			int LA65_1 = input.LA(1);

			if ((LA65_1==AS||LA65_1==BNOT||LA65_1==COMMA||(LA65_1>=DEC && LA65_1<=DECIMAL_LITERAL)||(LA65_1>=DYNAMIC && LA65_1<=E4X_ATTRI)||(LA65_1>=FALSE && LA65_1<=FLOAT_LITERAL)||LA65_1==FUNCTION||LA65_1==GET||(LA65_1>=HEX_LITERAL && LA65_1<=IDENT)||LA65_1==INC||(LA65_1>=INTERNAL && LA65_1<=IS)||(LA65_1>=LBRACK && LA65_1<=LCURLY)||LA65_1==LNOT||LA65_1==LPAREN||LA65_1==MINUS||LA65_1==NAMESPACE||LA65_1==NEW||LA65_1==NULL||LA65_1==OCTAL_LITERAL||LA65_1==PLUS||LA65_1==PRIVATE||(LA65_1>=PROTECTED && LA65_1<=PUBLIC)||LA65_1==REGEX_LITERAL||LA65_1==SET||(LA65_1>=STRING_LITERAL_DOUBLE && LA65_1<=SUPER)||LA65_1==TRUE||LA65_1==USE||LA65_1==XML||LA65_1==XML_LITERAL||LA65_1==243||(LA65_1>=255 && LA65_1<=257)))
			{
				alt65 = 1;
			}
			} finally { DebugExitDecision(65); }
			switch (alt65)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:689:11: elementList
				{
				DebugLocation(689, 11);
				PushFollow(Follow._elementList_in_arrayLiteral3683);
				elementList293=elementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_elementList.Add(elementList293.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(65); }

			DebugLocation(689, 24);
			RBRACK294=(IToken)Match(input,RBRACK,Follow._RBRACK_in_arrayLiteral3686); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACK.Add(RBRACK294);



			{
			// AST REWRITE
			// elements: LBRACK, elementList, RBRACK
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 690:3: -> ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK )
			{
				DebugLocation(690, 6);
				// AS3.g:690:6: ^( ARRAY_LITERAL LBRACK ( elementList )? RBRACK )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(690, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY_LITERAL, "ARRAY_LITERAL"), root_1);

				DebugLocation(690, 22);
				adaptor.AddChild(root_1, stream_LBRACK.NextNode());
				DebugLocation(690, 29);
				// AS3.g:690:29: ( elementList )?
				if (stream_elementList.HasNext)
				{
					DebugLocation(690, 29);
					adaptor.AddChild(root_1, stream_elementList.NextTree());

				}
				stream_elementList.Reset();
				DebugLocation(690, 42);
				adaptor.AddChild(root_1, stream_RBRACK.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 86);
			LeaveRule("arrayLiteral", 86);
			LeaveRule_arrayLiteral();
		}
		DebugLocation(691, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_elementList();
	partial void LeaveRule_elementList();
	// $ANTLR start "elementList"
	// AS3.g:693:1: elementList : ( COMMA !| nonemptyElementList );
	[GrammarRule("elementList")]
	private AstParserRuleReturnScope<CommonTree, IToken> elementList()
	{
		EnterRule_elementList();
		EnterRule("elementList", 87);
		TraceIn("elementList", 87);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA295 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> nonemptyElementList296 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA295_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "elementList");
		DebugLocation(693, 1);
		try
		{
			// AS3.g:694:2: ( COMMA !| nonemptyElementList )
			int alt66=2;
			try { DebugEnterDecision(66, false);
			int LA66_1 = input.LA(1);

			if ((LA66_1==COMMA))
			{
				alt66 = 1;
			}
			else if ((LA66_1==AS||LA66_1==BNOT||(LA66_1>=DEC && LA66_1<=DECIMAL_LITERAL)||(LA66_1>=DYNAMIC && LA66_1<=E4X_ATTRI)||(LA66_1>=FALSE && LA66_1<=FLOAT_LITERAL)||LA66_1==FUNCTION||LA66_1==GET||(LA66_1>=HEX_LITERAL && LA66_1<=IDENT)||LA66_1==INC||(LA66_1>=INTERNAL && LA66_1<=IS)||(LA66_1>=LBRACK && LA66_1<=LCURLY)||LA66_1==LNOT||LA66_1==LPAREN||LA66_1==MINUS||LA66_1==NAMESPACE||LA66_1==NEW||LA66_1==NULL||LA66_1==OCTAL_LITERAL||LA66_1==PLUS||LA66_1==PRIVATE||(LA66_1>=PROTECTED && LA66_1<=PUBLIC)||LA66_1==REGEX_LITERAL||LA66_1==SET||(LA66_1>=STRING_LITERAL_DOUBLE && LA66_1<=SUPER)||LA66_1==TRUE||LA66_1==USE||LA66_1==XML||LA66_1==XML_LITERAL||LA66_1==243||(LA66_1>=255 && LA66_1<=257)))
			{
				alt66 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 66, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:694:4: COMMA !
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(694, 9);
				COMMA295=(IToken)Match(input,COMMA,Follow._COMMA_in_elementList3714); if (state.failed) return retval;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:695:4: nonemptyElementList
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(695, 4);
				PushFollow(Follow._nonemptyElementList_in_elementList3720);
				nonemptyElementList296=nonemptyElementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, nonemptyElementList296.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("elementList", 87);
			LeaveRule("elementList", 87);
			LeaveRule_elementList();
		}
		DebugLocation(696, 1);
		} finally { DebugExitRule(GrammarFileName, "elementList"); }
		return retval;

	}
	// $ANTLR end "elementList"

	partial void EnterRule_nonemptyElementList();
	partial void LeaveRule_nonemptyElementList();
	// $ANTLR start "nonemptyElementList"
	// AS3.g:697:1: nonemptyElementList : assignmentExpression ( COMMA ! assignmentExpression )* ;
	[GrammarRule("nonemptyElementList")]
	private AstParserRuleReturnScope<CommonTree, IToken> nonemptyElementList()
	{
		EnterRule_nonemptyElementList();
		EnterRule("nonemptyElementList", 88);
		TraceIn("nonemptyElementList", 88);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA298 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression297 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression299 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA298_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "nonemptyElementList");
		DebugLocation(697, 1);
		try
		{
			// AS3.g:698:2: ( assignmentExpression ( COMMA ! assignmentExpression )* )
			DebugEnterAlt(1);
			// AS3.g:698:4: assignmentExpression ( COMMA ! assignmentExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(698, 4);
			PushFollow(Follow._assignmentExpression_in_nonemptyElementList3730);
			assignmentExpression297=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression297.Tree);
			DebugLocation(698, 25);
			// AS3.g:698:25: ( COMMA ! assignmentExpression )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==COMMA))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:698:26: COMMA ! assignmentExpression
					{
					DebugLocation(698, 31);
					COMMA298=(IToken)Match(input,COMMA,Follow._COMMA_in_nonemptyElementList3733); if (state.failed) return retval;
					DebugLocation(698, 33);
					PushFollow(Follow._assignmentExpression_in_nonemptyElementList3736);
					assignmentExpression299=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression299.Tree);

					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonemptyElementList", 88);
			LeaveRule("nonemptyElementList", 88);
			LeaveRule_nonemptyElementList();
		}
		DebugLocation(699, 1);
		} finally { DebugExitRule(GrammarFileName, "nonemptyElementList"); }
		return retval;

	}
	// $ANTLR end "nonemptyElementList"

	partial void EnterRule_element();
	partial void LeaveRule_element();
	// $ANTLR start "element"
	// AS3.g:701:1: element : assignmentExpression -> ^( ELEMENT assignmentExpression ) ;
	[GrammarRule("element")]
	private AstParserRuleReturnScope<CommonTree, IToken> element()
	{
		EnterRule_element();
		EnterRule("element", 89);
		TraceIn("element", 89);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression300 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "element");
		DebugLocation(701, 1);
		try
		{
			// AS3.g:702:2: ( assignmentExpression -> ^( ELEMENT assignmentExpression ) )
			DebugEnterAlt(1);
			// AS3.g:702:4: assignmentExpression
			{
			DebugLocation(702, 4);
			PushFollow(Follow._assignmentExpression_in_element3749);
			assignmentExpression300=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression300.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 703:3: -> ^( ELEMENT assignmentExpression )
			{
				DebugLocation(703, 6);
				// AS3.g:703:6: ^( ELEMENT assignmentExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(703, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ELEMENT, "ELEMENT"), root_1);

				DebugLocation(703, 16);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("element", 89);
			LeaveRule("element", 89);
			LeaveRule_element();
		}
		DebugLocation(704, 1);
		} finally { DebugExitRule(GrammarFileName, "element"); }
		return retval;

	}
	// $ANTLR end "element"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// AS3.g:707:1: objectLiteral : LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 90);
		TraceIn("objectLiteral", 90);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LCURLY301 = default(IToken);
		IToken RCURLY303 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> fieldList302 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LCURLY301_tree = default(CommonTree);
		CommonTree RCURLY303_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LCURLY=new RewriteRuleITokenStream(adaptor,"token LCURLY");
		RewriteRuleITokenStream stream_RCURLY=new RewriteRuleITokenStream(adaptor,"token RCURLY");
		RewriteRuleSubtreeStream stream_fieldList=new RewriteRuleSubtreeStream(adaptor,"rule fieldList");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(707, 1);
		try
		{
			// AS3.g:708:2: ( LCURLY ( fieldList )? RCURLY -> ^( OBJECT_LITERAL ( fieldList )? ) )
			DebugEnterAlt(1);
			// AS3.g:708:4: LCURLY ( fieldList )? RCURLY
			{
			DebugLocation(708, 4);
			LCURLY301=(IToken)Match(input,LCURLY,Follow._LCURLY_in_objectLiteral3771); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LCURLY.Add(LCURLY301);

			DebugLocation(708, 11);
			// AS3.g:708:11: ( fieldList )?
			int alt68=2;
			try { DebugEnterSubRule(68);
			try { DebugEnterDecision(68, false);
			int LA68_1 = input.LA(1);

			if ((LA68_1==AS||LA68_1==DECIMAL_LITERAL||LA68_1==DYNAMIC||LA68_1==FLOAT_LITERAL||LA68_1==GET||(LA68_1>=HEX_LITERAL && LA68_1<=IDENT)||LA68_1==IS||LA68_1==NAMESPACE||LA68_1==OCTAL_LITERAL||LA68_1==SET||LA68_1==SUPER||LA68_1==USE||LA68_1==XML))
			{
				alt68 = 1;
			}
			} finally { DebugExitDecision(68); }
			switch (alt68)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:708:11: fieldList
				{
				DebugLocation(708, 11);
				PushFollow(Follow._fieldList_in_objectLiteral3773);
				fieldList302=fieldList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_fieldList.Add(fieldList302.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(68); }

			DebugLocation(708, 22);
			RCURLY303=(IToken)Match(input,RCURLY,Follow._RCURLY_in_objectLiteral3776); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RCURLY.Add(RCURLY303);



			{
			// AST REWRITE
			// elements: fieldList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 709:3: -> ^( OBJECT_LITERAL ( fieldList )? )
			{
				DebugLocation(709, 6);
				// AS3.g:709:6: ^( OBJECT_LITERAL ( fieldList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(709, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(OBJECT_LITERAL, "OBJECT_LITERAL"), root_1);

				DebugLocation(709, 23);
				// AS3.g:709:23: ( fieldList )?
				if (stream_fieldList.HasNext)
				{
					DebugLocation(709, 23);
					adaptor.AddChild(root_1, stream_fieldList.NextTree());

				}
				stream_fieldList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 90);
			LeaveRule("objectLiteral", 90);
			LeaveRule_objectLiteral();
		}
		DebugLocation(710, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_fieldList();
	partial void LeaveRule_fieldList();
	// $ANTLR start "fieldList"
	// AS3.g:712:1: fieldList : literalField ( COMMA ! ( literalField )? )* ;
	[GrammarRule("fieldList")]
	private AstParserRuleReturnScope<CommonTree, IToken> fieldList()
	{
		EnterRule_fieldList();
		EnterRule("fieldList", 91);
		TraceIn("fieldList", 91);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA305 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> literalField304 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> literalField306 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA305_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "fieldList");
		DebugLocation(712, 1);
		try
		{
			// AS3.g:713:2: ( literalField ( COMMA ! ( literalField )? )* )
			DebugEnterAlt(1);
			// AS3.g:713:4: literalField ( COMMA ! ( literalField )? )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(713, 4);
			PushFollow(Follow._literalField_in_fieldList3799);
			literalField304=literalField();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, literalField304.Tree);
			DebugLocation(713, 17);
			// AS3.g:713:17: ( COMMA ! ( literalField )? )*
			try { DebugEnterSubRule(70);
			while (true)
			{
				int alt70=2;
				try { DebugEnterDecision(70, false);
				int LA70_1 = input.LA(1);

				if ((LA70_1==COMMA))
				{
					alt70 = 1;
				}


				} finally { DebugExitDecision(70); }
				switch ( alt70 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:713:18: COMMA ! ( literalField )?
					{
					DebugLocation(713, 23);
					COMMA305=(IToken)Match(input,COMMA,Follow._COMMA_in_fieldList3802); if (state.failed) return retval;
					DebugLocation(713, 25);
					// AS3.g:713:25: ( literalField )?
					int alt69=2;
					try { DebugEnterSubRule(69);
					try { DebugEnterDecision(69, false);
					int LA69_1 = input.LA(1);

					if ((LA69_1==AS||LA69_1==DECIMAL_LITERAL||LA69_1==DYNAMIC||LA69_1==FLOAT_LITERAL||LA69_1==GET||(LA69_1>=HEX_LITERAL && LA69_1<=IDENT)||LA69_1==IS||LA69_1==NAMESPACE||LA69_1==OCTAL_LITERAL||LA69_1==SET||LA69_1==SUPER||LA69_1==USE||LA69_1==XML))
					{
						alt69 = 1;
					}
					} finally { DebugExitDecision(69); }
					switch (alt69)
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:713:25: literalField
						{
						DebugLocation(713, 25);
						PushFollow(Follow._literalField_in_fieldList3805);
						literalField306=literalField();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, literalField306.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(69); }


					}
					break;

				default:
					goto loop70;
				}
			}

			loop70:
				;

			} finally { DebugExitSubRule(70); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fieldList", 91);
			LeaveRule("fieldList", 91);
			LeaveRule_fieldList();
		}
		DebugLocation(714, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldList"); }
		return retval;

	}
	// $ANTLR end "fieldList"

	partial void EnterRule_literalField();
	partial void LeaveRule_literalField();
	// $ANTLR start "literalField"
	// AS3.g:716:1: literalField : fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) ;
	[GrammarRule("literalField")]
	private AstParserRuleReturnScope<CommonTree, IToken> literalField()
	{
		EnterRule_literalField();
		EnterRule("literalField", 92);
		TraceIn("literalField", 92);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COLON308 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> fieldName307 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> element309 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON308_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_fieldName=new RewriteRuleSubtreeStream(adaptor,"rule fieldName");
		RewriteRuleSubtreeStream stream_element=new RewriteRuleSubtreeStream(adaptor,"rule element");
		try { DebugEnterRule(GrammarFileName, "literalField");
		DebugLocation(716, 1);
		try
		{
			// AS3.g:717:2: ( fieldName COLON element -> ^( OBJECT_FIELD fieldName element ) )
			DebugEnterAlt(1);
			// AS3.g:717:5: fieldName COLON element
			{
			DebugLocation(717, 5);
			PushFollow(Follow._fieldName_in_literalField3822);
			fieldName307=fieldName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fieldName.Add(fieldName307.Tree);
			DebugLocation(717, 15);
			COLON308=(IToken)Match(input,COLON,Follow._COLON_in_literalField3824); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON308);

			DebugLocation(717, 21);
			PushFollow(Follow._element_in_literalField3826);
			element309=element();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_element.Add(element309.Tree);


			{
			// AST REWRITE
			// elements: fieldName, element
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 718:3: -> ^( OBJECT_FIELD fieldName element )
			{
				DebugLocation(718, 6);
				// AS3.g:718:6: ^( OBJECT_FIELD fieldName element )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(718, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(OBJECT_FIELD, "OBJECT_FIELD"), root_1);

				DebugLocation(718, 21);
				adaptor.AddChild(root_1, stream_fieldName.NextTree());
				DebugLocation(718, 31);
				adaptor.AddChild(root_1, stream_element.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literalField", 92);
			LeaveRule("literalField", 92);
			LeaveRule_literalField();
		}
		DebugLocation(719, 1);
		} finally { DebugExitRule(GrammarFileName, "literalField"); }
		return retval;

	}
	// $ANTLR end "literalField"

	partial void EnterRule_fieldName();
	partial void LeaveRule_fieldName();
	// $ANTLR start "fieldName"
	// AS3.g:721:1: fieldName : ( ident | number );
	[GrammarRule("fieldName")]
	private AstParserRuleReturnScope<CommonTree, IToken> fieldName()
	{
		EnterRule_fieldName();
		EnterRule("fieldName", 93);
		TraceIn("fieldName", 93);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> ident310 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> number311 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "fieldName");
		DebugLocation(721, 1);
		try
		{
			// AS3.g:722:2: ( ident | number )
			int alt71=2;
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==AS||LA71_1==DYNAMIC||LA71_1==GET||LA71_1==IDENT||LA71_1==IS||LA71_1==NAMESPACE||LA71_1==SET||LA71_1==SUPER||LA71_1==USE||LA71_1==XML))
			{
				alt71 = 1;
			}
			else if ((LA71_1==DECIMAL_LITERAL||LA71_1==FLOAT_LITERAL||LA71_1==HEX_LITERAL||LA71_1==OCTAL_LITERAL))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:722:4: ident
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(722, 4);
				PushFollow(Follow._ident_in_fieldName3850);
				ident310=ident();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ident310.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:723:4: number
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(723, 4);
				PushFollow(Follow._number_in_fieldName3855);
				number311=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, number311.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fieldName", 93);
			LeaveRule("fieldName", 93);
			LeaveRule_fieldName();
		}
		DebugLocation(724, 1);
		} finally { DebugExitRule(GrammarFileName, "fieldName"); }
		return retval;

	}
	// $ANTLR end "fieldName"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// AS3.g:727:1: expression : assignmentExpression -> ^( EXPRESSION assignmentExpression ) ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 94);
		TraceIn("expression", 94);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression312 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(727, 1);
		try
		{
			// AS3.g:728:2: ( assignmentExpression -> ^( EXPRESSION assignmentExpression ) )
			DebugEnterAlt(1);
			// AS3.g:728:4: assignmentExpression
			{
			DebugLocation(728, 4);
			PushFollow(Follow._assignmentExpression_in_expression3867);
			assignmentExpression312=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression312.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 729:9: -> ^( EXPRESSION assignmentExpression )
			{
				DebugLocation(729, 12);
				// AS3.g:729:12: ^( EXPRESSION assignmentExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(729, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPRESSION, "EXPRESSION"), root_1);

				DebugLocation(729, 25);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 94);
			LeaveRule("expression", 94);
			LeaveRule_expression();
		}
		DebugLocation(730, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionList();
	partial void LeaveRule_expressionList();
	// $ANTLR start "expressionList"
	// AS3.g:733:1: expressionList : assignmentExpression ( COMMA assignmentExpression )* -> ^( EXPR_LIST ( assignmentExpression )+ ) ;
	[GrammarRule("expressionList")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionList()
	{
		EnterRule_expressionList();
		EnterRule("expressionList", 95);
		TraceIn("expressionList", 95);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COMMA314 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression313 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression315 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COMMA314_tree = default(CommonTree);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expressionList");
		DebugLocation(733, 1);
		try
		{
			// AS3.g:734:2: ( assignmentExpression ( COMMA assignmentExpression )* -> ^( EXPR_LIST ( assignmentExpression )+ ) )
			DebugEnterAlt(1);
			// AS3.g:734:4: assignmentExpression ( COMMA assignmentExpression )*
			{
			DebugLocation(734, 4);
			PushFollow(Follow._assignmentExpression_in_expressionList3895);
			assignmentExpression313=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression313.Tree);
			DebugLocation(734, 25);
			// AS3.g:734:25: ( COMMA assignmentExpression )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==COMMA))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:734:26: COMMA assignmentExpression
					{
					DebugLocation(734, 26);
					COMMA314=(IToken)Match(input,COMMA,Follow._COMMA_in_expressionList3898); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA314);

					DebugLocation(734, 32);
					PushFollow(Follow._assignmentExpression_in_expressionList3900);
					assignmentExpression315=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression315.Tree);

					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 735:9: -> ^( EXPR_LIST ( assignmentExpression )+ )
			{
				DebugLocation(735, 12);
				// AS3.g:735:12: ^( EXPR_LIST ( assignmentExpression )+ )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(735, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(EXPR_LIST, "EXPR_LIST"), root_1);

				DebugLocation(735, 24);
				if (!(stream_assignmentExpression.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(735, 24);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionList", 95);
			LeaveRule("expressionList", 95);
			LeaveRule_expressionList();
		}
		DebugLocation(736, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionList"); }
		return retval;

	}
	// $ANTLR end "expressionList"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// AS3.g:739:1: assignmentExpression : conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* ;
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 96);
		TraceIn("assignmentExpression", 96);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression316 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentOperator317 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression318 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(739, 1);
		try
		{
			// AS3.g:740:2: ( conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )* )
			DebugEnterAlt(1);
			// AS3.g:740:4: conditionalExpression ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(740, 4);
			PushFollow(Follow._conditionalExpression_in_assignmentExpression3931);
			conditionalExpression316=conditionalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, conditionalExpression316.Tree);
			DebugLocation(740, 26);
			// AS3.g:740:26: ( ( assignmentOperator )=> assignmentOperator assignmentExpression )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==ASSIGN||LA73_1==BAND_ASSIGN||LA73_1==BOR_ASSIGN||LA73_1==BSR_ASSIGN||LA73_1==BXOR_ASSIGN||LA73_1==DIV_ASSIGN||LA73_1==LAND_ASSIGN||LA73_1==LOR_ASSIGN||LA73_1==MINUS_ASSIGN||LA73_1==MOD_ASSIGN||LA73_1==PLUS_ASSIGN||LA73_1==SL_ASSIGN||LA73_1==SR_ASSIGN||LA73_1==STAR_ASSIGN))
				{
					int LA73_2 = input.LA(2);

					if ((EvaluatePredicate(synpred16_AS3_fragment)))
					{
						alt73 = 1;
					}


				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:740:27: ( assignmentOperator )=> assignmentOperator assignmentExpression
					{
					DebugLocation(740, 51);
					PushFollow(Follow._assignmentOperator_in_assignmentExpression3940);
					assignmentOperator317=assignmentOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentOperator317.Tree);
					DebugLocation(740, 70);
					PushFollow(Follow._assignmentExpression_in_assignmentExpression3942);
					assignmentExpression318=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression318.Tree);

					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 96);
			LeaveRule("assignmentExpression", 96);
			LeaveRule_assignmentExpression();
		}
		DebugLocation(741, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// AS3.g:743:1: assignmentOperator : ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 97);
		TraceIn("assignmentOperator", 97);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set319 = default(IToken);

		CommonTree set319_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(743, 1);
		try
		{
			// AS3.g:744:2: ( ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | SL_ASSIGN | SR_ASSIGN | BSR_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN | LAND_ASSIGN | LOR_ASSIGN )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(744, 2);

			set319=(IToken)input.LT(1);
			if (input.LA(1)==ASSIGN||input.LA(1)==BAND_ASSIGN||input.LA(1)==BOR_ASSIGN||input.LA(1)==BSR_ASSIGN||input.LA(1)==BXOR_ASSIGN||input.LA(1)==DIV_ASSIGN||input.LA(1)==LAND_ASSIGN||input.LA(1)==LOR_ASSIGN||input.LA(1)==MINUS_ASSIGN||input.LA(1)==MOD_ASSIGN||input.LA(1)==PLUS_ASSIGN||input.LA(1)==SL_ASSIGN||input.LA(1)==SR_ASSIGN||input.LA(1)==STAR_ASSIGN)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set319));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 97);
			LeaveRule("assignmentOperator", 97);
			LeaveRule_assignmentOperator();
		}
		DebugLocation(758, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// AS3.g:761:1: conditionalExpression : ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 98);
		TraceIn("conditionalExpression", 98);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken QUESTION321 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalOrExpression320 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionalSubExpression322 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree QUESTION321_tree = default(CommonTree);
		RewriteRuleITokenStream stream_QUESTION=new RewriteRuleITokenStream(adaptor,"token QUESTION");
		RewriteRuleSubtreeStream stream_logicalOrExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalOrExpression");
		RewriteRuleSubtreeStream stream_conditionalSubExpression=new RewriteRuleSubtreeStream(adaptor,"rule conditionalSubExpression");
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(761, 1);
		try
		{
			// AS3.g:762:2: ( ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )? )
			DebugEnterAlt(1);
			// AS3.g:762:4: ( logicalOrExpression -> logicalOrExpression ) ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
			{
			DebugLocation(762, 4);
			// AS3.g:762:4: ( logicalOrExpression -> logicalOrExpression )
			DebugEnterAlt(1);
			// AS3.g:762:5: logicalOrExpression
			{
			DebugLocation(762, 5);
			PushFollow(Follow._logicalOrExpression_in_conditionalExpression4035);
			logicalOrExpression320=logicalOrExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalOrExpression.Add(logicalOrExpression320.Tree);


			{
			// AST REWRITE
			// elements: logicalOrExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 762:25: -> logicalOrExpression
			{
				DebugLocation(762, 28);
				adaptor.AddChild(root_0, stream_logicalOrExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(763, 3);
			// AS3.g:763:3: ( QUESTION conditionalSubExpression -> ^( QUESTION $conditionalExpression conditionalSubExpression ) )?
			int alt74=2;
			try { DebugEnterSubRule(74);
			try { DebugEnterDecision(74, false);
			int LA74_1 = input.LA(1);

			if ((LA74_1==QUESTION))
			{
				alt74 = 1;
			}
			} finally { DebugExitDecision(74); }
			switch (alt74)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:764:4: QUESTION conditionalSubExpression
				{
				DebugLocation(764, 4);
				QUESTION321=(IToken)Match(input,QUESTION,Follow._QUESTION_in_conditionalExpression4049); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_QUESTION.Add(QUESTION321);

				DebugLocation(765, 4);
				PushFollow(Follow._conditionalSubExpression_in_conditionalExpression4054);
				conditionalSubExpression322=conditionalSubExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalSubExpression.Add(conditionalSubExpression322.Tree);


				{
				// AST REWRITE
				// elements: QUESTION, conditionalExpression, conditionalSubExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 766:4: -> ^( QUESTION $conditionalExpression conditionalSubExpression )
				{
					DebugLocation(766, 7);
					// AS3.g:766:7: ^( QUESTION $conditionalExpression conditionalSubExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(766, 9);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_QUESTION.NextNode(), root_1);

					DebugLocation(766, 19);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(766, 41);
					adaptor.AddChild(root_1, stream_conditionalSubExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(74); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 98);
			LeaveRule("conditionalExpression", 98);
			LeaveRule_conditionalExpression();
		}
		DebugLocation(768, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalSubExpression();
	partial void LeaveRule_conditionalSubExpression();
	// $ANTLR start "conditionalSubExpression"
	// AS3.g:769:1: conditionalSubExpression : assignmentExpression COLON assignmentExpression ;
	[GrammarRule("conditionalSubExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalSubExpression()
	{
		EnterRule_conditionalSubExpression();
		EnterRule("conditionalSubExpression", 99);
		TraceIn("conditionalSubExpression", 99);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken COLON324 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression323 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression325 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree COLON324_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "conditionalSubExpression");
		DebugLocation(769, 1);
		try
		{
			// AS3.g:770:2: ( assignmentExpression COLON assignmentExpression )
			DebugEnterAlt(1);
			// AS3.g:770:4: assignmentExpression COLON assignmentExpression
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(770, 4);
			PushFollow(Follow._assignmentExpression_in_conditionalSubExpression4083);
			assignmentExpression323=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression323.Tree);
			DebugLocation(770, 25);
			COLON324=(IToken)Match(input,COLON,Follow._COLON_in_conditionalSubExpression4085); if (state.failed) return retval;
			if (state.backtracking == 0) {
			COLON324_tree = (CommonTree)adaptor.Create(COLON324);
			adaptor.AddChild(root_0, COLON324_tree);
			}
			DebugLocation(770, 31);
			PushFollow(Follow._assignmentExpression_in_conditionalSubExpression4087);
			assignmentExpression325=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, assignmentExpression325.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalSubExpression", 99);
			LeaveRule("conditionalSubExpression", 99);
			LeaveRule_conditionalSubExpression();
		}
		DebugLocation(771, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalSubExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalSubExpression"

	partial void EnterRule_logicalOrExpression();
	partial void LeaveRule_logicalOrExpression();
	// $ANTLR start "logicalOrExpression"
	// AS3.g:776:1: logicalOrExpression : logicalAndExpression ( logicalOrOperator logicalAndExpression )* ;
	[GrammarRule("logicalOrExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalOrExpression()
	{
		EnterRule_logicalOrExpression();
		EnterRule("logicalOrExpression", 100);
		TraceIn("logicalOrExpression", 100);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> logicalAndExpression326 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalOrOperator327 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalAndExpression328 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalOrExpression");
		DebugLocation(776, 1);
		try
		{
			// AS3.g:777:2: ( logicalAndExpression ( logicalOrOperator logicalAndExpression )* )
			DebugEnterAlt(1);
			// AS3.g:777:4: logicalAndExpression ( logicalOrOperator logicalAndExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(777, 4);
			PushFollow(Follow._logicalAndExpression_in_logicalOrExpression4101);
			logicalAndExpression326=logicalAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression326.Tree);
			DebugLocation(778, 3);
			// AS3.g:778:3: ( logicalOrOperator logicalAndExpression )*
			try { DebugEnterSubRule(75);
			while (true)
			{
				int alt75=2;
				try { DebugEnterDecision(75, false);
				int LA75_1 = input.LA(1);

				if ((LA75_1==LOR||LA75_1==251))
				{
					alt75 = 1;
				}


				} finally { DebugExitDecision(75); }
				switch ( alt75 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:778:4: logicalOrOperator logicalAndExpression
					{
					DebugLocation(778, 4);
					PushFollow(Follow._logicalOrOperator_in_logicalOrExpression4106);
					logicalOrOperator327=logicalOrOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalOrOperator327.Tree);
					DebugLocation(778, 22);
					PushFollow(Follow._logicalAndExpression_in_logicalOrExpression4108);
					logicalAndExpression328=logicalAndExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndExpression328.Tree);

					}
					break;

				default:
					goto loop75;
				}
			}

			loop75:
				;

			} finally { DebugExitSubRule(75); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrExpression", 100);
			LeaveRule("logicalOrExpression", 100);
			LeaveRule_logicalOrExpression();
		}
		DebugLocation(779, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrExpression"); }
		return retval;

	}
	// $ANTLR end "logicalOrExpression"

	partial void EnterRule_logicalOrOperator();
	partial void LeaveRule_logicalOrOperator();
	// $ANTLR start "logicalOrOperator"
	// AS3.g:781:1: logicalOrOperator : ( LOR | 'or' );
	[GrammarRule("logicalOrOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalOrOperator()
	{
		EnterRule_logicalOrOperator();
		EnterRule("logicalOrOperator", 101);
		TraceIn("logicalOrOperator", 101);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set329 = default(IToken);

		CommonTree set329_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logicalOrOperator");
		DebugLocation(781, 1);
		try
		{
			// AS3.g:782:2: ( LOR | 'or' )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(782, 2);

			set329=(IToken)input.LT(1);
			if (input.LA(1)==LOR||input.LA(1)==251)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set329));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalOrOperator", 101);
			LeaveRule("logicalOrOperator", 101);
			LeaveRule_logicalOrOperator();
		}
		DebugLocation(783, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalOrOperator"); }
		return retval;

	}
	// $ANTLR end "logicalOrOperator"

	partial void EnterRule_logicalAndExpression();
	partial void LeaveRule_logicalAndExpression();
	// $ANTLR start "logicalAndExpression"
	// AS3.g:786:1: logicalAndExpression : bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* ;
	[GrammarRule("logicalAndExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalAndExpression()
	{
		EnterRule_logicalAndExpression();
		EnterRule("logicalAndExpression", 102);
		TraceIn("logicalAndExpression", 102);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> bitwiseOrExpression330 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalAndOperator331 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseOrExpression332 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "logicalAndExpression");
		DebugLocation(786, 1);
		try
		{
			// AS3.g:787:2: ( bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )* )
			DebugEnterAlt(1);
			// AS3.g:787:4: bitwiseOrExpression ( logicalAndOperator bitwiseOrExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(787, 4);
			PushFollow(Follow._bitwiseOrExpression_in_logicalAndExpression4137);
			bitwiseOrExpression330=bitwiseOrExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression330.Tree);
			DebugLocation(788, 3);
			// AS3.g:788:3: ( logicalAndOperator bitwiseOrExpression )*
			try { DebugEnterSubRule(76);
			while (true)
			{
				int alt76=2;
				try { DebugEnterDecision(76, false);
				int LA76_1 = input.LA(1);

				if ((LA76_1==LAND||LA76_1==241))
				{
					alt76 = 1;
				}


				} finally { DebugExitDecision(76); }
				switch ( alt76 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:788:4: logicalAndOperator bitwiseOrExpression
					{
					DebugLocation(788, 4);
					PushFollow(Follow._logicalAndOperator_in_logicalAndExpression4142);
					logicalAndOperator331=logicalAndOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, logicalAndOperator331.Tree);
					DebugLocation(788, 23);
					PushFollow(Follow._bitwiseOrExpression_in_logicalAndExpression4144);
					bitwiseOrExpression332=bitwiseOrExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseOrExpression332.Tree);

					}
					break;

				default:
					goto loop76;
				}
			}

			loop76:
				;

			} finally { DebugExitSubRule(76); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndExpression", 102);
			LeaveRule("logicalAndExpression", 102);
			LeaveRule_logicalAndExpression();
		}
		DebugLocation(789, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndExpression"); }
		return retval;

	}
	// $ANTLR end "logicalAndExpression"

	partial void EnterRule_logicalAndOperator();
	partial void LeaveRule_logicalAndOperator();
	// $ANTLR start "logicalAndOperator"
	// AS3.g:791:1: logicalAndOperator : ( LAND | 'and' );
	[GrammarRule("logicalAndOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalAndOperator()
	{
		EnterRule_logicalAndOperator();
		EnterRule("logicalAndOperator", 103);
		TraceIn("logicalAndOperator", 103);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set333 = default(IToken);

		CommonTree set333_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "logicalAndOperator");
		DebugLocation(791, 1);
		try
		{
			// AS3.g:792:2: ( LAND | 'and' )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(792, 2);

			set333=(IToken)input.LT(1);
			if (input.LA(1)==LAND||input.LA(1)==241)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set333));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalAndOperator", 103);
			LeaveRule("logicalAndOperator", 103);
			LeaveRule_logicalAndOperator();
		}
		DebugLocation(793, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalAndOperator"); }
		return retval;

	}
	// $ANTLR end "logicalAndOperator"

	partial void EnterRule_bitwiseOrExpression();
	partial void LeaveRule_bitwiseOrExpression();
	// $ANTLR start "bitwiseOrExpression"
	// AS3.g:796:1: bitwiseOrExpression : bitwiseXorExpression ( BOR bitwiseXorExpression )* ;
	[GrammarRule("bitwiseOrExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseOrExpression()
	{
		EnterRule_bitwiseOrExpression();
		EnterRule("bitwiseOrExpression", 104);
		TraceIn("bitwiseOrExpression", 104);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken BOR335 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXorExpression334 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXorExpression336 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BOR335_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseOrExpression");
		DebugLocation(796, 1);
		try
		{
			// AS3.g:797:2: ( bitwiseXorExpression ( BOR bitwiseXorExpression )* )
			DebugEnterAlt(1);
			// AS3.g:797:4: bitwiseXorExpression ( BOR bitwiseXorExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(797, 4);
			PushFollow(Follow._bitwiseXorExpression_in_bitwiseOrExpression4173);
			bitwiseXorExpression334=bitwiseXorExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression334.Tree);
			DebugLocation(798, 3);
			// AS3.g:798:3: ( BOR bitwiseXorExpression )*
			try { DebugEnterSubRule(77);
			while (true)
			{
				int alt77=2;
				try { DebugEnterDecision(77, false);
				int LA77_1 = input.LA(1);

				if ((LA77_1==BOR))
				{
					alt77 = 1;
				}


				} finally { DebugExitDecision(77); }
				switch ( alt77 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:798:4: BOR bitwiseXorExpression
					{
					DebugLocation(798, 4);
					BOR335=(IToken)Match(input,BOR,Follow._BOR_in_bitwiseOrExpression4178); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BOR335_tree = (CommonTree)adaptor.Create(BOR335);
					adaptor.AddChild(root_0, BOR335_tree);
					}
					DebugLocation(798, 8);
					PushFollow(Follow._bitwiseXorExpression_in_bitwiseOrExpression4180);
					bitwiseXorExpression336=bitwiseXorExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseXorExpression336.Tree);

					}
					break;

				default:
					goto loop77;
				}
			}

			loop77:
				;

			} finally { DebugExitSubRule(77); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseOrExpression", 104);
			LeaveRule("bitwiseOrExpression", 104);
			LeaveRule_bitwiseOrExpression();
		}
		DebugLocation(799, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseOrExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseOrExpression"

	partial void EnterRule_bitwiseXorExpression();
	partial void LeaveRule_bitwiseXorExpression();
	// $ANTLR start "bitwiseXorExpression"
	// AS3.g:802:1: bitwiseXorExpression : bitwiseAndExpression ( BXOR bitwiseAndExpression )* ;
	[GrammarRule("bitwiseXorExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseXorExpression()
	{
		EnterRule_bitwiseXorExpression();
		EnterRule("bitwiseXorExpression", 105);
		TraceIn("bitwiseXorExpression", 105);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken BXOR338 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseAndExpression337 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseAndExpression339 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BXOR338_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseXorExpression");
		DebugLocation(802, 1);
		try
		{
			// AS3.g:803:2: ( bitwiseAndExpression ( BXOR bitwiseAndExpression )* )
			DebugEnterAlt(1);
			// AS3.g:803:4: bitwiseAndExpression ( BXOR bitwiseAndExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(803, 4);
			PushFollow(Follow._bitwiseAndExpression_in_bitwiseXorExpression4194);
			bitwiseAndExpression337=bitwiseAndExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression337.Tree);
			DebugLocation(804, 3);
			// AS3.g:804:3: ( BXOR bitwiseAndExpression )*
			try { DebugEnterSubRule(78);
			while (true)
			{
				int alt78=2;
				try { DebugEnterDecision(78, false);
				int LA78_1 = input.LA(1);

				if ((LA78_1==BXOR))
				{
					alt78 = 1;
				}


				} finally { DebugExitDecision(78); }
				switch ( alt78 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:804:4: BXOR bitwiseAndExpression
					{
					DebugLocation(804, 4);
					BXOR338=(IToken)Match(input,BXOR,Follow._BXOR_in_bitwiseXorExpression4199); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BXOR338_tree = (CommonTree)adaptor.Create(BXOR338);
					adaptor.AddChild(root_0, BXOR338_tree);
					}
					DebugLocation(804, 9);
					PushFollow(Follow._bitwiseAndExpression_in_bitwiseXorExpression4201);
					bitwiseAndExpression339=bitwiseAndExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, bitwiseAndExpression339.Tree);

					}
					break;

				default:
					goto loop78;
				}
			}

			loop78:
				;

			} finally { DebugExitSubRule(78); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXorExpression", 105);
			LeaveRule("bitwiseXorExpression", 105);
			LeaveRule_bitwiseXorExpression();
		}
		DebugLocation(805, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXorExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXorExpression"

	partial void EnterRule_bitwiseAndExpression();
	partial void LeaveRule_bitwiseAndExpression();
	// $ANTLR start "bitwiseAndExpression"
	// AS3.g:808:1: bitwiseAndExpression : equalityExpression ( BAND equalityExpression )* ;
	[GrammarRule("bitwiseAndExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseAndExpression()
	{
		EnterRule_bitwiseAndExpression();
		EnterRule("bitwiseAndExpression", 106);
		TraceIn("bitwiseAndExpression", 106);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken BAND341 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression340 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression342 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree BAND341_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "bitwiseAndExpression");
		DebugLocation(808, 1);
		try
		{
			// AS3.g:809:2: ( equalityExpression ( BAND equalityExpression )* )
			DebugEnterAlt(1);
			// AS3.g:809:4: equalityExpression ( BAND equalityExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(809, 4);
			PushFollow(Follow._equalityExpression_in_bitwiseAndExpression4215);
			equalityExpression340=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression340.Tree);
			DebugLocation(810, 3);
			// AS3.g:810:3: ( BAND equalityExpression )*
			try { DebugEnterSubRule(79);
			while (true)
			{
				int alt79=2;
				try { DebugEnterDecision(79, false);
				int LA79_1 = input.LA(1);

				if ((LA79_1==BAND))
				{
					alt79 = 1;
				}


				} finally { DebugExitDecision(79); }
				switch ( alt79 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:810:4: BAND equalityExpression
					{
					DebugLocation(810, 4);
					BAND341=(IToken)Match(input,BAND,Follow._BAND_in_bitwiseAndExpression4220); if (state.failed) return retval;
					if (state.backtracking == 0) {
					BAND341_tree = (CommonTree)adaptor.Create(BAND341);
					adaptor.AddChild(root_0, BAND341_tree);
					}
					DebugLocation(810, 9);
					PushFollow(Follow._equalityExpression_in_bitwiseAndExpression4222);
					equalityExpression342=equalityExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityExpression342.Tree);

					}
					break;

				default:
					goto loop79;
				}
			}

			loop79:
				;

			} finally { DebugExitSubRule(79); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseAndExpression", 106);
			LeaveRule("bitwiseAndExpression", 106);
			LeaveRule_bitwiseAndExpression();
		}
		DebugLocation(811, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseAndExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseAndExpression"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// AS3.g:814:1: equalityExpression : relationalExpression ( equalityOperator relationalExpression )* ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 107);
		TraceIn("equalityExpression", 107);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> relationalExpression343 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equalityOperator344 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpression345 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(814, 1);
		try
		{
			// AS3.g:815:2: ( relationalExpression ( equalityOperator relationalExpression )* )
			DebugEnterAlt(1);
			// AS3.g:815:4: relationalExpression ( equalityOperator relationalExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(815, 4);
			PushFollow(Follow._relationalExpression_in_equalityExpression4236);
			relationalExpression343=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression343.Tree);
			DebugLocation(816, 9);
			// AS3.g:816:9: ( equalityOperator relationalExpression )*
			try { DebugEnterSubRule(80);
			while (true)
			{
				int alt80=2;
				try { DebugEnterDecision(80, false);
				int LA80_1 = input.LA(1);

				if ((LA80_1==EQUAL||LA80_1==NOT_EQUAL||(LA80_1>=STRICT_EQUAL && LA80_1<=STRICT_NOT_EQUAL)))
				{
					alt80 = 1;
				}


				} finally { DebugExitDecision(80); }
				switch ( alt80 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:816:10: equalityOperator relationalExpression
					{
					DebugLocation(816, 10);
					PushFollow(Follow._equalityOperator_in_equalityExpression4247);
					equalityOperator344=equalityOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, equalityOperator344.Tree);
					DebugLocation(816, 27);
					PushFollow(Follow._relationalExpression_in_equalityExpression4249);
					relationalExpression345=relationalExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalExpression345.Tree);

					}
					break;

				default:
					goto loop80;
				}
			}

			loop80:
				;

			} finally { DebugExitSubRule(80); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 107);
			LeaveRule("equalityExpression", 107);
			LeaveRule_equalityExpression();
		}
		DebugLocation(817, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityOperator();
	partial void LeaveRule_equalityOperator();
	// $ANTLR start "equalityOperator"
	// AS3.g:819:1: equalityOperator : ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL );
	[GrammarRule("equalityOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityOperator()
	{
		EnterRule_equalityOperator();
		EnterRule("equalityOperator", 108);
		TraceIn("equalityOperator", 108);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set346 = default(IToken);

		CommonTree set346_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "equalityOperator");
		DebugLocation(819, 1);
		try
		{
			// AS3.g:820:2: ( STRICT_EQUAL | STRICT_NOT_EQUAL | NOT_EQUAL | EQUAL )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(820, 2);

			set346=(IToken)input.LT(1);
			if (input.LA(1)==EQUAL||input.LA(1)==NOT_EQUAL||(input.LA(1)>=STRICT_EQUAL && input.LA(1)<=STRICT_NOT_EQUAL))
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set346));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityOperator", 108);
			LeaveRule("equalityOperator", 108);
			LeaveRule_equalityOperator();
		}
		DebugLocation(821, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityOperator"); }
		return retval;

	}
	// $ANTLR end "equalityOperator"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// AS3.g:824:1: relationalExpression : shiftExpression ( relationalOperator shiftExpression )* ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 109);
		TraceIn("relationalExpression", 109);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> shiftExpression347 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relationalOperator348 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shiftExpression349 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(824, 1);
		try
		{
			// AS3.g:825:2: ( shiftExpression ( relationalOperator shiftExpression )* )
			DebugEnterAlt(1);
			// AS3.g:825:4: shiftExpression ( relationalOperator shiftExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(825, 4);
			PushFollow(Follow._shiftExpression_in_relationalExpression4287);
			shiftExpression347=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression347.Tree);
			DebugLocation(825, 20);
			// AS3.g:825:20: ( relationalOperator shiftExpression )*
			try { DebugEnterSubRule(81);
			while (true)
			{
				int alt81=2;
				try { DebugEnterDecision(81, false);
				int LA81_1 = input.LA(1);

				if ((LA81_1==AS||LA81_1==GE||LA81_1==GT||LA81_1==IS||LA81_1==LE||LA81_1==LT||LA81_1==249))
				{
					alt81 = 1;
				}


				} finally { DebugExitDecision(81); }
				switch ( alt81 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:825:21: relationalOperator shiftExpression
					{
					DebugLocation(825, 21);
					PushFollow(Follow._relationalOperator_in_relationalExpression4290);
					relationalOperator348=relationalOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relationalOperator348.Tree);
					DebugLocation(825, 40);
					PushFollow(Follow._shiftExpression_in_relationalExpression4292);
					shiftExpression349=shiftExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftExpression349.Tree);

					}
					break;

				default:
					goto loop81;
				}
			}

			loop81:
				;

			} finally { DebugExitSubRule(81); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 109);
			LeaveRule("relationalExpression", 109);
			LeaveRule_relationalExpression();
		}
		DebugLocation(826, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalOperator();
	partial void LeaveRule_relationalOperator();
	// $ANTLR start "relationalOperator"
	// AS3.g:828:1: relationalOperator : ( LT | GT | LE | GE | IS | AS | 'instanceof' );
	[GrammarRule("relationalOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalOperator()
	{
		EnterRule_relationalOperator();
		EnterRule("relationalOperator", 110);
		TraceIn("relationalOperator", 110);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set350 = default(IToken);

		CommonTree set350_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "relationalOperator");
		DebugLocation(828, 1);
		try
		{
			// AS3.g:829:2: ( LT | GT | LE | GE | IS | AS | 'instanceof' )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(829, 2);

			set350=(IToken)input.LT(1);
			if (input.LA(1)==AS||input.LA(1)==GE||input.LA(1)==GT||input.LA(1)==IS||input.LA(1)==LE||input.LA(1)==LT||input.LA(1)==249)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set350));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalOperator", 110);
			LeaveRule("relationalOperator", 110);
			LeaveRule_relationalOperator();
		}
		DebugLocation(830, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalOperator"); }
		return retval;

	}
	// $ANTLR end "relationalOperator"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// AS3.g:833:1: shiftExpression : additiveExpression ( shiftOperator additiveExpression )* ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 111);
		TraceIn("shiftExpression", 111);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> additiveExpression351 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shiftOperator352 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> additiveExpression353 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(833, 1);
		try
		{
			// AS3.g:834:2: ( additiveExpression ( shiftOperator additiveExpression )* )
			DebugEnterAlt(1);
			// AS3.g:834:4: additiveExpression ( shiftOperator additiveExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(834, 4);
			PushFollow(Follow._additiveExpression_in_shiftExpression4342);
			additiveExpression351=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression351.Tree);
			DebugLocation(835, 3);
			// AS3.g:835:3: ( shiftOperator additiveExpression )*
			try { DebugEnterSubRule(82);
			while (true)
			{
				int alt82=2;
				try { DebugEnterDecision(82, false);
				int LA82_1 = input.LA(1);

				if ((LA82_1==BSR||LA82_1==SL||LA82_1==SR))
				{
					alt82 = 1;
				}


				} finally { DebugExitDecision(82); }
				switch ( alt82 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:835:4: shiftOperator additiveExpression
					{
					DebugLocation(835, 4);
					PushFollow(Follow._shiftOperator_in_shiftExpression4347);
					shiftOperator352=shiftOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, shiftOperator352.Tree);
					DebugLocation(835, 18);
					PushFollow(Follow._additiveExpression_in_shiftExpression4349);
					additiveExpression353=additiveExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveExpression353.Tree);

					}
					break;

				default:
					goto loop82;
				}
			}

			loop82:
				;

			} finally { DebugExitSubRule(82); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 111);
			LeaveRule("shiftExpression", 111);
			LeaveRule_shiftExpression();
		}
		DebugLocation(836, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_shiftOperator();
	partial void LeaveRule_shiftOperator();
	// $ANTLR start "shiftOperator"
	// AS3.g:838:1: shiftOperator : ( SL | SR | BSR );
	[GrammarRule("shiftOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> shiftOperator()
	{
		EnterRule_shiftOperator();
		EnterRule("shiftOperator", 112);
		TraceIn("shiftOperator", 112);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set354 = default(IToken);

		CommonTree set354_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "shiftOperator");
		DebugLocation(838, 1);
		try
		{
			// AS3.g:839:2: ( SL | SR | BSR )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(839, 2);

			set354=(IToken)input.LT(1);
			if (input.LA(1)==BSR||input.LA(1)==SL||input.LA(1)==SR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set354));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftOperator", 112);
			LeaveRule("shiftOperator", 112);
			LeaveRule_shiftOperator();
		}
		DebugLocation(840, 1);
		} finally { DebugExitRule(GrammarFileName, "shiftOperator"); }
		return retval;

	}
	// $ANTLR end "shiftOperator"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// AS3.g:843:1: additiveExpression : multiplicativeExpression ( additiveOperator multiplicativeExpression )* ;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 113);
		TraceIn("additiveExpression", 113);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression355 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> additiveOperator356 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression357 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(843, 1);
		try
		{
			// AS3.g:844:2: ( multiplicativeExpression ( additiveOperator multiplicativeExpression )* )
			DebugEnterAlt(1);
			// AS3.g:844:4: multiplicativeExpression ( additiveOperator multiplicativeExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(844, 4);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression4382);
			multiplicativeExpression355=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression355.Tree);
			DebugLocation(844, 29);
			// AS3.g:844:29: ( additiveOperator multiplicativeExpression )*
			try { DebugEnterSubRule(83);
			while (true)
			{
				int alt83=2;
				try { DebugEnterDecision(83, false);
				int LA83_1 = input.LA(1);

				if ((LA83_1==MINUS||LA83_1==PLUS))
				{
					alt83 = 1;
				}


				} finally { DebugExitDecision(83); }
				switch ( alt83 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:844:30: additiveOperator multiplicativeExpression
					{
					DebugLocation(844, 30);
					PushFollow(Follow._additiveOperator_in_additiveExpression4385);
					additiveOperator356=additiveOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, additiveOperator356.Tree);
					DebugLocation(844, 47);
					PushFollow(Follow._multiplicativeExpression_in_additiveExpression4387);
					multiplicativeExpression357=multiplicativeExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeExpression357.Tree);

					}
					break;

				default:
					goto loop83;
				}
			}

			loop83:
				;

			} finally { DebugExitSubRule(83); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 113);
			LeaveRule("additiveExpression", 113);
			LeaveRule_additiveExpression();
		}
		DebugLocation(845, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_additiveOperator();
	partial void LeaveRule_additiveOperator();
	// $ANTLR start "additiveOperator"
	// AS3.g:847:1: additiveOperator : ( PLUS | MINUS );
	[GrammarRule("additiveOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> additiveOperator()
	{
		EnterRule_additiveOperator();
		EnterRule("additiveOperator", 114);
		TraceIn("additiveOperator", 114);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set358 = default(IToken);

		CommonTree set358_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "additiveOperator");
		DebugLocation(847, 1);
		try
		{
			// AS3.g:848:2: ( PLUS | MINUS )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(848, 2);

			set358=(IToken)input.LT(1);
			if (input.LA(1)==MINUS||input.LA(1)==PLUS)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set358));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveOperator", 114);
			LeaveRule("additiveOperator", 114);
			LeaveRule_additiveOperator();
		}
		DebugLocation(849, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveOperator"); }
		return retval;

	}
	// $ANTLR end "additiveOperator"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// AS3.g:852:1: multiplicativeExpression : unaryExpression ( multiplicativeOperator unaryExpression )* ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 115);
		TraceIn("multiplicativeExpression", 115);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression359 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> multiplicativeOperator360 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression361 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(852, 1);
		try
		{
			// AS3.g:853:2: ( unaryExpression ( multiplicativeOperator unaryExpression )* )
			DebugEnterAlt(1);
			// AS3.g:853:4: unaryExpression ( multiplicativeOperator unaryExpression )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(853, 4);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression4416);
			unaryExpression359=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression359.Tree);
			DebugLocation(854, 3);
			// AS3.g:854:3: ( multiplicativeOperator unaryExpression )*
			try { DebugEnterSubRule(84);
			while (true)
			{
				int alt84=2;
				try { DebugEnterDecision(84, false);
				int LA84_1 = input.LA(1);

				if ((LA84_1==DIV||LA84_1==MOD||LA84_1==STAR))
				{
					alt84 = 1;
				}


				} finally { DebugExitDecision(84); }
				switch ( alt84 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:854:5: multiplicativeOperator unaryExpression
					{
					DebugLocation(854, 5);
					PushFollow(Follow._multiplicativeOperator_in_multiplicativeExpression4422);
					multiplicativeOperator360=multiplicativeOperator();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, multiplicativeOperator360.Tree);
					DebugLocation(855, 4);
					PushFollow(Follow._unaryExpression_in_multiplicativeExpression4427);
					unaryExpression361=unaryExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression361.Tree);

					}
					break;

				default:
					goto loop84;
				}
			}

			loop84:
				;

			} finally { DebugExitSubRule(84); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 115);
			LeaveRule("multiplicativeExpression", 115);
			LeaveRule_multiplicativeExpression();
		}
		DebugLocation(857, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_multiplicativeOperator();
	partial void LeaveRule_multiplicativeOperator();
	// $ANTLR start "multiplicativeOperator"
	// AS3.g:859:1: multiplicativeOperator : ( STAR | DIV | MOD );
	[GrammarRule("multiplicativeOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplicativeOperator()
	{
		EnterRule_multiplicativeOperator();
		EnterRule("multiplicativeOperator", 116);
		TraceIn("multiplicativeOperator", 116);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set362 = default(IToken);

		CommonTree set362_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "multiplicativeOperator");
		DebugLocation(859, 1);
		try
		{
			// AS3.g:860:2: ( STAR | DIV | MOD )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(860, 2);

			set362=(IToken)input.LT(1);
			if (input.LA(1)==DIV||input.LA(1)==MOD||input.LA(1)==STAR)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set362));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeOperator", 116);
			LeaveRule("multiplicativeOperator", 116);
			LeaveRule_multiplicativeOperator();
		}
		DebugLocation(861, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeOperator"); }
		return retval;

	}
	// $ANTLR end "multiplicativeOperator"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// AS3.g:864:1: unaryExpression : (inc= INC unaryExpression |dec= DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus );
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 117);
		TraceIn("unaryExpression", 117);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken inc = default(IToken);
		IToken dec = default(IToken);
		IToken MINUS365 = default(IToken);
		IToken PLUS367 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression363 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression364 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression366 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression368 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpressionNotPlusMinus369 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree inc_tree = default(CommonTree);
		CommonTree dec_tree = default(CommonTree);
		CommonTree MINUS365_tree = default(CommonTree);
		CommonTree PLUS367_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(864, 1);
		try
		{
			// AS3.g:865:2: (inc= INC unaryExpression |dec= DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus )
			int alt85=5;
			try { DebugEnterDecision(85, false);
			switch (input.LA(1))
			{
			case INC:
				{
				alt85 = 1;
				}
				break;
			case DEC:
				{
				alt85 = 2;
				}
				break;
			case MINUS:
				{
				alt85 = 3;
				}
				break;
			case PLUS:
				{
				alt85 = 4;
				}
				break;
			case AS:
			case BNOT:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LCURLY:
			case LNOT:
			case LPAREN:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 243:
			case 255:
			case 256:
			case 257:
				{
				alt85 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 85, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(85); }
			switch (alt85)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:865:4: inc= INC unaryExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(865, 7);
				inc=(IToken)Match(input,INC,Follow._INC_in_unaryExpression4465); if (state.failed) return retval;
				if (state.backtracking == 0) {
				inc_tree = (CommonTree)adaptor.Create(inc);
				adaptor.AddChild(root_0, inc_tree);
				}
				DebugLocation(865, 12);
				PushFollow(Follow._unaryExpression_in_unaryExpression4467);
				unaryExpression363=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression363.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:866:4: dec= DEC unaryExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(866, 7);
				dec=(IToken)Match(input,DEC,Follow._DEC_in_unaryExpression4474); if (state.failed) return retval;
				if (state.backtracking == 0) {
				dec_tree = (CommonTree)adaptor.Create(dec);
				adaptor.AddChild(root_0, dec_tree);
				}
				DebugLocation(866, 12);
				PushFollow(Follow._unaryExpression_in_unaryExpression4476);
				unaryExpression364=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression364.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:867:4: MINUS unaryExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(867, 4);
				MINUS365=(IToken)Match(input,MINUS,Follow._MINUS_in_unaryExpression4481); if (state.failed) return retval;
				if (state.backtracking == 0) {
				MINUS365_tree = (CommonTree)adaptor.Create(MINUS365);
				adaptor.AddChild(root_0, MINUS365_tree);
				}
				DebugLocation(867, 10);
				PushFollow(Follow._unaryExpression_in_unaryExpression4483);
				unaryExpression366=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression366.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:868:4: PLUS unaryExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(868, 4);
				PLUS367=(IToken)Match(input,PLUS,Follow._PLUS_in_unaryExpression4488); if (state.failed) return retval;
				if (state.backtracking == 0) {
				PLUS367_tree = (CommonTree)adaptor.Create(PLUS367);
				adaptor.AddChild(root_0, PLUS367_tree);
				}
				DebugLocation(868, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpression4490);
				unaryExpression368=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpression368.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:869:4: unaryExpressionNotPlusMinus
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(869, 4);
				PushFollow(Follow._unaryExpressionNotPlusMinus_in_unaryExpression4495);
				unaryExpressionNotPlusMinus369=unaryExpressionNotPlusMinus();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, unaryExpressionNotPlusMinus369.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 117);
			LeaveRule("unaryExpression", 117);
			LeaveRule_unaryExpression();
		}
		DebugLocation(870, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_unaryExpressionNotPlusMinus();
	partial void LeaveRule_unaryExpressionNotPlusMinus();
	// $ANTLR start "unaryExpressionNotPlusMinus"
	// AS3.g:872:1: unaryExpressionNotPlusMinus : ( 'delete' postfixExpression -> ^( 'delete' postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | 'typeof' unaryExpression -> ^( 'typeof' unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression );
	[GrammarRule("unaryExpressionNotPlusMinus")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryExpressionNotPlusMinus()
	{
		EnterRule_unaryExpressionNotPlusMinus();
		EnterRule("unaryExpressionNotPlusMinus", 118);
		TraceIn("unaryExpressionNotPlusMinus", 118);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal370 = default(IToken);
		IToken string_literal372 = default(IToken);
		IToken string_literal374 = default(IToken);
		IToken LNOT376 = default(IToken);
		IToken BNOT378 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> postfixExpression371 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression373 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression375 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression377 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> unaryExpression379 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> postfixExpression380 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal370_tree = default(CommonTree);
		CommonTree string_literal372_tree = default(CommonTree);
		CommonTree string_literal374_tree = default(CommonTree);
		CommonTree LNOT376_tree = default(CommonTree);
		CommonTree BNOT378_tree = default(CommonTree);
		RewriteRuleITokenStream stream_243=new RewriteRuleITokenStream(adaptor,"token 243");
		RewriteRuleITokenStream stream_257=new RewriteRuleITokenStream(adaptor,"token 257");
		RewriteRuleITokenStream stream_255=new RewriteRuleITokenStream(adaptor,"token 255");
		RewriteRuleITokenStream stream_LNOT=new RewriteRuleITokenStream(adaptor,"token LNOT");
		RewriteRuleITokenStream stream_BNOT=new RewriteRuleITokenStream(adaptor,"token BNOT");
		RewriteRuleSubtreeStream stream_postfixExpression=new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpressionNotPlusMinus");
		DebugLocation(872, 1);
		try
		{
			// AS3.g:873:2: ( 'delete' postfixExpression -> ^( 'delete' postfixExpression ) | 'void' unaryExpression -> ^( 'void' unaryExpression ) | 'typeof' unaryExpression -> ^( 'typeof' unaryExpression ) | LNOT unaryExpression -> ^( LNOT unaryExpression ) | BNOT unaryExpression -> ^( BNOT unaryExpression ) | postfixExpression )
			int alt86=6;
			try { DebugEnterDecision(86, false);
			switch (input.LA(1))
			{
			case 243:
				{
				alt86 = 1;
				}
				break;
			case 257:
				{
				alt86 = 2;
				}
				break;
			case 255:
				{
				alt86 = 3;
				}
				break;
			case LNOT:
				{
				alt86 = 4;
				}
				break;
			case BNOT:
				{
				alt86 = 5;
				}
				break;
			case AS:
			case DECIMAL_LITERAL:
			case DYNAMIC:
			case E4X_ATTRI:
			case FALSE:
			case FLOAT_LITERAL:
			case FUNCTION:
			case GET:
			case HEX_LITERAL:
			case IDENT:
			case INTERNAL:
			case IS:
			case LBRACK:
			case LCURLY:
			case LPAREN:
			case NAMESPACE:
			case NEW:
			case NULL:
			case OCTAL_LITERAL:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case REGEX_LITERAL:
			case SET:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case SUPER:
			case TRUE:
			case USE:
			case XML:
			case XML_LITERAL:
			case 256:
				{
				alt86 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 86, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(86); }
			switch (alt86)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:873:4: 'delete' postfixExpression
				{
				DebugLocation(873, 4);
				string_literal370=(IToken)Match(input,243,Follow._243_in_unaryExpressionNotPlusMinus4506); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_243.Add(string_literal370);

				DebugLocation(873, 13);
				PushFollow(Follow._postfixExpression_in_unaryExpressionNotPlusMinus4508);
				postfixExpression371=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(postfixExpression371.Tree);


				{
				// AST REWRITE
				// elements: 243, postfixExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 873:31: -> ^( 'delete' postfixExpression )
				{
					DebugLocation(873, 34);
					// AS3.g:873:34: ^( 'delete' postfixExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(873, 36);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_243.NextNode(), root_1);

					DebugLocation(873, 45);
					adaptor.AddChild(root_1, stream_postfixExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:874:4: 'void' unaryExpression
				{
				DebugLocation(874, 4);
				string_literal372=(IToken)Match(input,257,Follow._257_in_unaryExpressionNotPlusMinus4521); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_257.Add(string_literal372);

				DebugLocation(874, 11);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4523);
				unaryExpression373=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression373.Tree);


				{
				// AST REWRITE
				// elements: 257, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 874:27: -> ^( 'void' unaryExpression )
				{
					DebugLocation(874, 30);
					// AS3.g:874:30: ^( 'void' unaryExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(874, 32);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_257.NextNode(), root_1);

					DebugLocation(874, 39);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:875:4: 'typeof' unaryExpression
				{
				DebugLocation(875, 4);
				string_literal374=(IToken)Match(input,255,Follow._255_in_unaryExpressionNotPlusMinus4536); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_255.Add(string_literal374);

				DebugLocation(875, 13);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4538);
				unaryExpression375=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression375.Tree);


				{
				// AST REWRITE
				// elements: 255, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 875:29: -> ^( 'typeof' unaryExpression )
				{
					DebugLocation(875, 32);
					// AS3.g:875:32: ^( 'typeof' unaryExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(875, 34);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_255.NextNode(), root_1);

					DebugLocation(875, 43);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:876:4: LNOT unaryExpression
				{
				DebugLocation(876, 4);
				LNOT376=(IToken)Match(input,LNOT,Follow._LNOT_in_unaryExpressionNotPlusMinus4551); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LNOT.Add(LNOT376);

				DebugLocation(876, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4553);
				unaryExpression377=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression377.Tree);


				{
				// AST REWRITE
				// elements: LNOT, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 876:25: -> ^( LNOT unaryExpression )
				{
					DebugLocation(876, 28);
					// AS3.g:876:28: ^( LNOT unaryExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(876, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_LNOT.NextNode(), root_1);

					DebugLocation(876, 35);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:877:4: BNOT unaryExpression
				{
				DebugLocation(877, 4);
				BNOT378=(IToken)Match(input,BNOT,Follow._BNOT_in_unaryExpressionNotPlusMinus4566); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BNOT.Add(BNOT378);

				DebugLocation(877, 9);
				PushFollow(Follow._unaryExpression_in_unaryExpressionNotPlusMinus4568);
				unaryExpression379=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(unaryExpression379.Tree);


				{
				// AST REWRITE
				// elements: BNOT, unaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 877:25: -> ^( BNOT unaryExpression )
				{
					DebugLocation(877, 28);
					// AS3.g:877:28: ^( BNOT unaryExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(877, 30);
					root_1 = (CommonTree)adaptor.BecomeRoot(stream_BNOT.NextNode(), root_1);

					DebugLocation(877, 35);
					adaptor.AddChild(root_1, stream_unaryExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:878:4: postfixExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(878, 4);
				PushFollow(Follow._postfixExpression_in_unaryExpressionNotPlusMinus4581);
				postfixExpression380=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, postfixExpression380.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpressionNotPlusMinus", 118);
			LeaveRule("unaryExpressionNotPlusMinus", 118);
			LeaveRule_unaryExpressionNotPlusMinus();
		}
		DebugLocation(879, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpressionNotPlusMinus"); }
		return retval;

	}
	// $ANTLR end "unaryExpressionNotPlusMinus"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// AS3.g:885:1: postfixExpression : ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )? ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 119);
		TraceIn("postfixExpression", 119);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DOT383 = default(IToken);
		IToken E4X_DESC385 = default(IToken);
		IToken LBRACK387 = default(IToken);
		IToken RBRACK389 = default(IToken);
		IToken INC391 = default(IToken);
		IToken DEC392 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primaryExpression381 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propOrIdent382 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> e4xExpression384 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> e4xExpression386 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression388 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arguments390 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT383_tree = default(CommonTree);
		CommonTree E4X_DESC385_tree = default(CommonTree);
		CommonTree LBRACK387_tree = default(CommonTree);
		CommonTree RBRACK389_tree = default(CommonTree);
		CommonTree INC391_tree = default(CommonTree);
		CommonTree DEC392_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_E4X_DESC=new RewriteRuleITokenStream(adaptor,"token E4X_DESC");
		RewriteRuleITokenStream stream_LBRACK=new RewriteRuleITokenStream(adaptor,"token LBRACK");
		RewriteRuleITokenStream stream_RBRACK=new RewriteRuleITokenStream(adaptor,"token RBRACK");
		RewriteRuleITokenStream stream_INC=new RewriteRuleITokenStream(adaptor,"token INC");
		RewriteRuleITokenStream stream_DEC=new RewriteRuleITokenStream(adaptor,"token DEC");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_propOrIdent=new RewriteRuleSubtreeStream(adaptor,"rule propOrIdent");
		RewriteRuleSubtreeStream stream_e4xExpression=new RewriteRuleSubtreeStream(adaptor,"rule e4xExpression");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(885, 2);
		try
		{
			// AS3.g:886:2: ( ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )? )
			DebugEnterAlt(1);
			// AS3.g:886:4: ( primaryExpression -> primaryExpression ) ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )* ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )?
			{
			DebugLocation(886, 4);
			// AS3.g:886:4: ( primaryExpression -> primaryExpression )
			DebugEnterAlt(1);
			// AS3.g:886:5: primaryExpression
			{
			DebugLocation(886, 5);
			PushFollow(Follow._primaryExpression_in_postfixExpression4595);
			primaryExpression381=primaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression381.Tree);


			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 886:23: -> primaryExpression
			{
				DebugLocation(886, 26);
				adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(887, 3);
			// AS3.g:887:3: ( propOrIdent -> ^( PROP_ACCESS $postfixExpression propOrIdent ) | DOT e4xExpression -> ^( E4X_EXPRESSION $postfixExpression e4xExpression ) | E4X_DESC e4xExpression -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression ) | LBRACK expression RBRACK -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) ) | arguments -> ^( FUNCTION_CALL $postfixExpression arguments ) )*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=6;
				try { DebugEnterDecision(87, false);
				switch (input.LA(1))
				{
				case DOT:
					{
					int LA87_2 = input.LA(2);

					if ((LA87_2==AS||LA87_2==DYNAMIC||LA87_2==GET||LA87_2==IDENT||(LA87_2>=INTERNAL && LA87_2<=IS)||LA87_2==NAMESPACE||LA87_2==PRIVATE||(LA87_2>=PROTECTED && LA87_2<=PUBLIC)||LA87_2==SET||LA87_2==SUPER||LA87_2==USE||LA87_2==XML))
					{
						alt87 = 1;
					}
					else if ((LA87_2==E4X_ATTRI||LA87_2==LPAREN||LA87_2==STAR))
					{
						alt87 = 2;
					}


					}
					break;
				case E4X_DESC:
					{
					alt87 = 3;
					}
					break;
				case LBRACK:
					{
					alt87 = 4;
					}
					break;
				case LPAREN:
					{
					alt87 = 5;
					}
					break;
				}

				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:888:13: propOrIdent
					{
					DebugLocation(888, 13);
					PushFollow(Follow._propOrIdent_in_postfixExpression4619);
					propOrIdent382=propOrIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_propOrIdent.Add(propOrIdent382.Tree);


					{
					// AST REWRITE
					// elements: postfixExpression, propOrIdent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 889:13: -> ^( PROP_ACCESS $postfixExpression propOrIdent )
					{
						DebugLocation(889, 16);
						// AS3.g:889:16: ^( PROP_ACCESS $postfixExpression propOrIdent )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(889, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROP_ACCESS, "PROP_ACCESS"), root_1);

						DebugLocation(889, 31);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(889, 49);
						adaptor.AddChild(root_1, stream_propOrIdent.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:892:13: DOT e4xExpression
					{
					DebugLocation(892, 13);
					DOT383=(IToken)Match(input,DOT,Follow._DOT_in_postfixExpression4674); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(DOT383);

					DebugLocation(892, 17);
					PushFollow(Follow._e4xExpression_in_postfixExpression4676);
					e4xExpression384=e4xExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_e4xExpression.Add(e4xExpression384.Tree);


					{
					// AST REWRITE
					// elements: postfixExpression, e4xExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 893:13: -> ^( E4X_EXPRESSION $postfixExpression e4xExpression )
					{
						DebugLocation(893, 16);
						// AS3.g:893:16: ^( E4X_EXPRESSION $postfixExpression e4xExpression )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(893, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(E4X_EXPRESSION, "E4X_EXPRESSION"), root_1);

						DebugLocation(893, 34);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(893, 52);
						adaptor.AddChild(root_1, stream_e4xExpression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// AS3.g:896:13: E4X_DESC e4xExpression
					{
					DebugLocation(896, 13);
					E4X_DESC385=(IToken)Match(input,E4X_DESC,Follow._E4X_DESC_in_postfixExpression4719); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_E4X_DESC.Add(E4X_DESC385);

					DebugLocation(896, 22);
					PushFollow(Follow._e4xExpression_in_postfixExpression4721);
					e4xExpression386=e4xExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_e4xExpression.Add(e4xExpression386.Tree);


					{
					// AST REWRITE
					// elements: postfixExpression, E4X_DESC, e4xExpression
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 897:13: -> ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression )
					{
						DebugLocation(897, 16);
						// AS3.g:897:16: ^( E4X_EXPRESSION $postfixExpression E4X_DESC e4xExpression )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(897, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(E4X_EXPRESSION, "E4X_EXPRESSION"), root_1);

						DebugLocation(897, 34);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(897, 52);
						adaptor.AddChild(root_1, stream_E4X_DESC.NextNode());
						DebugLocation(897, 61);
						adaptor.AddChild(root_1, stream_e4xExpression.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// AS3.g:900:13: LBRACK expression RBRACK
					{
					DebugLocation(900, 13);
					LBRACK387=(IToken)Match(input,LBRACK,Follow._LBRACK_in_postfixExpression4778); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LBRACK.Add(LBRACK387);

					DebugLocation(900, 20);
					PushFollow(Follow._expression_in_postfixExpression4780);
					expression388=expression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expression.Add(expression388.Tree);
					DebugLocation(900, 31);
					RBRACK389=(IToken)Match(input,RBRACK,Follow._RBRACK_in_postfixExpression4782); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_RBRACK.Add(RBRACK389);



					{
					// AST REWRITE
					// elements: postfixExpression, LBRACK, expression, RBRACK
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 901:13: -> ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) )
					{
						DebugLocation(901, 16);
						// AS3.g:901:16: ^( ARRAY_ACCESS $postfixExpression ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK ) )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(901, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY_ACCESS, "ARRAY_ACCESS"), root_1);

						DebugLocation(901, 32);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(901, 50);
						// AS3.g:901:50: ^( ARRAY_SUBSCRIPT LBRACK expression RBRACK )
						{
						CommonTree root_2 = (CommonTree)adaptor.Nil();
						DebugLocation(901, 52);
						root_2 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY_SUBSCRIPT, "ARRAY_SUBSCRIPT"), root_2);

						DebugLocation(901, 68);
						adaptor.AddChild(root_2, stream_LBRACK.NextNode());
						DebugLocation(901, 75);
						adaptor.AddChild(root_2, stream_expression.NextTree());
						DebugLocation(901, 86);
						adaptor.AddChild(root_2, stream_RBRACK.NextNode());

						adaptor.AddChild(root_1, root_2);
						}

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// AS3.g:904:13: arguments
					{
					DebugLocation(904, 13);
					PushFollow(Follow._arguments_in_postfixExpression4833);
					arguments390=arguments();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_arguments.Add(arguments390.Tree);


					{
					// AST REWRITE
					// elements: postfixExpression, arguments
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 905:13: -> ^( FUNCTION_CALL $postfixExpression arguments )
					{
						DebugLocation(905, 16);
						// AS3.g:905:16: ^( FUNCTION_CALL $postfixExpression arguments )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(905, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNCTION_CALL, "FUNCTION_CALL"), root_1);

						DebugLocation(905, 33);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(905, 51);
						adaptor.AddChild(root_1, stream_arguments.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }

			DebugLocation(908, 3);
			// AS3.g:908:3: ( INC -> ^( POST_INC $postfixExpression INC ) | DEC -> ^( POST_DEC $postfixExpression DEC ) )?
			int alt88=3;
			try { DebugEnterSubRule(88);
			try { DebugEnterDecision(88, false);
			int LA88_1 = input.LA(1);

			if ((LA88_1==INC))
			{
				alt88 = 1;
			}
			else if ((LA88_1==DEC))
			{
				alt88 = 2;
			}
			} finally { DebugExitDecision(88); }
			switch (alt88)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:908:6: INC
				{
				DebugLocation(908, 6);
				INC391=(IToken)Match(input,INC,Follow._INC_in_postfixExpression4877); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_INC.Add(INC391);



				{
				// AST REWRITE
				// elements: postfixExpression, INC
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 908:10: -> ^( POST_INC $postfixExpression INC )
				{
					DebugLocation(908, 13);
					// AS3.g:908:13: ^( POST_INC $postfixExpression INC )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(908, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(POST_INC, "POST_INC"), root_1);

					DebugLocation(908, 25);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(908, 43);
					adaptor.AddChild(root_1, stream_INC.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:909:6: DEC
				{
				DebugLocation(909, 6);
				DEC392=(IToken)Match(input,DEC,Follow._DEC_in_postfixExpression4895); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DEC.Add(DEC392);



				{
				// AST REWRITE
				// elements: postfixExpression, DEC
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 909:10: -> ^( POST_DEC $postfixExpression DEC )
				{
					DebugLocation(909, 13);
					// AS3.g:909:13: ^( POST_DEC $postfixExpression DEC )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(909, 15);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(POST_DEC, "POST_DEC"), root_1);

					DebugLocation(909, 25);
					adaptor.AddChild(root_1, stream_retval.NextTree());
					DebugLocation(909, 43);
					adaptor.AddChild(root_1, stream_DEC.NextNode());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(88); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 119);
			LeaveRule("postfixExpression", 119);
			LeaveRule_postfixExpression();
		}
		DebugLocation(912, 2);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_e4xExpression();
	partial void LeaveRule_e4xExpression();
	// $ANTLR start "e4xExpression"
	// AS3.g:914:1: e4xExpression : ( STAR | e4xAttributeIdentifier | e4xFilterPredicate );
	[GrammarRule("e4xExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> e4xExpression()
	{
		EnterRule_e4xExpression();
		EnterRule("e4xExpression", 120);
		TraceIn("e4xExpression", 120);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken STAR393 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> e4xAttributeIdentifier394 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> e4xFilterPredicate395 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree STAR393_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "e4xExpression");
		DebugLocation(914, 1);
		try
		{
			// AS3.g:915:2: ( STAR | e4xAttributeIdentifier | e4xFilterPredicate )
			int alt89=3;
			try { DebugEnterDecision(89, false);
			switch (input.LA(1))
			{
			case STAR:
				{
				alt89 = 1;
				}
				break;
			case E4X_ATTRI:
				{
				alt89 = 2;
				}
				break;
			case LPAREN:
				{
				alt89 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 89, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(89); }
			switch (alt89)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:915:4: STAR
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(915, 4);
				STAR393=(IToken)Match(input,STAR,Follow._STAR_in_e4xExpression4924); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STAR393_tree = (CommonTree)adaptor.Create(STAR393);
				adaptor.AddChild(root_0, STAR393_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:916:4: e4xAttributeIdentifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(916, 4);
				PushFollow(Follow._e4xAttributeIdentifier_in_e4xExpression4929);
				e4xAttributeIdentifier394=e4xAttributeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier394.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:917:4: e4xFilterPredicate
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(917, 4);
				PushFollow(Follow._e4xFilterPredicate_in_e4xExpression4934);
				e4xFilterPredicate395=e4xFilterPredicate();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xFilterPredicate395.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xExpression", 120);
			LeaveRule("e4xExpression", 120);
			LeaveRule_e4xExpression();
		}
		DebugLocation(918, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xExpression"); }
		return retval;

	}
	// $ANTLR end "e4xExpression"

	partial void EnterRule_e4xAttributeIdentifier();
	partial void LeaveRule_e4xAttributeIdentifier();
	// $ANTLR start "e4xAttributeIdentifier"
	// AS3.g:920:1: e4xAttributeIdentifier : E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) ;
	[GrammarRule("e4xAttributeIdentifier")]
	private AstParserRuleReturnScope<CommonTree, IToken> e4xAttributeIdentifier()
	{
		EnterRule_e4xAttributeIdentifier();
		EnterRule("e4xAttributeIdentifier", 121);
		TraceIn("e4xAttributeIdentifier", 121);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken E4X_ATTRI396 = default(IToken);
		IToken STAR398 = default(IToken);
		IToken LBRACK399 = default(IToken);
		IToken RBRACK401 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent397 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression400 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree E4X_ATTRI396_tree = default(CommonTree);
		CommonTree STAR398_tree = default(CommonTree);
		CommonTree LBRACK399_tree = default(CommonTree);
		CommonTree RBRACK401_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "e4xAttributeIdentifier");
		DebugLocation(920, 1);
		try
		{
			// AS3.g:921:2: ( E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK ) )
			DebugEnterAlt(1);
			// AS3.g:921:4: E4X_ATTRI ( qualifiedIdent | STAR | LBRACK expression RBRACK )
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(921, 4);
			E4X_ATTRI396=(IToken)Match(input,E4X_ATTRI,Follow._E4X_ATTRI_in_e4xAttributeIdentifier4945); if (state.failed) return retval;
			if (state.backtracking == 0) {
			E4X_ATTRI396_tree = (CommonTree)adaptor.Create(E4X_ATTRI396);
			adaptor.AddChild(root_0, E4X_ATTRI396_tree);
			}
			DebugLocation(922, 3);
			// AS3.g:922:3: ( qualifiedIdent | STAR | LBRACK expression RBRACK )
			int alt90=3;
			try { DebugEnterSubRule(90);
			try { DebugEnterDecision(90, false);
			switch (input.LA(1))
			{
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case INTERNAL:
			case IS:
			case NAMESPACE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt90 = 1;
				}
				break;
			case STAR:
				{
				alt90 = 2;
				}
				break;
			case LBRACK:
				{
				alt90 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 90, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(90); }
			switch (alt90)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:922:5: qualifiedIdent
				{
				DebugLocation(922, 5);
				PushFollow(Follow._qualifiedIdent_in_e4xAttributeIdentifier4951);
				qualifiedIdent397=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent397.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:923:5: STAR
				{
				DebugLocation(923, 5);
				STAR398=(IToken)Match(input,STAR,Follow._STAR_in_e4xAttributeIdentifier4957); if (state.failed) return retval;
				if (state.backtracking == 0) {
				STAR398_tree = (CommonTree)adaptor.Create(STAR398);
				adaptor.AddChild(root_0, STAR398_tree);
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:924:5: LBRACK expression RBRACK
				{
				DebugLocation(924, 5);
				LBRACK399=(IToken)Match(input,LBRACK,Follow._LBRACK_in_e4xAttributeIdentifier4963); if (state.failed) return retval;
				if (state.backtracking == 0) {
				LBRACK399_tree = (CommonTree)adaptor.Create(LBRACK399);
				adaptor.AddChild(root_0, LBRACK399_tree);
				}
				DebugLocation(924, 12);
				PushFollow(Follow._expression_in_e4xAttributeIdentifier4965);
				expression400=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expression400.Tree);
				DebugLocation(924, 23);
				RBRACK401=(IToken)Match(input,RBRACK,Follow._RBRACK_in_e4xAttributeIdentifier4967); if (state.failed) return retval;
				if (state.backtracking == 0) {
				RBRACK401_tree = (CommonTree)adaptor.Create(RBRACK401);
				adaptor.AddChild(root_0, RBRACK401_tree);
				}

				}
				break;

			}
			} finally { DebugExitSubRule(90); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xAttributeIdentifier", 121);
			LeaveRule("e4xAttributeIdentifier", 121);
			LeaveRule_e4xAttributeIdentifier();
		}
		DebugLocation(926, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xAttributeIdentifier"); }
		return retval;

	}
	// $ANTLR end "e4xAttributeIdentifier"

	partial void EnterRule_e4xFilterPredicate();
	partial void LeaveRule_e4xFilterPredicate();
	// $ANTLR start "e4xFilterPredicate"
	// AS3.g:928:1: e4xFilterPredicate : LPAREN ! expression RPAREN !;
	[GrammarRule("e4xFilterPredicate")]
	private AstParserRuleReturnScope<CommonTree, IToken> e4xFilterPredicate()
	{
		EnterRule_e4xFilterPredicate();
		EnterRule("e4xFilterPredicate", 122);
		TraceIn("e4xFilterPredicate", 122);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN402 = default(IToken);
		IToken RPAREN404 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression403 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN402_tree = default(CommonTree);
		CommonTree RPAREN404_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "e4xFilterPredicate");
		DebugLocation(928, 1);
		try
		{
			// AS3.g:929:2: ( LPAREN ! expression RPAREN !)
			DebugEnterAlt(1);
			// AS3.g:929:4: LPAREN ! expression RPAREN !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(929, 10);
			LPAREN402=(IToken)Match(input,LPAREN,Follow._LPAREN_in_e4xFilterPredicate4982); if (state.failed) return retval;
			DebugLocation(930, 3);
			PushFollow(Follow._expression_in_e4xFilterPredicate4987);
			expression403=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expression403.Tree);
			DebugLocation(931, 9);
			RPAREN404=(IToken)Match(input,RPAREN,Follow._RPAREN_in_e4xFilterPredicate4991); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("e4xFilterPredicate", 122);
			LeaveRule("e4xFilterPredicate", 122);
			LeaveRule_e4xFilterPredicate();
		}
		DebugLocation(932, 1);
		} finally { DebugExitRule(GrammarFileName, "e4xFilterPredicate"); }
		return retval;

	}
	// $ANTLR end "e4xFilterPredicate"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// AS3.g:934:1: primaryExpression : ( 'undefined' | constant -> ^( CONSTANT constant ) | arrayLiteral | objectLiteral | functionDefinition | newExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 123);
		TraceIn("primaryExpression", 123);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken string_literal405 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> constant406 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral407 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> objectLiteral408 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionDefinition409 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> newExpression410 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> encapsulatedExpression411 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> e4xAttributeIdentifier412 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent413 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal405_tree = default(CommonTree);
		RewriteRuleSubtreeStream stream_constant=new RewriteRuleSubtreeStream(adaptor,"rule constant");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(934, 1);
		try
		{
			// AS3.g:935:2: ( 'undefined' | constant -> ^( CONSTANT constant ) | arrayLiteral | objectLiteral | functionDefinition | newExpression | encapsulatedExpression | e4xAttributeIdentifier | qualifiedIdent )
			int alt91=9;
			try { DebugEnterDecision(91, false);
			switch (input.LA(1))
			{
			case 256:
				{
				alt91 = 1;
				}
				break;
			case DECIMAL_LITERAL:
			case FALSE:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case NULL:
			case OCTAL_LITERAL:
			case REGEX_LITERAL:
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
			case TRUE:
			case XML_LITERAL:
				{
				alt91 = 2;
				}
				break;
			case LBRACK:
				{
				alt91 = 3;
				}
				break;
			case LCURLY:
				{
				alt91 = 4;
				}
				break;
			case FUNCTION:
				{
				alt91 = 5;
				}
				break;
			case NEW:
				{
				alt91 = 6;
				}
				break;
			case LPAREN:
				{
				alt91 = 7;
				}
				break;
			case E4X_ATTRI:
				{
				alt91 = 8;
				}
				break;
			case AS:
			case DYNAMIC:
			case GET:
			case IDENT:
			case INTERNAL:
			case IS:
			case NAMESPACE:
			case PRIVATE:
			case PROTECTED:
			case PUBLIC:
			case SET:
			case SUPER:
			case USE:
			case XML:
				{
				alt91 = 9;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 91, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(91); }
			switch (alt91)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:935:4: 'undefined'
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(935, 4);
				string_literal405=(IToken)Match(input,256,Follow._256_in_primaryExpression5003); if (state.failed) return retval;
				if (state.backtracking == 0) {
				string_literal405_tree = (CommonTree)adaptor.Create(string_literal405);
				adaptor.AddChild(root_0, string_literal405_tree);
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:936:4: constant
				{
				DebugLocation(936, 4);
				PushFollow(Follow._constant_in_primaryExpression5008);
				constant406=constant();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_constant.Add(constant406.Tree);


				{
				// AST REWRITE
				// elements: constant
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 937:9: -> ^( CONSTANT constant )
				{
					DebugLocation(937, 12);
					// AS3.g:937:12: ^( CONSTANT constant )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(937, 14);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(CONSTANT, "CONSTANT"), root_1);

					DebugLocation(937, 23);
					adaptor.AddChild(root_1, stream_constant.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:938:4: arrayLiteral
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(938, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression5029);
				arrayLiteral407=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arrayLiteral407.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:939:4: objectLiteral
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(939, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression5034);
				objectLiteral408=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, objectLiteral408.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:940:4: functionDefinition
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(940, 4);
				PushFollow(Follow._functionDefinition_in_primaryExpression5039);
				functionDefinition409=functionDefinition();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDefinition409.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:941:4: newExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(941, 4);
				PushFollow(Follow._newExpression_in_primaryExpression5044);
				newExpression410=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression410.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:942:4: encapsulatedExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(942, 4);
				PushFollow(Follow._encapsulatedExpression_in_primaryExpression5049);
				encapsulatedExpression411=encapsulatedExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, encapsulatedExpression411.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// AS3.g:943:4: e4xAttributeIdentifier
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(943, 4);
				PushFollow(Follow._e4xAttributeIdentifier_in_primaryExpression5054);
				e4xAttributeIdentifier412=e4xAttributeIdentifier();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, e4xAttributeIdentifier412.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// AS3.g:944:4: qualifiedIdent
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(944, 4);
				PushFollow(Follow._qualifiedIdent_in_primaryExpression5059);
				qualifiedIdent413=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent413.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 123);
			LeaveRule("primaryExpression", 123);
			LeaveRule_primaryExpression();
		}
		DebugLocation(946, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_propOrIdent();
	partial void LeaveRule_propOrIdent();
	// $ANTLR start "propOrIdent"
	// AS3.g:949:1: propOrIdent : DOT qualifiedIdent -> ^( PROP_OR_IDENT qualifiedIdent ) ;
	[GrammarRule("propOrIdent")]
	private AstParserRuleReturnScope<CommonTree, IToken> propOrIdent()
	{
		EnterRule_propOrIdent();
		EnterRule("propOrIdent", 124);
		TraceIn("propOrIdent", 124);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DOT414 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent415 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT414_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		try { DebugEnterRule(GrammarFileName, "propOrIdent");
		DebugLocation(949, 1);
		try
		{
			// AS3.g:950:2: ( DOT qualifiedIdent -> ^( PROP_OR_IDENT qualifiedIdent ) )
			DebugEnterAlt(1);
			// AS3.g:951:3: DOT qualifiedIdent
			{
			DebugLocation(951, 3);
			DOT414=(IToken)Match(input,DOT,Follow._DOT_in_propOrIdent5075); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOT.Add(DOT414);

			DebugLocation(951, 7);
			PushFollow(Follow._qualifiedIdent_in_propOrIdent5077);
			qualifiedIdent415=qualifiedIdent();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent415.Tree);


			{
			// AST REWRITE
			// elements: qualifiedIdent
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 957:3: -> ^( PROP_OR_IDENT qualifiedIdent )
			{
				DebugLocation(957, 6);
				// AS3.g:957:6: ^( PROP_OR_IDENT qualifiedIdent )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(957, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROP_OR_IDENT, "PROP_OR_IDENT"), root_1);

				DebugLocation(957, 22);
				adaptor.AddChild(root_1, stream_qualifiedIdent.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propOrIdent", 124);
			LeaveRule("propOrIdent", 124);
			LeaveRule_propOrIdent();
		}
		DebugLocation(958, 1);
		} finally { DebugExitRule(GrammarFileName, "propOrIdent"); }
		return retval;

	}
	// $ANTLR end "propOrIdent"

	partial void EnterRule_constant();
	partial void LeaveRule_constant();
	// $ANTLR start "constant"
	// AS3.g:960:1: constant : ( xmlLiteral | regexpLiteral | number -> ^( LITERAL_NUMBER number ) | stringLiteral -> ^( LITERAL_STRING stringLiteral ) | TRUE | FALSE | NULL );
	[GrammarRule("constant")]
	private AstParserRuleReturnScope<CommonTree, IToken> constant()
	{
		EnterRule_constant();
		EnterRule("constant", 125);
		TraceIn("constant", 125);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken TRUE420 = default(IToken);
		IToken FALSE421 = default(IToken);
		IToken NULL422 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> xmlLiteral416 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> regexpLiteral417 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> number418 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stringLiteral419 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree TRUE420_tree = default(CommonTree);
		CommonTree FALSE421_tree = default(CommonTree);
		CommonTree NULL422_tree = default(CommonTree);
		RewriteRuleSubtreeStream stream_number=new RewriteRuleSubtreeStream(adaptor,"rule number");
		RewriteRuleSubtreeStream stream_stringLiteral=new RewriteRuleSubtreeStream(adaptor,"rule stringLiteral");
		try { DebugEnterRule(GrammarFileName, "constant");
		DebugLocation(960, 1);
		try
		{
			// AS3.g:961:2: ( xmlLiteral | regexpLiteral | number -> ^( LITERAL_NUMBER number ) | stringLiteral -> ^( LITERAL_STRING stringLiteral ) | TRUE | FALSE | NULL )
			int alt92=7;
			try { DebugEnterDecision(92, false);
			switch (input.LA(1))
			{
			case XML_LITERAL:
				{
				alt92 = 1;
				}
				break;
			case REGEX_LITERAL:
				{
				alt92 = 2;
				}
				break;
			case DECIMAL_LITERAL:
			case FLOAT_LITERAL:
			case HEX_LITERAL:
			case OCTAL_LITERAL:
				{
				alt92 = 3;
				}
				break;
			case STRING_LITERAL_DOUBLE:
			case STRING_LITERAL_SINGLE:
				{
				alt92 = 4;
				}
				break;
			case TRUE:
				{
				alt92 = 5;
				}
				break;
			case FALSE:
				{
				alt92 = 6;
				}
				break;
			case NULL:
				{
				alt92 = 7;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 92, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(92); }
			switch (alt92)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:961:4: xmlLiteral
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(961, 4);
				PushFollow(Follow._xmlLiteral_in_constant5102);
				xmlLiteral416=xmlLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, xmlLiteral416.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:962:4: regexpLiteral
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(962, 4);
				PushFollow(Follow._regexpLiteral_in_constant5107);
				regexpLiteral417=regexpLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, regexpLiteral417.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:963:4: number
				{
				DebugLocation(963, 4);
				PushFollow(Follow._number_in_constant5112);
				number418=number();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_number.Add(number418.Tree);


				{
				// AST REWRITE
				// elements: number
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 963:11: -> ^( LITERAL_NUMBER number )
				{
					DebugLocation(963, 14);
					// AS3.g:963:14: ^( LITERAL_NUMBER number )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(963, 16);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_NUMBER, "LITERAL_NUMBER"), root_1);

					DebugLocation(963, 31);
					adaptor.AddChild(root_1, stream_number.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// AS3.g:964:4: stringLiteral
				{
				DebugLocation(964, 4);
				PushFollow(Follow._stringLiteral_in_constant5125);
				stringLiteral419=stringLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_stringLiteral.Add(stringLiteral419.Tree);


				{
				// AST REWRITE
				// elements: stringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 964:18: -> ^( LITERAL_STRING stringLiteral )
				{
					DebugLocation(964, 21);
					// AS3.g:964:21: ^( LITERAL_STRING stringLiteral )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(964, 23);
					root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_STRING, "LITERAL_STRING"), root_1);

					DebugLocation(964, 38);
					adaptor.AddChild(root_1, stream_stringLiteral.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// AS3.g:965:4: TRUE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(965, 4);
				TRUE420=(IToken)Match(input,TRUE,Follow._TRUE_in_constant5138); if (state.failed) return retval;
				if (state.backtracking == 0) {
				TRUE420_tree = (CommonTree)adaptor.Create(TRUE420);
				adaptor.AddChild(root_0, TRUE420_tree);
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// AS3.g:966:4: FALSE
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(966, 4);
				FALSE421=(IToken)Match(input,FALSE,Follow._FALSE_in_constant5143); if (state.failed) return retval;
				if (state.backtracking == 0) {
				FALSE421_tree = (CommonTree)adaptor.Create(FALSE421);
				adaptor.AddChild(root_0, FALSE421_tree);
				}

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// AS3.g:967:4: NULL
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(967, 4);
				NULL422=(IToken)Match(input,NULL,Follow._NULL_in_constant5148); if (state.failed) return retval;
				if (state.backtracking == 0) {
				NULL422_tree = (CommonTree)adaptor.Create(NULL422);
				adaptor.AddChild(root_0, NULL422_tree);
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant", 125);
			LeaveRule("constant", 125);
			LeaveRule_constant();
		}
		DebugLocation(968, 1);
		} finally { DebugExitRule(GrammarFileName, "constant"); }
		return retval;

	}
	// $ANTLR end "constant"

	partial void EnterRule_stringLiteral();
	partial void LeaveRule_stringLiteral();
	// $ANTLR start "stringLiteral"
	// AS3.g:970:1: stringLiteral : ( stringLiteralDouble | stringLiteralSingle );
	[GrammarRule("stringLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> stringLiteral()
	{
		EnterRule_stringLiteral();
		EnterRule("stringLiteral", 126);
		TraceIn("stringLiteral", 126);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> stringLiteralDouble423 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> stringLiteralSingle424 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "stringLiteral");
		DebugLocation(970, 4);
		try
		{
			// AS3.g:971:5: ( stringLiteralDouble | stringLiteralSingle )
			int alt93=2;
			try { DebugEnterDecision(93, false);
			int LA93_1 = input.LA(1);

			if ((LA93_1==STRING_LITERAL_DOUBLE))
			{
				alt93 = 1;
			}
			else if ((LA93_1==STRING_LITERAL_SINGLE))
			{
				alt93 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 93, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(93); }
			switch (alt93)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:971:7: stringLiteralDouble
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(971, 7);
				PushFollow(Follow._stringLiteralDouble_in_stringLiteral5162);
				stringLiteralDouble423=stringLiteralDouble();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteralDouble423.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:971:29: stringLiteralSingle
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(971, 29);
				PushFollow(Follow._stringLiteralSingle_in_stringLiteral5166);
				stringLiteralSingle424=stringLiteralSingle();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, stringLiteralSingle424.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteral", 126);
			LeaveRule("stringLiteral", 126);
			LeaveRule_stringLiteral();
		}
		DebugLocation(972, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteral"); }
		return retval;

	}
	// $ANTLR end "stringLiteral"

	partial void EnterRule_stringLiteralDouble();
	partial void LeaveRule_stringLiteralDouble();
	// $ANTLR start "stringLiteralDouble"
	// AS3.g:974:1: stringLiteralDouble : STRING_LITERAL_DOUBLE -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE ) ;
	[GrammarRule("stringLiteralDouble")]
	private AstParserRuleReturnScope<CommonTree, IToken> stringLiteralDouble()
	{
		EnterRule_stringLiteralDouble();
		EnterRule("stringLiteralDouble", 127);
		TraceIn("stringLiteralDouble", 127);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken STRING_LITERAL_DOUBLE425 = default(IToken);

		CommonTree STRING_LITERAL_DOUBLE425_tree = default(CommonTree);
		RewriteRuleITokenStream stream_STRING_LITERAL_DOUBLE=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL_DOUBLE");
		try { DebugEnterRule(GrammarFileName, "stringLiteralDouble");
		DebugLocation(974, 4);
		try
		{
			// AS3.g:975:5: ( STRING_LITERAL_DOUBLE -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE ) )
			DebugEnterAlt(1);
			// AS3.g:975:7: STRING_LITERAL_DOUBLE
			{
			DebugLocation(975, 7);
			STRING_LITERAL_DOUBLE425=(IToken)Match(input,STRING_LITERAL_DOUBLE,Follow._STRING_LITERAL_DOUBLE_in_stringLiteralDouble5183); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING_LITERAL_DOUBLE.Add(STRING_LITERAL_DOUBLE425);



			{
			// AST REWRITE
			// elements: STRING_LITERAL_DOUBLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 975:29: -> ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE )
			{
				DebugLocation(975, 32);
				// AS3.g:975:32: ^( LITERAL_DOUBLE_STRING STRING_LITERAL_DOUBLE )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(975, 34);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_DOUBLE_STRING, "LITERAL_DOUBLE_STRING"), root_1);

				DebugLocation(975, 56);
				adaptor.AddChild(root_1, stream_STRING_LITERAL_DOUBLE.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteralDouble", 127);
			LeaveRule("stringLiteralDouble", 127);
			LeaveRule_stringLiteralDouble();
		}
		DebugLocation(976, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteralDouble"); }
		return retval;

	}
	// $ANTLR end "stringLiteralDouble"

	partial void EnterRule_stringLiteralSingle();
	partial void LeaveRule_stringLiteralSingle();
	// $ANTLR start "stringLiteralSingle"
	// AS3.g:978:1: stringLiteralSingle : STRING_LITERAL_SINGLE -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE ) ;
	[GrammarRule("stringLiteralSingle")]
	private AstParserRuleReturnScope<CommonTree, IToken> stringLiteralSingle()
	{
		EnterRule_stringLiteralSingle();
		EnterRule("stringLiteralSingle", 128);
		TraceIn("stringLiteralSingle", 128);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken STRING_LITERAL_SINGLE426 = default(IToken);

		CommonTree STRING_LITERAL_SINGLE426_tree = default(CommonTree);
		RewriteRuleITokenStream stream_STRING_LITERAL_SINGLE=new RewriteRuleITokenStream(adaptor,"token STRING_LITERAL_SINGLE");
		try { DebugEnterRule(GrammarFileName, "stringLiteralSingle");
		DebugLocation(978, 4);
		try
		{
			// AS3.g:979:5: ( STRING_LITERAL_SINGLE -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE ) )
			DebugEnterAlt(1);
			// AS3.g:979:7: STRING_LITERAL_SINGLE
			{
			DebugLocation(979, 7);
			STRING_LITERAL_SINGLE426=(IToken)Match(input,STRING_LITERAL_SINGLE,Follow._STRING_LITERAL_SINGLE_in_stringLiteralSingle5208); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_STRING_LITERAL_SINGLE.Add(STRING_LITERAL_SINGLE426);



			{
			// AST REWRITE
			// elements: STRING_LITERAL_SINGLE
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 979:29: -> ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE )
			{
				DebugLocation(979, 32);
				// AS3.g:979:32: ^( LITERAL_SINGLE_STRING STRING_LITERAL_SINGLE )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(979, 34);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_SINGLE_STRING, "LITERAL_SINGLE_STRING"), root_1);

				DebugLocation(979, 56);
				adaptor.AddChild(root_1, stream_STRING_LITERAL_SINGLE.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("stringLiteralSingle", 128);
			LeaveRule("stringLiteralSingle", 128);
			LeaveRule_stringLiteralSingle();
		}
		DebugLocation(980, 4);
		} finally { DebugExitRule(GrammarFileName, "stringLiteralSingle"); }
		return retval;

	}
	// $ANTLR end "stringLiteralSingle"

	partial void EnterRule_number();
	partial void LeaveRule_number();
	// $ANTLR start "number"
	// AS3.g:983:1: number : ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL );
	[GrammarRule("number")]
	private AstParserRuleReturnScope<CommonTree, IToken> number()
	{
		EnterRule_number();
		EnterRule("number", 129);
		TraceIn("number", 129);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set427 = default(IToken);

		CommonTree set427_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "number");
		DebugLocation(983, 1);
		try
		{
			// AS3.g:983:8: ( HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL )
			DebugEnterAlt(1);
			// AS3.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(983, 8);

			set427=(IToken)input.LT(1);
			if (input.LA(1)==DECIMAL_LITERAL||input.LA(1)==FLOAT_LITERAL||input.LA(1)==HEX_LITERAL||input.LA(1)==OCTAL_LITERAL)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set427));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("number", 129);
			LeaveRule("number", 129);
			LeaveRule_number();
		}
		DebugLocation(987, 1);
		} finally { DebugExitRule(GrammarFileName, "number"); }
		return retval;

	}
	// $ANTLR end "number"

	partial void EnterRule_xmlLiteral();
	partial void LeaveRule_xmlLiteral();
	// $ANTLR start "xmlLiteral"
	// AS3.g:990:1: xmlLiteral : XML_LITERAL -> ^( LITERAL_XML XML_LITERAL ) ;
	[GrammarRule("xmlLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> xmlLiteral()
	{
		EnterRule_xmlLiteral();
		EnterRule("xmlLiteral", 130);
		TraceIn("xmlLiteral", 130);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken XML_LITERAL428 = default(IToken);

		CommonTree XML_LITERAL428_tree = default(CommonTree);
		RewriteRuleITokenStream stream_XML_LITERAL=new RewriteRuleITokenStream(adaptor,"token XML_LITERAL");
		try { DebugEnterRule(GrammarFileName, "xmlLiteral");
		DebugLocation(990, 1);
		try
		{
			// AS3.g:991:2: ( XML_LITERAL -> ^( LITERAL_XML XML_LITERAL ) )
			DebugEnterAlt(1);
			// AS3.g:992:11: XML_LITERAL
			{
			DebugLocation(992, 11);
			XML_LITERAL428=(IToken)Match(input,XML_LITERAL,Follow._XML_LITERAL_in_xmlLiteral5269); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_XML_LITERAL.Add(XML_LITERAL428);



			{
			// AST REWRITE
			// elements: XML_LITERAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 993:3: -> ^( LITERAL_XML XML_LITERAL )
			{
				DebugLocation(993, 6);
				// AS3.g:993:6: ^( LITERAL_XML XML_LITERAL )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(993, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_XML, "LITERAL_XML"), root_1);

				DebugLocation(993, 20);
				adaptor.AddChild(root_1, stream_XML_LITERAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("xmlLiteral", 130);
			LeaveRule("xmlLiteral", 130);
			LeaveRule_xmlLiteral();
		}
		DebugLocation(994, 1);
		} finally { DebugExitRule(GrammarFileName, "xmlLiteral"); }
		return retval;

	}
	// $ANTLR end "xmlLiteral"

	partial void EnterRule_regexpLiteral();
	partial void LeaveRule_regexpLiteral();
	// $ANTLR start "regexpLiteral"
	// AS3.g:997:1: regexpLiteral : REGEX_LITERAL -> ^( LITERAL_REGEX REGEX_LITERAL ) ;
	[GrammarRule("regexpLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> regexpLiteral()
	{
		EnterRule_regexpLiteral();
		EnterRule("regexpLiteral", 131);
		TraceIn("regexpLiteral", 131);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken REGEX_LITERAL429 = default(IToken);

		CommonTree REGEX_LITERAL429_tree = default(CommonTree);
		RewriteRuleITokenStream stream_REGEX_LITERAL=new RewriteRuleITokenStream(adaptor,"token REGEX_LITERAL");
		try { DebugEnterRule(GrammarFileName, "regexpLiteral");
		DebugLocation(997, 1);
		try
		{
			// AS3.g:998:2: ( REGEX_LITERAL -> ^( LITERAL_REGEX REGEX_LITERAL ) )
			DebugEnterAlt(1);
			// AS3.g:998:4: REGEX_LITERAL
			{
			DebugLocation(998, 4);
			REGEX_LITERAL429=(IToken)Match(input,REGEX_LITERAL,Follow._REGEX_LITERAL_in_regexpLiteral5299); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_REGEX_LITERAL.Add(REGEX_LITERAL429);



			{
			// AST REWRITE
			// elements: REGEX_LITERAL
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 999:3: -> ^( LITERAL_REGEX REGEX_LITERAL )
			{
				DebugLocation(999, 6);
				// AS3.g:999:6: ^( LITERAL_REGEX REGEX_LITERAL )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(999, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(LITERAL_REGEX, "LITERAL_REGEX"), root_1);

				DebugLocation(999, 22);
				adaptor.AddChild(root_1, stream_REGEX_LITERAL.NextNode());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("regexpLiteral", 131);
			LeaveRule("regexpLiteral", 131);
			LeaveRule_regexpLiteral();
		}
		DebugLocation(1000, 1);
		} finally { DebugExitRule(GrammarFileName, "regexpLiteral"); }
		return retval;

	}
	// $ANTLR end "regexpLiteral"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// AS3.g:1002:1: newExpression : NEW fullNewSubexpression arguments -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments ) ;
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 132);
		TraceIn("newExpression", 132);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken NEW430 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> fullNewSubexpression431 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arguments432 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree NEW430_tree = default(CommonTree);
		RewriteRuleITokenStream stream_NEW=new RewriteRuleITokenStream(adaptor,"token NEW");
		RewriteRuleSubtreeStream stream_fullNewSubexpression=new RewriteRuleSubtreeStream(adaptor,"rule fullNewSubexpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(1002, 1);
		try
		{
			// AS3.g:1003:2: ( NEW fullNewSubexpression arguments -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments ) )
			DebugEnterAlt(1);
			// AS3.g:1003:4: NEW fullNewSubexpression arguments
			{
			DebugLocation(1003, 4);
			NEW430=(IToken)Match(input,NEW,Follow._NEW_in_newExpression5320); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_NEW.Add(NEW430);

			DebugLocation(1003, 8);
			PushFollow(Follow._fullNewSubexpression_in_newExpression5322);
			fullNewSubexpression431=fullNewSubexpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_fullNewSubexpression.Add(fullNewSubexpression431.Tree);
			DebugLocation(1003, 29);
			PushFollow(Follow._arguments_in_newExpression5324);
			arguments432=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(arguments432.Tree);


			{
			// AST REWRITE
			// elements: NEW, fullNewSubexpression, arguments
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1003:39: -> ^( NEW_EXPRESSION NEW fullNewSubexpression arguments )
			{
				DebugLocation(1003, 42);
				// AS3.g:1003:42: ^( NEW_EXPRESSION NEW fullNewSubexpression arguments )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1003, 44);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(NEW_EXPRESSION, "NEW_EXPRESSION"), root_1);

				DebugLocation(1003, 59);
				adaptor.AddChild(root_1, stream_NEW.NextNode());
				DebugLocation(1003, 63);
				adaptor.AddChild(root_1, stream_fullNewSubexpression.NextTree());
				DebugLocation(1003, 84);
				adaptor.AddChild(root_1, stream_arguments.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 132);
			LeaveRule("newExpression", 132);
			LeaveRule_newExpression();
		}
		DebugLocation(1004, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_fullNewSubexpression();
	partial void LeaveRule_fullNewSubexpression();
	// $ANTLR start "fullNewSubexpression"
	// AS3.g:1006:1: fullNewSubexpression : ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* ;
	[GrammarRule("fullNewSubexpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> fullNewSubexpression()
	{
		EnterRule_fullNewSubexpression();
		EnterRule("fullNewSubexpression", 133);
		TraceIn("fullNewSubexpression", 133);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken d = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primaryExpression433 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent434 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> brackets435 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree d_tree = default(CommonTree);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_qualifiedIdent=new RewriteRuleSubtreeStream(adaptor,"rule qualifiedIdent");
		RewriteRuleSubtreeStream stream_brackets=new RewriteRuleSubtreeStream(adaptor,"rule brackets");
		try { DebugEnterRule(GrammarFileName, "fullNewSubexpression");
		DebugLocation(1006, 1);
		try
		{
			// AS3.g:1007:2: ( ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )* )
			DebugEnterAlt(1);
			// AS3.g:1007:4: ( primaryExpression -> primaryExpression ) (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
			{
			DebugLocation(1007, 4);
			// AS3.g:1007:4: ( primaryExpression -> primaryExpression )
			DebugEnterAlt(1);
			// AS3.g:1007:6: primaryExpression
			{
			DebugLocation(1007, 6);
			PushFollow(Follow._primaryExpression_in_fullNewSubexpression5349);
			primaryExpression433=primaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression433.Tree);


			{
			// AST REWRITE
			// elements: primaryExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1007:24: -> primaryExpression
			{
				DebugLocation(1007, 27);
				adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(1009, 3);
			// AS3.g:1009:3: (d= DOT qualifiedIdent -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent ) | brackets -> ^( ARRAY_ACC $fullNewSubexpression brackets ) )*
			try { DebugEnterSubRule(94);
			while (true)
			{
				int alt94=3;
				try { DebugEnterDecision(94, false);
				int LA94_1 = input.LA(1);

				if ((LA94_1==DOT))
				{
					alt94 = 1;
				}
				else if ((LA94_1==LBRACK))
				{
					alt94 = 2;
				}


				} finally { DebugExitDecision(94); }
				switch ( alt94 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1009:5: d= DOT qualifiedIdent
					{
					DebugLocation(1009, 6);
					d=(IToken)Match(input,DOT,Follow._DOT_in_fullNewSubexpression5365); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_DOT.Add(d);

					DebugLocation(1009, 11);
					PushFollow(Follow._qualifiedIdent_in_fullNewSubexpression5367);
					qualifiedIdent434=qualifiedIdent();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_qualifiedIdent.Add(qualifiedIdent434.Tree);


					{
					// AST REWRITE
					// elements: fullNewSubexpression, qualifiedIdent
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1009:26: -> ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent )
					{
						DebugLocation(1009, 29);
						// AS3.g:1009:29: ^( PROP_OR_IDENT $fullNewSubexpression qualifiedIdent )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1009, 31);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(PROP_OR_IDENT, "PROP_OR_IDENT"), root_1);

						DebugLocation(1009, 46);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(1009, 67);
						adaptor.AddChild(root_1, stream_qualifiedIdent.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1010:5: brackets
					{
					DebugLocation(1010, 5);
					PushFollow(Follow._brackets_in_fullNewSubexpression5384);
					brackets435=brackets();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_brackets.Add(brackets435.Tree);


					{
					// AST REWRITE
					// elements: fullNewSubexpression, brackets
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 1010:14: -> ^( ARRAY_ACC $fullNewSubexpression brackets )
					{
						DebugLocation(1010, 17);
						// AS3.g:1010:17: ^( ARRAY_ACC $fullNewSubexpression brackets )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(1010, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ARRAY_ACC, "ARRAY_ACC"), root_1);

						DebugLocation(1010, 30);
						adaptor.AddChild(root_1, stream_retval.NextTree());
						DebugLocation(1010, 51);
						adaptor.AddChild(root_1, stream_brackets.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				default:
					goto loop94;
				}
			}

			loop94:
				;

			} finally { DebugExitSubRule(94); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fullNewSubexpression", 133);
			LeaveRule("fullNewSubexpression", 133);
			LeaveRule_fullNewSubexpression();
		}
		DebugLocation(1012, 1);
		} finally { DebugExitRule(GrammarFileName, "fullNewSubexpression"); }
		return retval;

	}
	// $ANTLR end "fullNewSubexpression"

	partial void EnterRule_propertyOperator();
	partial void LeaveRule_propertyOperator();
	// $ANTLR start "propertyOperator"
	// AS3.g:1014:1: propertyOperator : ( DOT qualifiedIdent | brackets );
	[GrammarRule("propertyOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyOperator()
	{
		EnterRule_propertyOperator();
		EnterRule("propertyOperator", 134);
		TraceIn("propertyOperator", 134);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken DOT436 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> qualifiedIdent437 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> brackets438 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree DOT436_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "propertyOperator");
		DebugLocation(1014, 1);
		try
		{
			// AS3.g:1015:2: ( DOT qualifiedIdent | brackets )
			int alt95=2;
			try { DebugEnterDecision(95, false);
			int LA95_1 = input.LA(1);

			if ((LA95_1==DOT))
			{
				alt95 = 1;
			}
			else if ((LA95_1==LBRACK))
			{
				alt95 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 95, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(95); }
			switch (alt95)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1015:4: DOT qualifiedIdent
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1015, 4);
				DOT436=(IToken)Match(input,DOT,Follow._DOT_in_propertyOperator5411); if (state.failed) return retval;
				if (state.backtracking == 0) {
				DOT436_tree = (CommonTree)adaptor.Create(DOT436);
				adaptor.AddChild(root_0, DOT436_tree);
				}
				DebugLocation(1015, 8);
				PushFollow(Follow._qualifiedIdent_in_propertyOperator5413);
				qualifiedIdent437=qualifiedIdent();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, qualifiedIdent437.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1016:4: brackets
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(1016, 4);
				PushFollow(Follow._brackets_in_propertyOperator5418);
				brackets438=brackets();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, brackets438.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyOperator", 134);
			LeaveRule("propertyOperator", 134);
			LeaveRule_propertyOperator();
		}
		DebugLocation(1017, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyOperator"); }
		return retval;

	}
	// $ANTLR end "propertyOperator"

	partial void EnterRule_brackets();
	partial void LeaveRule_brackets();
	// $ANTLR start "brackets"
	// AS3.g:1019:1: brackets : LBRACK expressionList RBRACK ;
	[GrammarRule("brackets")]
	private AstParserRuleReturnScope<CommonTree, IToken> brackets()
	{
		EnterRule_brackets();
		EnterRule("brackets", 135);
		TraceIn("brackets", 135);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LBRACK439 = default(IToken);
		IToken RBRACK441 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expressionList440 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LBRACK439_tree = default(CommonTree);
		CommonTree RBRACK441_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "brackets");
		DebugLocation(1019, 1);
		try
		{
			// AS3.g:1020:2: ( LBRACK expressionList RBRACK )
			DebugEnterAlt(1);
			// AS3.g:1020:4: LBRACK expressionList RBRACK
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(1020, 4);
			LBRACK439=(IToken)Match(input,LBRACK,Follow._LBRACK_in_brackets5429); if (state.failed) return retval;
			if (state.backtracking == 0) {
			LBRACK439_tree = (CommonTree)adaptor.Create(LBRACK439);
			adaptor.AddChild(root_0, LBRACK439_tree);
			}
			DebugLocation(1020, 11);
			PushFollow(Follow._expressionList_in_brackets5431);
			expressionList440=expressionList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, expressionList440.Tree);
			DebugLocation(1020, 26);
			RBRACK441=(IToken)Match(input,RBRACK,Follow._RBRACK_in_brackets5433); if (state.failed) return retval;
			if (state.backtracking == 0) {
			RBRACK441_tree = (CommonTree)adaptor.Create(RBRACK441);
			adaptor.AddChild(root_0, RBRACK441_tree);
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("brackets", 135);
			LeaveRule("brackets", 135);
			LeaveRule_brackets();
		}
		DebugLocation(1021, 1);
		} finally { DebugExitRule(GrammarFileName, "brackets"); }
		return retval;

	}
	// $ANTLR end "brackets"

	partial void EnterRule_encapsulatedExpression();
	partial void LeaveRule_encapsulatedExpression();
	// $ANTLR start "encapsulatedExpression"
	// AS3.g:1023:1: encapsulatedExpression : LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) ;
	[GrammarRule("encapsulatedExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> encapsulatedExpression()
	{
		EnterRule_encapsulatedExpression();
		EnterRule("encapsulatedExpression", 136);
		TraceIn("encapsulatedExpression", 136);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken LPAREN442 = default(IToken);
		IToken RPAREN444 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression443 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LPAREN442_tree = default(CommonTree);
		CommonTree RPAREN444_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "encapsulatedExpression");
		DebugLocation(1023, 1);
		try
		{
			// AS3.g:1024:2: ( LPAREN assignmentExpression RPAREN -> ^( ENCPS_EXPR assignmentExpression ) )
			DebugEnterAlt(1);
			// AS3.g:1024:4: LPAREN assignmentExpression RPAREN
			{
			DebugLocation(1024, 4);
			LPAREN442=(IToken)Match(input,LPAREN,Follow._LPAREN_in_encapsulatedExpression5444); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN442);

			DebugLocation(1024, 11);
			PushFollow(Follow._assignmentExpression_in_encapsulatedExpression5446);
			assignmentExpression443=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression443.Tree);
			DebugLocation(1024, 32);
			RPAREN444=(IToken)Match(input,RPAREN,Follow._RPAREN_in_encapsulatedExpression5448); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN444);



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1025:3: -> ^( ENCPS_EXPR assignmentExpression )
			{
				DebugLocation(1025, 6);
				// AS3.g:1025:6: ^( ENCPS_EXPR assignmentExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1025, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(ENCPS_EXPR, "ENCPS_EXPR"), root_1);

				DebugLocation(1025, 19);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("encapsulatedExpression", 136);
			LeaveRule("encapsulatedExpression", 136);
			LeaveRule_encapsulatedExpression();
		}
		DebugLocation(1026, 1);
		} finally { DebugExitRule(GrammarFileName, "encapsulatedExpression"); }
		return retval;

	}
	// $ANTLR end "encapsulatedExpression"

	partial void EnterRule_functionDefinition();
	partial void LeaveRule_functionDefinition();
	// $ANTLR start "functionDefinition"
	// AS3.g:1031:1: functionDefinition : FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) ;
	[GrammarRule("functionDefinition")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionDefinition()
	{
		EnterRule_functionDefinition();
		EnterRule("functionDefinition", 137);
		TraceIn("functionDefinition", 137);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken FUNCTION445 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> parameterDeclarationList446 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> typeExpression447 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> block448 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree FUNCTION445_tree = default(CommonTree);
		RewriteRuleITokenStream stream_FUNCTION=new RewriteRuleITokenStream(adaptor,"token FUNCTION");
		RewriteRuleSubtreeStream stream_parameterDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule parameterDeclarationList");
		RewriteRuleSubtreeStream stream_typeExpression=new RewriteRuleSubtreeStream(adaptor,"rule typeExpression");
		RewriteRuleSubtreeStream stream_block=new RewriteRuleSubtreeStream(adaptor,"rule block");
		try { DebugEnterRule(GrammarFileName, "functionDefinition");
		DebugLocation(1031, 1);
		try
		{
			// AS3.g:1032:2: ( FUNCTION parameterDeclarationList ( typeExpression )? block -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block ) )
			DebugEnterAlt(1);
			// AS3.g:1032:4: FUNCTION parameterDeclarationList ( typeExpression )? block
			{
			DebugLocation(1032, 4);
			FUNCTION445=(IToken)Match(input,FUNCTION,Follow._FUNCTION_in_functionDefinition5472); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTION.Add(FUNCTION445);

			DebugLocation(1032, 13);
			PushFollow(Follow._parameterDeclarationList_in_functionDefinition5474);
			parameterDeclarationList446=parameterDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_parameterDeclarationList.Add(parameterDeclarationList446.Tree);
			DebugLocation(1032, 38);
			// AS3.g:1032:38: ( typeExpression )?
			int alt96=2;
			try { DebugEnterSubRule(96);
			try { DebugEnterDecision(96, false);
			int LA96_1 = input.LA(1);

			if ((LA96_1==COLON))
			{
				alt96 = 1;
			}
			} finally { DebugExitDecision(96); }
			switch (alt96)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1032:38: typeExpression
				{
				DebugLocation(1032, 38);
				PushFollow(Follow._typeExpression_in_functionDefinition5476);
				typeExpression447=typeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_typeExpression.Add(typeExpression447.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(96); }

			DebugLocation(1032, 54);
			PushFollow(Follow._block_in_functionDefinition5479);
			block448=block();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_block.Add(block448.Tree);


			{
			// AST REWRITE
			// elements: parameterDeclarationList, typeExpression, block
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 1033:3: -> ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
			{
				DebugLocation(1033, 6);
				// AS3.g:1033:6: ^( FUNC_DEF parameterDeclarationList ( typeExpression )? block )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(1033, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot((CommonTree)adaptor.Create(FUNC_DEF, "FUNC_DEF"), root_1);

				DebugLocation(1033, 17);
				adaptor.AddChild(root_1, stream_parameterDeclarationList.NextTree());
				DebugLocation(1033, 42);
				// AS3.g:1033:42: ( typeExpression )?
				if (stream_typeExpression.HasNext)
				{
					DebugLocation(1033, 42);
					adaptor.AddChild(root_1, stream_typeExpression.NextTree());

				}
				stream_typeExpression.Reset();
				DebugLocation(1033, 58);
				adaptor.AddChild(root_1, stream_block.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
			retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDefinition", 137);
			LeaveRule("functionDefinition", 137);
			LeaveRule_functionDefinition();
		}
		DebugLocation(1034, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDefinition"); }
		return retval;

	}
	// $ANTLR end "functionDefinition"

	partial void EnterRule_synpred1_AS3_fragment();
	partial void LeaveRule_synpred1_AS3_fragment();

	// $ANTLR start synpred1_AS3
	private void synpred1_AS3_fragment()
	{
		EnterRule_synpred1_AS3_fragment();
		EnterRule("synpred1_AS3_fragment", 138);
		TraceIn("synpred1_AS3_fragment", 138);
		try
		{
			// AS3.g:128:4: ( modifiers CLASS )
			DebugEnterAlt(1);
			// AS3.g:128:5: modifiers CLASS
			{
			DebugLocation(128, 5);
			PushFollow(Follow._modifiers_in_synpred1_AS3535);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(128, 15);
			Match(input,CLASS,Follow._CLASS_in_synpred1_AS3537); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_AS3_fragment", 138);
			LeaveRule("synpred1_AS3_fragment", 138);
			LeaveRule_synpred1_AS3_fragment();
		}
	}
	// $ANTLR end synpred1_AS3

	partial void EnterRule_synpred2_AS3_fragment();
	partial void LeaveRule_synpred2_AS3_fragment();

	// $ANTLR start synpred2_AS3
	private void synpred2_AS3_fragment()
	{
		EnterRule_synpred2_AS3_fragment();
		EnterRule("synpred2_AS3_fragment", 139);
		TraceIn("synpred2_AS3_fragment", 139);
		try
		{
			// AS3.g:129:4: ( modifiers INTERFACE )
			DebugEnterAlt(1);
			// AS3.g:129:5: modifiers INTERFACE
			{
			DebugLocation(129, 5);
			PushFollow(Follow._modifiers_in_synpred2_AS3548);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(129, 15);
			Match(input,INTERFACE,Follow._INTERFACE_in_synpred2_AS3550); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_AS3_fragment", 139);
			LeaveRule("synpred2_AS3_fragment", 139);
			LeaveRule_synpred2_AS3_fragment();
		}
	}
	// $ANTLR end synpred2_AS3

	partial void EnterRule_synpred3_AS3_fragment();
	partial void LeaveRule_synpred3_AS3_fragment();

	// $ANTLR start synpred3_AS3
	private void synpred3_AS3_fragment()
	{
		EnterRule_synpred3_AS3_fragment();
		EnterRule("synpred3_AS3_fragment", 140);
		TraceIn("synpred3_AS3_fragment", 140);
		try
		{
			// AS3.g:151:7: ( LBRACK IDENT )
			DebugEnterAlt(1);
			// AS3.g:151:8: LBRACK IDENT
			{
			DebugLocation(151, 8);
			Match(input,LBRACK,Follow._LBRACK_in_synpred3_AS3681); if (state.failed) return;
			DebugLocation(151, 15);
			Match(input,IDENT,Follow._IDENT_in_synpred3_AS3683); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_AS3_fragment", 140);
			LeaveRule("synpred3_AS3_fragment", 140);
			LeaveRule_synpred3_AS3_fragment();
		}
	}
	// $ANTLR end synpred3_AS3

	partial void EnterRule_synpred4_AS3_fragment();
	partial void LeaveRule_synpred4_AS3_fragment();

	// $ANTLR start synpred4_AS3
	private void synpred4_AS3_fragment()
	{
		EnterRule_synpred4_AS3_fragment();
		EnterRule("synpred4_AS3_fragment", 141);
		TraceIn("synpred4_AS3_fragment", 141);
		try
		{
			// AS3.g:152:7: ( modifiers NAMESPACE )
			DebugEnterAlt(1);
			// AS3.g:152:8: modifiers NAMESPACE
			{
			DebugLocation(152, 8);
			PushFollow(Follow._modifiers_in_synpred4_AS3697);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(152, 18);
			Match(input,NAMESPACE,Follow._NAMESPACE_in_synpred4_AS3699); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred4_AS3_fragment", 141);
			LeaveRule("synpred4_AS3_fragment", 141);
			LeaveRule_synpred4_AS3_fragment();
		}
	}
	// $ANTLR end synpred4_AS3

	partial void EnterRule_synpred5_AS3_fragment();
	partial void LeaveRule_synpred5_AS3_fragment();

	// $ANTLR start synpred5_AS3
	private void synpred5_AS3_fragment()
	{
		EnterRule_synpred5_AS3_fragment();
		EnterRule("synpred5_AS3_fragment", 142);
		TraceIn("synpred5_AS3_fragment", 142);
		try
		{
			// AS3.g:153:13: ( modifiers CLASS )
			DebugEnterAlt(1);
			// AS3.g:153:14: modifiers CLASS
			{
			DebugLocation(153, 14);
			PushFollow(Follow._modifiers_in_synpred5_AS3719);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(153, 24);
			Match(input,CLASS,Follow._CLASS_in_synpred5_AS3721); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_AS3_fragment", 142);
			LeaveRule("synpred5_AS3_fragment", 142);
			LeaveRule_synpred5_AS3_fragment();
		}
	}
	// $ANTLR end synpred5_AS3

	partial void EnterRule_synpred6_AS3_fragment();
	partial void LeaveRule_synpred6_AS3_fragment();

	// $ANTLR start synpred6_AS3
	private void synpred6_AS3_fragment()
	{
		EnterRule_synpred6_AS3_fragment();
		EnterRule("synpred6_AS3_fragment", 143);
		TraceIn("synpred6_AS3_fragment", 143);
		try
		{
			// AS3.g:154:7: ( modifiers INTERFACE )
			DebugEnterAlt(1);
			// AS3.g:154:8: modifiers INTERFACE
			{
			DebugLocation(154, 8);
			PushFollow(Follow._modifiers_in_synpred6_AS3735);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(154, 18);
			Match(input,INTERFACE,Follow._INTERFACE_in_synpred6_AS3737); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred6_AS3_fragment", 143);
			LeaveRule("synpred6_AS3_fragment", 143);
			LeaveRule_synpred6_AS3_fragment();
		}
	}
	// $ANTLR end synpred6_AS3

	partial void EnterRule_synpred7_AS3_fragment();
	partial void LeaveRule_synpred7_AS3_fragment();

	// $ANTLR start synpred7_AS3
	private void synpred7_AS3_fragment()
	{
		EnterRule_synpred7_AS3_fragment();
		EnterRule("synpred7_AS3_fragment", 144);
		TraceIn("synpred7_AS3_fragment", 144);
		try
		{
			// AS3.g:155:7: ( modifiers FUNCTION )
			DebugEnterAlt(1);
			// AS3.g:155:8: modifiers FUNCTION
			{
			DebugLocation(155, 8);
			PushFollow(Follow._modifiers_in_synpred7_AS3751);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(155, 18);
			Match(input,FUNCTION,Follow._FUNCTION_in_synpred7_AS3753); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred7_AS3_fragment", 144);
			LeaveRule("synpred7_AS3_fragment", 144);
			LeaveRule_synpred7_AS3_fragment();
		}
	}
	// $ANTLR end synpred7_AS3

	partial void EnterRule_synpred8_AS3_fragment();
	partial void LeaveRule_synpred8_AS3_fragment();

	// $ANTLR start synpred8_AS3
	private void synpred8_AS3_fragment()
	{
		EnterRule_synpred8_AS3_fragment();
		EnterRule("synpred8_AS3_fragment", 145);
		TraceIn("synpred8_AS3_fragment", 145);
		try
		{
			// AS3.g:156:7: ( modifiers varOrConst )
			DebugEnterAlt(1);
			// AS3.g:156:8: modifiers varOrConst
			{
			DebugLocation(156, 8);
			PushFollow(Follow._modifiers_in_synpred8_AS3767);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(156, 18);
			PushFollow(Follow._varOrConst_in_synpred8_AS3769);
			varOrConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred8_AS3_fragment", 145);
			LeaveRule("synpred8_AS3_fragment", 145);
			LeaveRule_synpred8_AS3_fragment();
		}
	}
	// $ANTLR end synpred8_AS3

	partial void EnterRule_synpred9_AS3_fragment();
	partial void LeaveRule_synpred9_AS3_fragment();

	// $ANTLR start synpred9_AS3
	private void synpred9_AS3_fragment()
	{
		EnterRule_synpred9_AS3_fragment();
		EnterRule("synpred9_AS3_fragment", 146);
		TraceIn("synpred9_AS3_fragment", 146);
		try
		{
			// AS3.g:236:4: ( LBRACK IDENT )
			DebugEnterAlt(1);
			// AS3.g:236:5: LBRACK IDENT
			{
			DebugLocation(236, 5);
			Match(input,LBRACK,Follow._LBRACK_in_synpred9_AS31248); if (state.failed) return;
			DebugLocation(236, 12);
			Match(input,IDENT,Follow._IDENT_in_synpred9_AS31250); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_AS3_fragment", 146);
			LeaveRule("synpred9_AS3_fragment", 146);
			LeaveRule_synpred9_AS3_fragment();
		}
	}
	// $ANTLR end synpred9_AS3

	partial void EnterRule_synpred10_AS3_fragment();
	partial void LeaveRule_synpred10_AS3_fragment();

	// $ANTLR start synpred10_AS3
	private void synpred10_AS3_fragment()
	{
		EnterRule_synpred10_AS3_fragment();
		EnterRule("synpred10_AS3_fragment", 147);
		TraceIn("synpred10_AS3_fragment", 147);
		try
		{
			// AS3.g:237:4: ( modifiers varOrConst )
			DebugEnterAlt(1);
			// AS3.g:237:5: modifiers varOrConst
			{
			DebugLocation(237, 5);
			PushFollow(Follow._modifiers_in_synpred10_AS31261);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(237, 15);
			PushFollow(Follow._varOrConst_in_synpred10_AS31263);
			varOrConst();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred10_AS3_fragment", 147);
			LeaveRule("synpred10_AS3_fragment", 147);
			LeaveRule_synpred10_AS3_fragment();
		}
	}
	// $ANTLR end synpred10_AS3

	partial void EnterRule_synpred11_AS3_fragment();
	partial void LeaveRule_synpred11_AS3_fragment();

	// $ANTLR start synpred11_AS3
	private void synpred11_AS3_fragment()
	{
		EnterRule_synpred11_AS3_fragment();
		EnterRule("synpred11_AS3_fragment", 148);
		TraceIn("synpred11_AS3_fragment", 148);
		try
		{
			// AS3.g:238:4: ( modifiers FUNCTION )
			DebugEnterAlt(1);
			// AS3.g:238:5: modifiers FUNCTION
			{
			DebugLocation(238, 5);
			PushFollow(Follow._modifiers_in_synpred11_AS31283);
			modifiers();
			PopFollow();
			if (state.failed) return;
			DebugLocation(238, 15);
			Match(input,FUNCTION,Follow._FUNCTION_in_synpred11_AS31285); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred11_AS3_fragment", 148);
			LeaveRule("synpred11_AS3_fragment", 148);
			LeaveRule_synpred11_AS3_fragment();
		}
	}
	// $ANTLR end synpred11_AS3

	partial void EnterRule_synpred12_AS3_fragment();
	partial void LeaveRule_synpred12_AS3_fragment();

	// $ANTLR start synpred12_AS3
	private void synpred12_AS3_fragment()
	{
		EnterRule_synpred12_AS3_fragment();
		EnterRule("synpred12_AS3_fragment", 149);
		TraceIn("synpred12_AS3_fragment", 149);
		try
		{
			// AS3.g:272:5: ( LCURLY )
			DebugEnterAlt(1);
			// AS3.g:272:6: LCURLY
			{
			DebugLocation(272, 6);
			Match(input,LCURLY,Follow._LCURLY_in_synpred12_AS31496); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred12_AS3_fragment", 149);
			LeaveRule("synpred12_AS3_fragment", 149);
			LeaveRule_synpred12_AS3_fragment();
		}
	}
	// $ANTLR end synpred12_AS3

	partial void EnterRule_synpred13_AS3_fragment();
	partial void LeaveRule_synpred13_AS3_fragment();

	// $ANTLR start synpred13_AS3
	private void synpred13_AS3_fragment()
	{
		EnterRule_synpred13_AS3_fragment();
		EnterRule("synpred13_AS3_fragment", 150);
		TraceIn("synpred13_AS3_fragment", 150);
		try
		{
			// AS3.g:372:4: ( LCURLY )
			DebugEnterAlt(1);
			// AS3.g:372:5: LCURLY
			{
			DebugLocation(372, 5);
			Match(input,LCURLY,Follow._LCURLY_in_synpred13_AS32032); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred13_AS3_fragment", 150);
			LeaveRule("synpred13_AS3_fragment", 150);
			LeaveRule_synpred13_AS3_fragment();
		}
	}
	// $ANTLR end synpred13_AS3

	partial void EnterRule_synpred14_AS3_fragment();
	partial void LeaveRule_synpred14_AS3_fragment();

	// $ANTLR start synpred14_AS3
	private void synpred14_AS3_fragment()
	{
		EnterRule_synpred14_AS3_fragment();
		EnterRule("synpred14_AS3_fragment", 151);
		TraceIn("synpred14_AS3_fragment", 151);
		try
		{
			// AS3.g:419:4: ( ELSE )
			DebugEnterAlt(1);
			// AS3.g:419:5: ELSE
			{
			DebugLocation(419, 5);
			Match(input,ELSE,Follow._ELSE_in_synpred14_AS32227); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred14_AS3_fragment", 151);
			LeaveRule("synpred14_AS3_fragment", 151);
			LeaveRule_synpred14_AS3_fragment();
		}
	}
	// $ANTLR end synpred14_AS3

	partial void EnterRule_synpred15_AS3_fragment();
	partial void LeaveRule_synpred15_AS3_fragment();

	// $ANTLR start synpred15_AS3
	private void synpred15_AS3_fragment()
	{
		EnterRule_synpred15_AS3_fragment();
		EnterRule("synpred15_AS3_fragment", 152);
		TraceIn("synpred15_AS3_fragment", 152);
		try
		{
			// AS3.g:584:10: ( namespaceName DBL_COLON )
			DebugEnterAlt(1);
			// AS3.g:584:11: namespaceName DBL_COLON
			{
			DebugLocation(584, 11);
			PushFollow(Follow._namespaceName_in_synpred15_AS33189);
			namespaceName();
			PopFollow();
			if (state.failed) return;
			DebugLocation(584, 25);
			Match(input,DBL_COLON,Follow._DBL_COLON_in_synpred15_AS33191); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred15_AS3_fragment", 152);
			LeaveRule("synpred15_AS3_fragment", 152);
			LeaveRule_synpred15_AS3_fragment();
		}
	}
	// $ANTLR end synpred15_AS3

	partial void EnterRule_synpred16_AS3_fragment();
	partial void LeaveRule_synpred16_AS3_fragment();

	// $ANTLR start synpred16_AS3
	private void synpred16_AS3_fragment()
	{
		EnterRule_synpred16_AS3_fragment();
		EnterRule("synpred16_AS3_fragment", 153);
		TraceIn("synpred16_AS3_fragment", 153);
		try
		{
			// AS3.g:740:27: ( assignmentOperator )
			DebugEnterAlt(1);
			// AS3.g:740:28: assignmentOperator
			{
			DebugLocation(740, 28);
			PushFollow(Follow._assignmentOperator_in_synpred16_AS33935);
			assignmentOperator();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred16_AS3_fragment", 153);
			LeaveRule("synpred16_AS3_fragment", 153);
			LeaveRule_synpred16_AS3_fragment();
		}
	}
	// $ANTLR end synpred16_AS3
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA3 dfa3;
	private DFA7 dfa7;
	private DFA17 dfa17;
	private DFA20 dfa20;
	private DFA43 dfa43;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa3 = new DFA3( this, SpecialStateTransition3 );
		dfa7 = new DFA7( this, SpecialStateTransition7 );
		dfa17 = new DFA17( this, SpecialStateTransition17 );
		dfa20 = new DFA20( this, SpecialStateTransition20 );
		dfa43 = new DFA43( this );
	}

	private class DFA3 : DFA
	{
		private const string DFA3_eotS =
			"\x16\xFFFF";
		private const string DFA3_eofS =
			"\x16\xFFFF";
		private const string DFA3_minS =
			"\x1\x22\x1\xFFFF\x9\x22\x2\xFFFF\x9\x22";
		private const string DFA3_maxS =
			"\x1\xFC\x1\xFFFF\x9\xFC\x2\xFFFF\x9\xFC";
		private const string DFA3_acceptS =
			"\x1\xFFFF\x1\x1\x9\xFFFF\x1\x2\x1\x3\x9\xFFFF";
		private const string DFA3_specialS =
			"\x1\x0\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x2\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\x12}>";
		private static readonly string[] DFA3_transitionS =
			{
				"\x1\xB\x19\xFFFF\x1\x9\x25\xFFFF\x1\x2\xA\xFFFF\x1\x1\x1\xC\x1\xFFFF"+
				"\x1\x3\x3B\xFFFF\x1\x3\x2\xFFFF\x2\x3\x17\xFFFF\x1\x4\x2B\xFFFF\x1\x6"+
				"\x1\x7\x1\x5\x3\xFFFF\x1\xA\x1\xFFFF\x1\x8",
				"",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"",
				"",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13",
				"\x1\xB\x19\xFFFF\x1\x14\x25\xFFFF\x1\xD\xB\xFFFF\x1\xC\x1\xFFFF\x1\xE"+
				"\x3B\xFFFF\x1\xE\x2\xFFFF\x2\xE\x17\xFFFF\x1\xF\x2B\xFFFF\x1\x11\x1"+
				"\x12\x1\x10\x3\xFFFF\x1\x15\x1\xFFFF\x1\x13"
			};

		private static readonly short[] DFA3_eot = DFA.UnpackEncodedString(DFA3_eotS);
		private static readonly short[] DFA3_eof = DFA.UnpackEncodedString(DFA3_eofS);
		private static readonly char[] DFA3_min = DFA.UnpackEncodedStringToUnsignedChars(DFA3_minS);
		private static readonly char[] DFA3_max = DFA.UnpackEncodedStringToUnsignedChars(DFA3_maxS);
		private static readonly short[] DFA3_accept = DFA.UnpackEncodedString(DFA3_acceptS);
		private static readonly short[] DFA3_special = DFA.UnpackEncodedString(DFA3_specialS);
		private static readonly short[][] DFA3_transition;

		static DFA3()
		{
			int numStates = DFA3_transitionS.Length;
			DFA3_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA3_transition[i] = DFA.UnpackEncodedString(DFA3_transitionS[i]);
			}
		}

		public DFA3( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 3;
			this.eot = DFA3_eot;
			this.eof = DFA3_eof;
			this.min = DFA3_min;
			this.max = DFA3_max;
			this.accept = DFA3_accept;
			this.special = DFA3_special;
			this.transition = DFA3_transition;
		}

		public override string Description { get { return "127:2: ( as2IncludeDirective | ( modifiers CLASS )=> as2ClassDefinition | ( modifiers INTERFACE )=> as2InterfaceDefinition )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition3(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA3_1 = input.LA(1);
		int index3_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA3_1==INCLUDE_DIRECTIVE)) {s = 1;}

				else if ((LA3_1==IDENT)) {s = 2;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 3;}

				else if ((LA3_1==STATIC)) {s = 4;}

				else if ((LA3_1==246)) {s = 5;}

				else if ((LA3_1==244)) {s = 6;}

				else if ((LA3_1==245)) {s = 7;}

				else if ((LA3_1==252)) {s = 8;}

				else if ((LA3_1==DYNAMIC)) {s = 9;}

				else if ((LA3_1==250)) {s = 10;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 5:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 6:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 7:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 8:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 9:
			{
				input.Rewind();
				if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 10:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 11:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 12:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 13:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 14:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 15:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 16:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 17:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}
		case 18:
			{
				input.Rewind();
				if ((LA3_1==CLASS) && (EvaluatePredicate(synpred1_AS3_fragment))) {s = 11;}

				else if ((LA3_1==IDENT)) {s = 13;}

				else if ((LA3_1==INTERNAL||LA3_1==PRIVATE||(LA3_1>=PROTECTED && LA3_1<=PUBLIC))) {s = 14;}

				else if ((LA3_1==STATIC)) {s = 15;}

				else if ((LA3_1==246)) {s = 16;}

				else if ((LA3_1==244)) {s = 17;}

				else if ((LA3_1==245)) {s = 18;}

				else if ((LA3_1==252)) {s = 19;}

				else if ((LA3_1==DYNAMIC)) {s = 20;}

				else if ((LA3_1==250)) {s = 21;}

				else if ((LA3_1==INTERFACE) && (EvaluatePredicate(synpred2_AS3_fragment))) {s = 12;}

				input.Seek(index3_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 3, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA7 : DFA
	{
		private const string DFA7_eotS =
			"\x14A\xFFFF";
		private const string DFA7_eofS =
			"\x14A\xFFFF";
		private const string DFA7_minS =
			"\x1\xF\x2\xFFFF\x3\xF\x6\x22\x1\xF\x1\x22\x1\xF\x2\xFFFF\x2\xF\x3E\xFFFF"+
			"\xA\x0\x1B\xFFFF\x9\x0\x1A\xFFFF\x9\x0\x6\xFFFF\x9\x0\x5\xFFFF\x9\x0"+
			"\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x19\xFFFF"+
			"\x9\x0\x26\xFFFF\xA\x0\x1\xFFFF";
		private const string DFA7_maxS =
			"\x1\x101\x2\xFFFF\x1\xFB\x1\x101\x9\xFC\x1\xFB\x2\xFFFF\x2\xE7\x3E\xFFFF"+
			"\xA\x0\x1B\xFFFF\x9\x0\x1A\xFFFF\x9\x0\x6\xFFFF\x9\x0\x5\xFFFF\x9\x0"+
			"\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x5\xFFFF\x9\x0\x19\xFFFF"+
			"\x9\x0\x26\xFFFF\xA\x0\x1\xFFFF";
		private const string DFA7_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\xC\xFFFF\x1\x6\x1\x7\x2\xFFFF\x1\xA\x28\xFFFF\x1"+
			"\x3\x42\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1E\xFFFF\x1\x5\x1\x6\x1"+
			"\x7\x1\x8\x1\x9\xA\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5"+
			"\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF"+
			"\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1D\xFFFF\x1\x5\x1\x6\x1\x7\x1"+
			"\x8\x1\x9\x2\x5\x14\xFFFF\xA\x8\xB\xFFFF\x1\x4";
		private const string DFA7_specialS =
			"\x1\x0\x4\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9"+
			"\x1\xA\x2\xFFFF\x1\xB\x3F\xFFFF\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11"+
			"\x1\x12\x1\x13\x1\x14\x1\x15\x1B\xFFFF\x1\x16\x1\x17\x1\x18\x1\x19\x1"+
			"\x1A\x1\x1B\x1\x1C\x1\x1D\x1\x1E\x1A\xFFFF\x1\x1F\x1\x20\x1\x21\x1\x22"+
			"\x1\x23\x1\x24\x1\x25\x1\x26\x1\x27\x6\xFFFF\x1\x28\x1\x29\x1\x2A\x1"+
			"\x2B\x1\x2C\x1\x2D\x1\x2E\x1\x2F\x1\x30\x5\xFFFF\x1\x31\x1\x32\x1\x33"+
			"\x1\x34\x1\x35\x1\x36\x1\x37\x1\x38\x1\x39\x5\xFFFF\x1\x3A\x1\x3B\x1"+
			"\x3C\x1\x3D\x1\x3E\x1\x3F\x1\x40\x1\x41\x1\x42\x5\xFFFF\x1\x43\x1\x44"+
			"\x1\x45\x1\x46\x1\x47\x1\x48\x1\x49\x1\x4A\x1\x4B\x5\xFFFF\x1\x4C\x1"+
			"\x4D\x1\x4E\x1\x4F\x1\x50\x1\x51\x1\x52\x1\x53\x1\x54\x5\xFFFF\x1\x55"+
			"\x1\x56\x1\x57\x1\x58\x1\x59\x1\x5A\x1\x5B\x1\x5C\x1\x5D\x19\xFFFF\x1"+
			"\x5E\x1\x5F\x1\x60\x1\x61\x1\x62\x1\x63\x1\x64\x1\x65\x1\x66\x26\xFFFF"+
			"\x1\x67\x1\x68\x1\x69\x1\x6A\x1\x6B\x1\x6C\x1\x6D\x1\x6E\x1\x6F\x1\x70"+
			"\x1\xFFFF}>";
		private static readonly string[] DFA7_transitionS =
			{
				"\x1\x13\x5\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\xF\x7\xFFFF\x1\x12"+
				"\x1\xFFFF\x1\x13\x3\xFFFF\x2\x13\x2\xFFFF\x1\x13\x3\xFFFF\x1\x13\x3"+
				"\xFFFF\x1\xC\x1\x13\x11\xFFFF\x3\x13\x8\xFFFF\x1\x11\x3\xFFFF\x1\x13"+
				"\x2\xFFFF\x1\x13\x1\x5\x2\xFFFF\x1\x13\x3\xFFFF\x1\x1\x2\xFFFF\x1\x13"+
				"\x1\xFFFF\x1\x10\x1\xFFFF\x1\x6\x1\x13\x2\xFFFF\x1\x4\x1\x13\x7\xFFFF"+
				"\x1\x13\x2\xFFFF\x1\x13\x7\xFFFF\x1\x13\x7\xFFFF\x1\xE\x2\xFFFF\x1\x13"+
				"\x4\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\x13\x6\xFFFF\x1\x6\x2\xFFFF"+
				"\x2\x6\x6\xFFFF\x1\x13\x2\xFFFF\x1\x13\x2\xFFFF\x2\x13\x9\xFFFF\x1\x7"+
				"\x2\xFFFF\x4\x13\x5\xFFFF\x1\x13\x6\xFFFF\x1\x3\x1\x12\x6\xFFFF\x1\x13"+
				"\x1\xFFFF\x1\x13\x1\xFFFF\x1\x13\x5\xFFFF\x1\x13\x5\xFFFF\x1\x13\x1"+
				"\x9\x1\xA\x1\x8\x1\xFFFF\x1\x2\x1\xFFFF\x1\xD\x1\xFFFF\x1\xB\x5\x13",
				"",
				"",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x7\xFFFF\x1"+
				"\x13\x8\xFFFF\x1\x13\x5\xFFFF\x2\x13\x1\xFFFF\x1\x13\x4\xFFFF\x1\x13"+
				"\x7\xFFFF\x1\x13\x16\xFFFF\x1\x13\x1\xFFFF\x1\x13\xC\xFFFF\x1\x13\x4"+
				"\xFFFF\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF"+
				"\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1\x3C\x6\xFFFF\x1\x13\xD\xFFFF\x2"+
				"\x13\xB\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13"+
				"\x3\xFFFF\x2\x13\x26\xFFFF\x1\x13\x7\xFFFF\x1\x13\x1\xFFFF\x1\x13",
				"\x1\x57\x5\xFFFF\x1\x13\x11\xFFFF\x1\x13\x8\xFFFF\x2\x13\xA\xFFFF\x1"+
				"\x54\x1\x13\x11\xFFFF\x2\x13\x9\xFFFF\x1\x13\x3\xFFFF\x1\x58\x2\xFFFF"+
				"\x1\x13\x1\x51\x9\xFFFF\x1\x13\x3\xFFFF\x1\x13\x1\x56\x2\xFFFF\x2\x13"+
				"\x7\xFFFF\x1\x13\x2\xFFFF\x1\x13\x7\xFFFF\x1\x13\x7\xFFFF\x1\x55\x2"+
				"\xFFFF\x1\x13\x4\xFFFF\x1\x13\x3\xFFFF\x1\x13\x8\xFFFF\x1\x13\x6\xFFFF"+
				"\x1\x13\x2\xFFFF\x2\x13\x2\xFFFF\x1\x13\x3\xFFFF\x1\x13\x6\xFFFF\x1"+
				"\x59\xC\xFFFF\x2\x13\x1\x5A\x6\xFFFF\x1\x13\x6\xFFFF\x1\x52\xB\xFFFF"+
				"\x1\x53\x5\xFFFF\x1\x13\x5\xFFFF\x1\x13\xB\xFFFF\x3\x13",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x2\xFFFF\x1"+
				"\x80\x4\xFFFF\x1\x13\x2\xFFFF\x1\x83\x4\xFFFF\x2\x13\x5\xFFFF\x2\x13"+
				"\x1\xFFFF\x1\x13\x2\xFFFF\x1\x7D\x1\xFFFF\x1\x13\x7\xFFFF\x1\x13\x13"+
				"\xFFFF\x1\x82\x2\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x76\x9\xFFFF"+
				"\x1\x13\x1\xFFFF\x1\x81\x1\xFFFF\x1\x77\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF"+
				"\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1"+
				"\x7F\x6\xFFFF\x1\x13\xD\xFFFF\x2\x13\x5\xFFFF\x1\x77\x2\xFFFF\x2\x77"+
				"\x1\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x2"+
				"\xFFFF\x1\x78\x2\x13\x11\xFFFF\x1\x83\x14\xFFFF\x1\x13\x2\xFFFF\x1\x7A"+
				"\x1\x7B\x1\x79\x2\xFFFF\x1\x13\x1\x7E\x1\x13\x1\x7C",
				"\x1\xA3\x7\xFFFF\x1\xA6\x4\xFFFF\x1\x13\xC\xFFFF\x1\xA0\x1D\xFFFF\x1"+
				"\xA5\x7\xFFFF\x1\x99\xB\xFFFF\x1\xA4\x1\xFFFF\x1\x9A\x1F\xFFFF\x1\xA2"+
				"\x1B\xFFFF\x1\x9A\x2\xFFFF\x2\x9A\x17\xFFFF\x1\x9B\x13\xFFFF\x1\xA6"+
				"\x17\xFFFF\x1\x9D\x1\x9E\x1\x9C\x3\xFFFF\x1\xA1\x1\xFFFF\x1\x9F",
				"\x1\xB2\x7\xFFFF\x1\xB5\x11\xFFFF\x1\xAF\x1D\xFFFF\x1\xB4\x7\xFFFF\x1"+
				"\xA8\xB\xFFFF\x1\xB3\x1\xFFFF\x1\xA9\x1F\xFFFF\x1\xB1\x1B\xFFFF\x1\xA9"+
				"\x2\xFFFF\x2\xA9\x17\xFFFF\x1\xAA\x13\xFFFF\x1\xB5\x17\xFFFF\x1\xAC"+
				"\x1\xAD\x1\xAB\x3\xFFFF\x1\xB0\x1\xFFFF\x1\xAE",
				"\x1\xC0\x7\xFFFF\x1\xC3\x11\xFFFF\x1\xBD\x1D\xFFFF\x1\xC2\x7\xFFFF\x1"+
				"\xB6\xB\xFFFF\x1\xC1\x1\xFFFF\x1\xB7\x1F\xFFFF\x1\xBF\x1B\xFFFF\x1\xB7"+
				"\x2\xFFFF\x2\xB7\x17\xFFFF\x1\xB8\x13\xFFFF\x1\xC3\x17\xFFFF\x1\xBA"+
				"\x1\xBB\x1\xB9\x3\xFFFF\x1\xBE\x1\xFFFF\x1\xBC",
				"\x1\xCE\x7\xFFFF\x1\xD1\x11\xFFFF\x1\xCB\x1D\xFFFF\x1\xD0\x7\xFFFF\x1"+
				"\xC4\xB\xFFFF\x1\xCF\x1\xFFFF\x1\xC5\x1F\xFFFF\x1\xCD\x1B\xFFFF\x1\xC5"+
				"\x2\xFFFF\x2\xC5\x17\xFFFF\x1\xC6\x13\xFFFF\x1\xD1\x17\xFFFF\x1\xC8"+
				"\x1\xC9\x1\xC7\x3\xFFFF\x1\xCC\x1\xFFFF\x1\xCA",
				"\x1\xDC\x7\xFFFF\x1\xDF\x11\xFFFF\x1\xD9\x1D\xFFFF\x1\xDE\x7\xFFFF\x1"+
				"\xD2\xB\xFFFF\x1\xDD\x1\xFFFF\x1\xD3\x1F\xFFFF\x1\xDB\x1B\xFFFF\x1\xD3"+
				"\x2\xFFFF\x2\xD3\x17\xFFFF\x1\xD4\x13\xFFFF\x1\xDF\x17\xFFFF\x1\xD6"+
				"\x1\xD7\x1\xD5\x3\xFFFF\x1\xDA\x1\xFFFF\x1\xD8",
				"\x1\xEA\x7\xFFFF\x1\xED\x11\xFFFF\x1\xE7\x1D\xFFFF\x1\xEC\x7\xFFFF\x1"+
				"\xE0\xB\xFFFF\x1\xEB\x1\xFFFF\x1\xE1\x1F\xFFFF\x1\xE9\x1B\xFFFF\x1\xE1"+
				"\x2\xFFFF\x2\xE1\x17\xFFFF\x1\xE2\x13\xFFFF\x1\xED\x17\xFFFF\x1\xE4"+
				"\x1\xE5\x1\xE3\x3\xFFFF\x1\xE8\x1\xFFFF\x1\xE6",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x2\xFFFF\x1"+
				"\xF8\x4\xFFFF\x1\x13\x2\xFFFF\x1\xFB\x5\xFFFF\x1\x13\x5\xFFFF\x2\x13"+
				"\x1\xFFFF\x1\x13\x2\xFFFF\x1\xF5\x1\xFFFF\x1\x13\x7\xFFFF\x1\x13\x13"+
				"\xFFFF\x1\xFA\x2\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\xEE\x9\xFFFF"+
				"\x1\x13\x1\xFFFF\x1\xF9\x1\xFFFF\x1\xEF\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF"+
				"\x4\x13\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x1\xFFFF\x1"+
				"\xF7\x6\xFFFF\x1\x13\xD\xFFFF\x2\x13\x5\xFFFF\x1\xEF\x2\xFFFF\x2\xEF"+
				"\x1\xFFFF\x1\x13\xA\xFFFF\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x2"+
				"\xFFFF\x1\xF0\x2\x13\x11\xFFFF\x1\xFB\x14\xFFFF\x1\x13\x2\xFFFF\x1\xF2"+
				"\x1\xF3\x1\xF1\x2\xFFFF\x1\x13\x1\xF6\x1\x13\x1\xF4",
				"\x1\x11A\x7\xFFFF\x1\x11D\x11\xFFFF\x1\x117\x1D\xFFFF\x1\x11C\x7\xFFFF"+
				"\x1\x110\xB\xFFFF\x1\x11B\x1\xFFFF\x1\x111\x1F\xFFFF\x1\x119\x1B\xFFFF"+
				"\x1\x111\x2\xFFFF\x2\x111\x17\xFFFF\x1\x112\x13\xFFFF\x1\x11D\x17\xFFFF"+
				"\x1\x114\x1\x115\x1\x113\x3\xFFFF\x1\x118\x1\xFFFF\x1\x116",
				"\x2\x13\x1\xFFFF\x2\x13\x3\xFFFF\x2\x13\x3\xFFFF\x4\x13\x7\xFFFF\x1"+
				"\x13\x8\xFFFF\x1\x13\x5\xFFFF\x2\x13\x1\xFFFF\x1\x13\x4\xFFFF\x1\x13"+
				"\x7\xFFFF\x1\x13\x16\xFFFF\x1\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x11E\x9"+
				"\xFFFF\x1\x13\x3\xFFFF\x1\x11F\x4\x13\x1\xFFFF\x1\x13\x7\xFFFF\x4\x13"+
				"\x6\xFFFF\x2\x13\x1\xFFFF\x1\x13\x2\xFFFF\x1\x13\x8\xFFFF\x1\x13\xD"+
				"\xFFFF\x2\x13\x5\xFFFF\x1\x11F\x2\xFFFF\x2\x11F\x1\xFFFF\x1\x13\xA\xFFFF"+
				"\x1\x13\x1\xFFFF\x2\x13\x1\xFFFF\x4\x13\x3\xFFFF\x2\x13\x26\xFFFF\x1"+
				"\x13\x7\xFFFF\x1\x13\x1\xFFFF\x1\x13",
				"",
				"",
				"\x1\x13B\x2C\xFFFF\x1\x138\x21\xFFFF\x1\x134\x3\xFFFF\x1\x135\xE\xFFFF"+
				"\x1\x13A\xE\xFFFF\x1\x13\xF\xFFFF\x1\x139\x2D\xFFFF\x1\x13C\xE\xFFFF"+
				"\x1\x13D\xD\xFFFF\x1\x136\xB\xFFFF\x1\x137",
				"\x1\x145\x2C\xFFFF\x1\x142\x21\xFFFF\x1\x146\x3\xFFFF\x1\x13F\xE\xFFFF"+
				"\x1\x144\x1E\xFFFF\x1\x143\x2D\xFFFF\x1\x147\xE\xFFFF\x1\x148\xD\xFFFF"+
				"\x1\x140\xB\xFFFF\x1\x141",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				""
			};

		private static readonly short[] DFA7_eot = DFA.UnpackEncodedString(DFA7_eotS);
		private static readonly short[] DFA7_eof = DFA.UnpackEncodedString(DFA7_eofS);
		private static readonly char[] DFA7_min = DFA.UnpackEncodedStringToUnsignedChars(DFA7_minS);
		private static readonly char[] DFA7_max = DFA.UnpackEncodedStringToUnsignedChars(DFA7_maxS);
		private static readonly short[] DFA7_accept = DFA.UnpackEncodedString(DFA7_acceptS);
		private static readonly short[] DFA7_special = DFA.UnpackEncodedString(DFA7_specialS);
		private static readonly short[][] DFA7_transition;

		static DFA7()
		{
			int numStates = DFA7_transitionS.Length;
			DFA7_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA7_transition[i] = DFA.UnpackEncodedString(DFA7_transitionS[i]);
			}
		}

		public DFA7( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 7;
			this.eot = DFA7_eot;
			this.eof = DFA7_eof;
			this.min = DFA7_min;
			this.max = DFA7_max;
			this.accept = DFA7_accept;
			this.special = DFA7_special;
			this.transition = DFA7_transition;
		}

		public override string Description { get { return "147:2: packageBlockEntry options {k=2; } : ( importDefinition | includeDirective | useNamespaceDirective | ( LBRACK IDENT )=> annotation | ( modifiers NAMESPACE )=> namespaceDefinition | ( modifiers CLASS )=> classDefinition | ( modifiers INTERFACE )=> interfaceDefinition | ( modifiers FUNCTION )=> methodDefinition | ( modifiers varOrConst )=> variableDefinition | statement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition7(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA7_1 = input.LA(1);
		int index7_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA7_1==IMPORT)) {s = 1;}

				else if ((LA7_1==248)) {s = 2;}

				else if ((LA7_1==USE)) {s = 3;}

				else if ((LA7_1==LBRACK)) {s = 4;}

				else if ((LA7_1==IDENT)) {s = 5;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 6;}

				else if ((LA7_1==STATIC)) {s = 7;}

				else if ((LA7_1==246)) {s = 8;}

				else if ((LA7_1==244)) {s = 9;}

				else if ((LA7_1==245)) {s = 10;}

				else if ((LA7_1==252)) {s = 11;}

				else if ((LA7_1==DYNAMIC)) {s = 12;}

				else if ((LA7_1==250)) {s = 13;}

				else if ((LA7_1==NAMESPACE)) {s = 14;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 15;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 16;}

				else if ((LA7_1==FUNCTION)) {s = 17;}

				else if ((LA7_1==CONST||LA7_1==VAR)) {s = 18;}

				else if ((LA7_1==AS||LA7_1==BNOT||LA7_1==BREAK||LA7_1==CONTINUE||(LA7_1>=DEC && LA7_1<=DECIMAL_LITERAL)||LA7_1==DEFAULT||LA7_1==DO||LA7_1==E4X_ATTRI||(LA7_1>=FALSE && LA7_1<=FOR)||LA7_1==GET||LA7_1==HEX_LITERAL||LA7_1==IF||LA7_1==INC||LA7_1==IS||LA7_1==LCURLY||LA7_1==LNOT||LA7_1==LPAREN||LA7_1==MINUS||LA7_1==NEW||LA7_1==NULL||LA7_1==OCTAL_LITERAL||LA7_1==PLUS||LA7_1==REGEX_LITERAL||LA7_1==RETURN||(LA7_1>=SEMI && LA7_1<=SET)||(LA7_1>=STRING_LITERAL_DOUBLE && LA7_1<=SWITCH)||LA7_1==TRUE||LA7_1==WHILE||LA7_1==WITH||LA7_1==XML||LA7_1==XML_LITERAL||LA7_1==243||(LA7_1>=253 && LA7_1<=257))) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 118;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 119;}

				else if ((LA7_1==STATIC)) {s = 120;}

				else if ((LA7_1==246)) {s = 121;}

				else if ((LA7_1==244)) {s = 122;}

				else if ((LA7_1==245)) {s = 123;}

				else if ((LA7_1==252)) {s = 124;}

				else if ((LA7_1==DYNAMIC)) {s = 125;}

				else if ((LA7_1==250)) {s = 126;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 127;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 128;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 129;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 130;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 131;}

				else if (((LA7_1>=AS && LA7_1<=ASSIGN)||(LA7_1>=BAND && LA7_1<=BAND_ASSIGN)||(LA7_1>=BOR && LA7_1<=BOR_ASSIGN)||(LA7_1>=BSR && LA7_1<=BXOR_ASSIGN)||LA7_1==COMMA||(LA7_1>=DBL_COLON && LA7_1<=DEC)||(LA7_1>=DIV && LA7_1<=DIV_ASSIGN)||LA7_1==DOT||LA7_1==E4X_DESC||LA7_1==EQUAL||LA7_1==GE||LA7_1==GT||LA7_1==INC||(LA7_1>=IS && LA7_1<=LBRACK)||LA7_1==LE||(LA7_1>=LOR && LA7_1<=LT)||(LA7_1>=MINUS && LA7_1<=MINUS_ASSIGN)||LA7_1==MOD||LA7_1==MOD_ASSIGN||LA7_1==NOT_EQUAL||(LA7_1>=PLUS && LA7_1<=PLUS_ASSIGN)||LA7_1==QUESTION||LA7_1==SEMI||(LA7_1>=SL && LA7_1<=SL_ASSIGN)||(LA7_1>=SR && LA7_1<=STAR_ASSIGN)||(LA7_1>=STRICT_EQUAL && LA7_1<=STRICT_NOT_EQUAL)||LA7_1==241||LA7_1==249||LA7_1==251)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 153;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 154;}

				else if ((LA7_1==STATIC)) {s = 155;}

				else if ((LA7_1==246)) {s = 156;}

				else if ((LA7_1==244)) {s = 157;}

				else if ((LA7_1==245)) {s = 158;}

				else if ((LA7_1==252)) {s = 159;}

				else if ((LA7_1==DYNAMIC)) {s = 160;}

				else if ((LA7_1==250)) {s = 161;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 162;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 163;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 164;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 165;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 166;}

				else if ((LA7_1==DBL_COLON)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 168;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 169;}

				else if ((LA7_1==STATIC)) {s = 170;}

				else if ((LA7_1==246)) {s = 171;}

				else if ((LA7_1==244)) {s = 172;}

				else if ((LA7_1==245)) {s = 173;}

				else if ((LA7_1==252)) {s = 174;}

				else if ((LA7_1==DYNAMIC)) {s = 175;}

				else if ((LA7_1==250)) {s = 176;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 177;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 178;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 179;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 180;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 181;}

				input.Seek(index7_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 182;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 183;}

				else if ((LA7_1==STATIC)) {s = 184;}

				else if ((LA7_1==246)) {s = 185;}

				else if ((LA7_1==244)) {s = 186;}

				else if ((LA7_1==245)) {s = 187;}

				else if ((LA7_1==252)) {s = 188;}

				else if ((LA7_1==DYNAMIC)) {s = 189;}

				else if ((LA7_1==250)) {s = 190;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 191;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 192;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 193;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 194;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 195;}

				input.Seek(index7_1);
				break;
			}
		case 5:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 196;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 197;}

				else if ((LA7_1==STATIC)) {s = 198;}

				else if ((LA7_1==246)) {s = 199;}

				else if ((LA7_1==244)) {s = 200;}

				else if ((LA7_1==245)) {s = 201;}

				else if ((LA7_1==252)) {s = 202;}

				else if ((LA7_1==DYNAMIC)) {s = 203;}

				else if ((LA7_1==250)) {s = 204;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 205;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 206;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 207;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 208;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 209;}

				input.Seek(index7_1);
				break;
			}
		case 6:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 210;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 211;}

				else if ((LA7_1==STATIC)) {s = 212;}

				else if ((LA7_1==246)) {s = 213;}

				else if ((LA7_1==244)) {s = 214;}

				else if ((LA7_1==245)) {s = 215;}

				else if ((LA7_1==252)) {s = 216;}

				else if ((LA7_1==DYNAMIC)) {s = 217;}

				else if ((LA7_1==250)) {s = 218;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 219;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 220;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 221;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 222;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 223;}

				input.Seek(index7_1);
				break;
			}
		case 7:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 224;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 225;}

				else if ((LA7_1==STATIC)) {s = 226;}

				else if ((LA7_1==246)) {s = 227;}

				else if ((LA7_1==244)) {s = 228;}

				else if ((LA7_1==245)) {s = 229;}

				else if ((LA7_1==252)) {s = 230;}

				else if ((LA7_1==DYNAMIC)) {s = 231;}

				else if ((LA7_1==250)) {s = 232;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 233;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 234;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 235;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 236;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 237;}

				input.Seek(index7_1);
				break;
			}
		case 8:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 238;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 239;}

				else if ((LA7_1==STATIC)) {s = 240;}

				else if ((LA7_1==246)) {s = 241;}

				else if ((LA7_1==244)) {s = 242;}

				else if ((LA7_1==245)) {s = 243;}

				else if ((LA7_1==252)) {s = 244;}

				else if ((LA7_1==DYNAMIC)) {s = 245;}

				else if ((LA7_1==250)) {s = 246;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 247;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 248;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 249;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 250;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 251;}

				else if (((LA7_1>=AS && LA7_1<=ASSIGN)||(LA7_1>=BAND && LA7_1<=BAND_ASSIGN)||(LA7_1>=BOR && LA7_1<=BOR_ASSIGN)||(LA7_1>=BSR && LA7_1<=BXOR_ASSIGN)||LA7_1==COMMA||LA7_1==DEC||(LA7_1>=DIV && LA7_1<=DIV_ASSIGN)||LA7_1==DOT||LA7_1==E4X_DESC||LA7_1==EQUAL||LA7_1==GE||LA7_1==GT||LA7_1==INC||(LA7_1>=IS && LA7_1<=LBRACK)||LA7_1==LE||(LA7_1>=LOR && LA7_1<=LT)||(LA7_1>=MINUS && LA7_1<=MINUS_ASSIGN)||LA7_1==MOD||LA7_1==MOD_ASSIGN||LA7_1==NOT_EQUAL||(LA7_1>=PLUS && LA7_1<=PLUS_ASSIGN)||LA7_1==QUESTION||LA7_1==SEMI||(LA7_1>=SL && LA7_1<=SL_ASSIGN)||(LA7_1>=SR && LA7_1<=STAR_ASSIGN)||(LA7_1>=STRICT_EQUAL && LA7_1<=STRICT_NOT_EQUAL)||LA7_1==241||LA7_1==249||LA7_1==251)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 9:
			{
				input.Rewind();
				if ((LA7_1==IDENT)) {s = 272;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC))) {s = 273;}

				else if ((LA7_1==STATIC)) {s = 274;}

				else if ((LA7_1==246)) {s = 275;}

				else if ((LA7_1==244)) {s = 276;}

				else if ((LA7_1==245)) {s = 277;}

				else if ((LA7_1==252)) {s = 278;}

				else if ((LA7_1==DYNAMIC)) {s = 279;}

				else if ((LA7_1==250)) {s = 280;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 281;}

				else if ((LA7_1==CLASS) && (EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((LA7_1==INTERFACE) && (EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((LA7_1==FUNCTION) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 284;}

				else if ((LA7_1==CONST||LA7_1==VAR) && (EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 10:
			{
				input.Rewind();
				if ((LA7_1==IDENT) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 286;}

				else if ((LA7_1==INTERNAL||LA7_1==PRIVATE||(LA7_1>=PROTECTED && LA7_1<=PUBLIC)) && (EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if (((LA7_1>=AS && LA7_1<=ASSIGN)||(LA7_1>=BAND && LA7_1<=BAND_ASSIGN)||(LA7_1>=BOR && LA7_1<=BOR_ASSIGN)||(LA7_1>=BSR && LA7_1<=BXOR_ASSIGN)||LA7_1==COMMA||LA7_1==DEC||(LA7_1>=DIV && LA7_1<=DIV_ASSIGN)||LA7_1==DOT||LA7_1==E4X_DESC||LA7_1==EQUAL||LA7_1==GE||LA7_1==GT||LA7_1==INC||(LA7_1>=IS && LA7_1<=LBRACK)||LA7_1==LE||(LA7_1>=LOR && LA7_1<=LT)||(LA7_1>=MINUS && LA7_1<=MINUS_ASSIGN)||LA7_1==MOD||LA7_1==MOD_ASSIGN||LA7_1==NOT_EQUAL||(LA7_1>=PLUS && LA7_1<=PLUS_ASSIGN)||LA7_1==QUESTION||LA7_1==SEMI||(LA7_1>=SL && LA7_1<=SL_ASSIGN)||(LA7_1>=SR && LA7_1<=STAR_ASSIGN)||(LA7_1>=STRICT_EQUAL && LA7_1<=STRICT_NOT_EQUAL)||LA7_1==241||LA7_1==249||LA7_1==251)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 11:
			{
				input.Rewind();
				if ((LA7_1==GET) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 308;}

				else if ((LA7_1==IDENT) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 309;}

				else if ((LA7_1==USE) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 310;}

				else if ((LA7_1==XML) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 311;}

				else if ((LA7_1==DYNAMIC) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 312;}

				else if ((LA7_1==NAMESPACE) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 313;}

				else if ((LA7_1==IS) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 314;}

				else if ((LA7_1==AS) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 315;}

				else if ((LA7_1==SET) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 316;}

				else if ((LA7_1==SUPER) && (EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((LA7_1==LPAREN)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 12:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 13:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 14:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 15:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 16:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 17:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 18:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 19:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 20:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 21:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred3_AS3_fragment))) {s = 329;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 22:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 23:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 24:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 25:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 26:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 27:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 28:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 29:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 30:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 31:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 32:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 33:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 34:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 35:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 36:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 37:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 38:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 39:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 40:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 41:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 42:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 43:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 44:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 45:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 46:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 47:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 48:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 49:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 50:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 51:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 52:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 53:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 54:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 55:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 56:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 57:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 58:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 59:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 60:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 61:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 62:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 63:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 64:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 65:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 66:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 67:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 68:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 69:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 70:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 71:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 72:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 73:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 74:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 75:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 76:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 77:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 78:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 79:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 80:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 81:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 82:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 83:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 84:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 85:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 86:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 87:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 88:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 89:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 90:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 91:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 92:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 93:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 94:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 95:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 96:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 97:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 98:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 99:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 100:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 101:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 102:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred4_AS3_fragment))) {s = 287;}

				else if ((EvaluatePredicate(synpred5_AS3_fragment))) {s = 282;}

				else if ((EvaluatePredicate(synpred6_AS3_fragment))) {s = 283;}

				else if ((EvaluatePredicate(synpred7_AS3_fragment))) {s = 317;}

				else if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				input.Seek(index7_1);
				break;
			}
		case 103:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 104:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 105:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 106:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 107:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 108:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 109:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 110:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 111:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}
		case 112:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred8_AS3_fragment))) {s = 285;}

				else if ((true)) {s = 19;}

				input.Seek(index7_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 7, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\x102\xFFFF";
		private const string DFA17_eofS =
			"\x102\xFFFF";
		private const string DFA17_minS =
			"\x1\xF\x2\xFFFF\x2\xF\x6\x2A\x1\xF\x1\x2A\x2\xF\x2B\xFFFF\xA\x0\x1B\xFFFF"+
			"\x9\x0\x17\xFFFF\x9\x0\x3\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2"+
			"\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x16\xFFFF\x9\x0\x2\xFFFF\xA"+
			"\x0\xC\xFFFF";
		private const string DFA17_maxS =
			"\x1\x101\x2\xFFFF\x1\x101\x9\xFC\x2\xE7\x2B\xFFFF\xA\x0\x1B\xFFFF\x9"+
			"\x0\x17\xFFFF\x9\x0\x3\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF"+
			"\x9\x0\x2\xFFFF\x9\x0\x2\xFFFF\x9\x0\x16\xFFFF\x9\x0\x2\xFFFF\xA\x0\xC"+
			"\xFFFF";
		private const string DFA17_acceptS =
			"\x1\xFFFF\x1\x1\x1\x2\xC\xFFFF\x1\x6\x58\xFFFF\x1\x4\x1\x5\x1E\xFFFF"+
			"\x1\x4\x1\x5\xA\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4"+
			"\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5\x9\xFFFF\x1\x4\x1\x5"+
			"\x1D\xFFFF\x1\x4\x1\x5\xA\xFFFF\xA\x5\x1\xFFFF\x1\x3";
		private const string DFA17_specialS =
			"\x4\xFFFF\x1\x0\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\xFFFF"+
			"\x1\x9\x2B\xFFFF\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1"+
			"\x12\x1\x13\x1B\xFFFF\x1\x14\x1\x15\x1\x16\x1\x17\x1\x18\x1\x19\x1\x1A"+
			"\x1\x1B\x1\x1C\x17\xFFFF\x1\x1D\x1\x1E\x1\x1F\x1\x20\x1\x21\x1\x22\x1"+
			"\x23\x1\x24\x1\x25\x3\xFFFF\x1\x26\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B"+
			"\x1\x2C\x1\x2D\x1\x2E\x2\xFFFF\x1\x2F\x1\x30\x1\x31\x1\x32\x1\x33\x1"+
			"\x34\x1\x35\x1\x36\x1\x37\x2\xFFFF\x1\x38\x1\x39\x1\x3A\x1\x3B\x1\x3C"+
			"\x1\x3D\x1\x3E\x1\x3F\x1\x40\x2\xFFFF\x1\x41\x1\x42\x1\x43\x1\x44\x1"+
			"\x45\x1\x46\x1\x47\x1\x48\x1\x49\x2\xFFFF\x1\x4A\x1\x4B\x1\x4C\x1\x4D"+
			"\x1\x4E\x1\x4F\x1\x50\x1\x51\x1\x52\x2\xFFFF\x1\x53\x1\x54\x1\x55\x1"+
			"\x56\x1\x57\x1\x58\x1\x59\x1\x5A\x1\x5B\x16\xFFFF\x1\x5C\x1\x5D\x1\x5E"+
			"\x1\x5F\x1\x60\x1\x61\x1\x62\x1\x63\x1\x64\x2\xFFFF\x1\x65\x1\x66\x1"+
			"\x67\x1\x68\x1\x69\x1\x6A\x1\x6B\x1\x6C\x1\x6D\x1\x6E\xC\xFFFF}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\x1\xF\x5\xFFFF\x1\xF\x3\xFFFF\x1\xF\x10\xFFFF\x1\xD\x1\xFFFF\x1\xF"+
				"\x3\xFFFF\x2\xF\x2\xFFFF\x1\xF\x3\xFFFF\x1\xF\x3\xFFFF\x1\xB\x1\xF\x11"+
				"\xFFFF\x3\xF\x8\xFFFF\x1\xE\x3\xFFFF\x1\xF\x2\xFFFF\x1\xF\x1\x4\x2\xFFFF"+
				"\x1\xF\x3\xFFFF\x1\x2\x2\xFFFF\x1\xF\x3\xFFFF\x1\x5\x1\xF\x2\xFFFF\x1"+
				"\x3\x1\xF\x7\xFFFF\x1\xF\x2\xFFFF\x1\xF\x7\xFFFF\x1\xF\x7\xFFFF\x1\xF"+
				"\x2\xFFFF\x1\xF\x4\xFFFF\x1\xF\x3\xFFFF\x1\xF\x8\xFFFF\x1\xF\x6\xFFFF"+
				"\x1\x5\x2\xFFFF\x2\x5\x6\xFFFF\x1\xF\x2\xFFFF\x1\xF\x2\xFFFF\x2\xF\x9"+
				"\xFFFF\x1\x6\x2\xFFFF\x4\xF\x5\xFFFF\x1\xF\x6\xFFFF\x1\xF\x1\xD\x6\xFFFF"+
				"\x1\xF\x1\xFFFF\x1\xF\x1\xFFFF\x1\xF\x5\xFFFF\x1\xF\x5\xFFFF\x1\xF\x1"+
				"\x8\x1\x9\x1\x7\x1\xFFFF\x1\x1\x1\xFFFF\x1\xC\x1\xFFFF\x1\xA\x5\xF",
				"",
				"",
				"\x1\x40\x5\xFFFF\x1\xF\x11\xFFFF\x1\xF\x8\xFFFF\x2\xF\xA\xFFFF\x1\x3D"+
				"\x1\xF\x11\xFFFF\x2\xF\x9\xFFFF\x1\xF\x3\xFFFF\x1\x41\x2\xFFFF\x1\xF"+
				"\x1\x3A\x9\xFFFF\x1\xF\x3\xFFFF\x1\xF\x1\x3F\x2\xFFFF\x2\xF\x7\xFFFF"+
				"\x1\xF\x2\xFFFF\x1\xF\x7\xFFFF\x1\xF\x7\xFFFF\x1\x3E\x2\xFFFF\x1\xF"+
				"\x4\xFFFF\x1\xF\x3\xFFFF\x1\xF\x8\xFFFF\x1\xF\x6\xFFFF\x1\xF\x2\xFFFF"+
				"\x2\xF\x2\xFFFF\x1\xF\x3\xFFFF\x1\xF\x6\xFFFF\x1\x42\xC\xFFFF\x2\xF"+
				"\x1\x43\x6\xFFFF\x1\xF\x6\xFFFF\x1\x3B\xB\xFFFF\x1\x3C\x5\xFFFF\x1\xF"+
				"\x5\xFFFF\x1\xF\xB\xFFFF\x3\xF",
				"\x2\xF\x1\xFFFF\x2\xF\x3\xFFFF\x2\xF\x3\xFFFF\x4\xF\x7\xFFFF\x1\xF\x2"+
				"\xFFFF\x1\x68\x4\xFFFF\x2\xF\x5\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\x66\x1\xFFFF\x1\xF\x7\xFFFF\x1\xF\x13\xFFFF\x1\x69\x2\xFFFF\x1\xF"+
				"\x1\xFFFF\x1\xF\x2\xFFFF\x1\x5F\x9\xFFFF\x1\xF\x3\xFFFF\x1\x60\x4\xF"+
				"\x1\xFFFF\x1\xF\x7\xFFFF\x4\xF\x6\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xF\x8\xFFFF\x1\xF\xD\xFFFF\x2\xF\x5\xFFFF\x1\x60\x2\xFFFF\x2\x60"+
				"\x1\xFFFF\x1\xF\xA\xFFFF\x1\xF\x1\xFFFF\x2\xF\x1\xFFFF\x4\xF\x2\xFFFF"+
				"\x1\x61\x2\xF\x11\xFFFF\x1\x68\x14\xFFFF\x1\xF\x2\xFFFF\x1\x63\x1\x64"+
				"\x1\x62\x2\xFFFF\x1\xF\x1\x67\x1\xF\x1\x65",
				"\x1\x88\x4\xFFFF\x1\xF\xC\xFFFF\x1\x86\x1D\xFFFF\x1\x89\x7\xFFFF\x1"+
				"\x7F\xD\xFFFF\x1\x80\x3B\xFFFF\x1\x80\x2\xFFFF\x2\x80\x17\xFFFF\x1\x81"+
				"\x13\xFFFF\x1\x88\x17\xFFFF\x1\x83\x1\x84\x1\x82\x3\xFFFF\x1\x87\x1"+
				"\xFFFF\x1\x85",
				"\x1\x94\x11\xFFFF\x1\x92\x1D\xFFFF\x1\x95\x7\xFFFF\x1\x8B\xD\xFFFF\x1"+
				"\x8C\x3B\xFFFF\x1\x8C\x2\xFFFF\x2\x8C\x17\xFFFF\x1\x8D\x13\xFFFF\x1"+
				"\x94\x17\xFFFF\x1\x8F\x1\x90\x1\x8E\x3\xFFFF\x1\x93\x1\xFFFF\x1\x91",
				"\x1\x9F\x11\xFFFF\x1\x9D\x1D\xFFFF\x1\xA0\x7\xFFFF\x1\x96\xD\xFFFF\x1"+
				"\x97\x3B\xFFFF\x1\x97\x2\xFFFF\x2\x97\x17\xFFFF\x1\x98\x13\xFFFF\x1"+
				"\x9F\x17\xFFFF\x1\x9A\x1\x9B\x1\x99\x3\xFFFF\x1\x9E\x1\xFFFF\x1\x9C",
				"\x1\xAA\x11\xFFFF\x1\xA8\x1D\xFFFF\x1\xAB\x7\xFFFF\x1\xA1\xD\xFFFF\x1"+
				"\xA2\x3B\xFFFF\x1\xA2\x2\xFFFF\x2\xA2\x17\xFFFF\x1\xA3\x13\xFFFF\x1"+
				"\xAA\x17\xFFFF\x1\xA5\x1\xA6\x1\xA4\x3\xFFFF\x1\xA9\x1\xFFFF\x1\xA7",
				"\x1\xB5\x11\xFFFF\x1\xB3\x1D\xFFFF\x1\xB6\x7\xFFFF\x1\xAC\xD\xFFFF\x1"+
				"\xAD\x3B\xFFFF\x1\xAD\x2\xFFFF\x2\xAD\x17\xFFFF\x1\xAE\x13\xFFFF\x1"+
				"\xB5\x17\xFFFF\x1\xB0\x1\xB1\x1\xAF\x3\xFFFF\x1\xB4\x1\xFFFF\x1\xB2",
				"\x1\xC0\x11\xFFFF\x1\xBE\x1D\xFFFF\x1\xC1\x7\xFFFF\x1\xB7\xD\xFFFF\x1"+
				"\xB8\x3B\xFFFF\x1\xB8\x2\xFFFF\x2\xB8\x17\xFFFF\x1\xB9\x13\xFFFF\x1"+
				"\xC0\x17\xFFFF\x1\xBB\x1\xBC\x1\xBA\x3\xFFFF\x1\xBF\x1\xFFFF\x1\xBD",
				"\x2\xF\x1\xFFFF\x2\xF\x3\xFFFF\x2\xF\x3\xFFFF\x4\xF\x7\xFFFF\x1\xF\x2"+
				"\xFFFF\x1\xCB\x5\xFFFF\x1\xF\x5\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xC9\x1\xFFFF\x1\xF\x7\xFFFF\x1\xF\x13\xFFFF\x1\xCC\x2\xFFFF\x1\xF"+
				"\x1\xFFFF\x1\xF\x2\xFFFF\x1\xC2\x9\xFFFF\x1\xF\x3\xFFFF\x1\xC3\x4\xF"+
				"\x1\xFFFF\x1\xF\x7\xFFFF\x4\xF\x6\xFFFF\x2\xF\x1\xFFFF\x1\xF\x2\xFFFF"+
				"\x1\xF\x8\xFFFF\x1\xF\xD\xFFFF\x2\xF\x5\xFFFF\x1\xC3\x2\xFFFF\x2\xC3"+
				"\x1\xFFFF\x1\xF\xA\xFFFF\x1\xF\x1\xFFFF\x2\xF\x1\xFFFF\x4\xF\x2\xFFFF"+
				"\x1\xC4\x2\xF\x11\xFFFF\x1\xCB\x14\xFFFF\x1\xF\x2\xFFFF\x1\xC6\x1\xC7"+
				"\x1\xC5\x2\xFFFF\x1\xF\x1\xCA\x1\xF\x1\xC8",
				"\x1\xEA\x11\xFFFF\x1\xE8\x1D\xFFFF\x1\xEB\x7\xFFFF\x1\xE1\xD\xFFFF\x1"+
				"\xE2\x3B\xFFFF\x1\xE2\x2\xFFFF\x2\xE2\x17\xFFFF\x1\xE3\x13\xFFFF\x1"+
				"\xEA\x17\xFFFF\x1\xE5\x1\xE6\x1\xE4\x3\xFFFF\x1\xE9\x1\xFFFF\x1\xE7",
				"\x1\xF2\x2C\xFFFF\x1\xEF\x21\xFFFF\x1\xF3\x3\xFFFF\x1\xEC\xE\xFFFF\x1"+
				"\xF1\x1E\xFFFF\x1\xF0\x2D\xFFFF\x1\xF4\xE\xFFFF\x1\xF5\xD\xFFFF\x1\xED"+
				"\xB\xFFFF\x1\xEE",
				"\x1\xFD\x2C\xFFFF\x1\xFA\x21\xFFFF\x1\xF6\x3\xFFFF\x1\xF7\xE\xFFFF\x1"+
				"\xFC\xE\xFFFF\x1\xF\xF\xFFFF\x1\xFB\x2D\xFFFF\x1\xFE\xE\xFFFF\x1\xFF"+
				"\xD\xFFFF\x1\xF8\xB\xFFFF\x1\xF9",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "232:1: typeBlockEntry options {k=2; } : ( includeDirective | importDefinition | ( LBRACK IDENT )=> annotation | ( modifiers varOrConst )=> variableDefinition -> ^( CLASS_MEMBER variableDefinition ) | ( modifiers FUNCTION )=> methodDefinition -> ^( CLASS_MEMBER methodDefinition ) | statement );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition17(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA17_1 = input.LA(1);
		int index17_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 95;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 96;}

				else if ((LA17_1==STATIC)) {s = 97;}

				else if ((LA17_1==246)) {s = 98;}

				else if ((LA17_1==244)) {s = 99;}

				else if ((LA17_1==245)) {s = 100;}

				else if ((LA17_1==252)) {s = 101;}

				else if ((LA17_1==DYNAMIC)) {s = 102;}

				else if ((LA17_1==250)) {s = 103;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 104;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 105;}

				else if (((LA17_1>=AS && LA17_1<=ASSIGN)||(LA17_1>=BAND && LA17_1<=BAND_ASSIGN)||(LA17_1>=BOR && LA17_1<=BOR_ASSIGN)||(LA17_1>=BSR && LA17_1<=BXOR_ASSIGN)||LA17_1==COMMA||(LA17_1>=DBL_COLON && LA17_1<=DEC)||(LA17_1>=DIV && LA17_1<=DIV_ASSIGN)||LA17_1==DOT||LA17_1==E4X_DESC||LA17_1==EQUAL||LA17_1==GE||LA17_1==GT||LA17_1==INC||(LA17_1>=IS && LA17_1<=LBRACK)||LA17_1==LE||(LA17_1>=LOR && LA17_1<=LT)||(LA17_1>=MINUS && LA17_1<=MINUS_ASSIGN)||LA17_1==MOD||LA17_1==MOD_ASSIGN||LA17_1==NOT_EQUAL||(LA17_1>=PLUS && LA17_1<=PLUS_ASSIGN)||LA17_1==QUESTION||LA17_1==SEMI||(LA17_1>=SL && LA17_1<=SL_ASSIGN)||(LA17_1>=SR && LA17_1<=STAR_ASSIGN)||(LA17_1>=STRICT_EQUAL && LA17_1<=STRICT_NOT_EQUAL)||LA17_1==241||LA17_1==249||LA17_1==251)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 127;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 128;}

				else if ((LA17_1==STATIC)) {s = 129;}

				else if ((LA17_1==246)) {s = 130;}

				else if ((LA17_1==244)) {s = 131;}

				else if ((LA17_1==245)) {s = 132;}

				else if ((LA17_1==252)) {s = 133;}

				else if ((LA17_1==DYNAMIC)) {s = 134;}

				else if ((LA17_1==250)) {s = 135;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 136;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 137;}

				else if ((LA17_1==DBL_COLON)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 2:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 139;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 140;}

				else if ((LA17_1==STATIC)) {s = 141;}

				else if ((LA17_1==246)) {s = 142;}

				else if ((LA17_1==244)) {s = 143;}

				else if ((LA17_1==245)) {s = 144;}

				else if ((LA17_1==252)) {s = 145;}

				else if ((LA17_1==DYNAMIC)) {s = 146;}

				else if ((LA17_1==250)) {s = 147;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 148;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 149;}

				input.Seek(index17_1);
				break;
			}
		case 3:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 150;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 151;}

				else if ((LA17_1==STATIC)) {s = 152;}

				else if ((LA17_1==246)) {s = 153;}

				else if ((LA17_1==244)) {s = 154;}

				else if ((LA17_1==245)) {s = 155;}

				else if ((LA17_1==252)) {s = 156;}

				else if ((LA17_1==DYNAMIC)) {s = 157;}

				else if ((LA17_1==250)) {s = 158;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 159;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 160;}

				input.Seek(index17_1);
				break;
			}
		case 4:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 161;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 162;}

				else if ((LA17_1==STATIC)) {s = 163;}

				else if ((LA17_1==246)) {s = 164;}

				else if ((LA17_1==244)) {s = 165;}

				else if ((LA17_1==245)) {s = 166;}

				else if ((LA17_1==252)) {s = 167;}

				else if ((LA17_1==DYNAMIC)) {s = 168;}

				else if ((LA17_1==250)) {s = 169;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 170;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 171;}

				input.Seek(index17_1);
				break;
			}
		case 5:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 172;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 173;}

				else if ((LA17_1==STATIC)) {s = 174;}

				else if ((LA17_1==246)) {s = 175;}

				else if ((LA17_1==244)) {s = 176;}

				else if ((LA17_1==245)) {s = 177;}

				else if ((LA17_1==252)) {s = 178;}

				else if ((LA17_1==DYNAMIC)) {s = 179;}

				else if ((LA17_1==250)) {s = 180;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 181;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 182;}

				input.Seek(index17_1);
				break;
			}
		case 6:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 183;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 184;}

				else if ((LA17_1==STATIC)) {s = 185;}

				else if ((LA17_1==246)) {s = 186;}

				else if ((LA17_1==244)) {s = 187;}

				else if ((LA17_1==245)) {s = 188;}

				else if ((LA17_1==252)) {s = 189;}

				else if ((LA17_1==DYNAMIC)) {s = 190;}

				else if ((LA17_1==250)) {s = 191;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 192;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 193;}

				input.Seek(index17_1);
				break;
			}
		case 7:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 194;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 195;}

				else if ((LA17_1==STATIC)) {s = 196;}

				else if ((LA17_1==246)) {s = 197;}

				else if ((LA17_1==244)) {s = 198;}

				else if ((LA17_1==245)) {s = 199;}

				else if ((LA17_1==252)) {s = 200;}

				else if ((LA17_1==DYNAMIC)) {s = 201;}

				else if ((LA17_1==250)) {s = 202;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 203;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 204;}

				else if (((LA17_1>=AS && LA17_1<=ASSIGN)||(LA17_1>=BAND && LA17_1<=BAND_ASSIGN)||(LA17_1>=BOR && LA17_1<=BOR_ASSIGN)||(LA17_1>=BSR && LA17_1<=BXOR_ASSIGN)||LA17_1==COMMA||LA17_1==DEC||(LA17_1>=DIV && LA17_1<=DIV_ASSIGN)||LA17_1==DOT||LA17_1==E4X_DESC||LA17_1==EQUAL||LA17_1==GE||LA17_1==GT||LA17_1==INC||(LA17_1>=IS && LA17_1<=LBRACK)||LA17_1==LE||(LA17_1>=LOR && LA17_1<=LT)||(LA17_1>=MINUS && LA17_1<=MINUS_ASSIGN)||LA17_1==MOD||LA17_1==MOD_ASSIGN||LA17_1==NOT_EQUAL||(LA17_1>=PLUS && LA17_1<=PLUS_ASSIGN)||LA17_1==QUESTION||LA17_1==SEMI||(LA17_1>=SL && LA17_1<=SL_ASSIGN)||(LA17_1>=SR && LA17_1<=STAR_ASSIGN)||(LA17_1>=STRICT_EQUAL && LA17_1<=STRICT_NOT_EQUAL)||LA17_1==241||LA17_1==249||LA17_1==251)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 8:
			{
				input.Rewind();
				if ((LA17_1==IDENT)) {s = 225;}

				else if ((LA17_1==INTERNAL||LA17_1==PRIVATE||(LA17_1>=PROTECTED && LA17_1<=PUBLIC))) {s = 226;}

				else if ((LA17_1==STATIC)) {s = 227;}

				else if ((LA17_1==246)) {s = 228;}

				else if ((LA17_1==244)) {s = 229;}

				else if ((LA17_1==245)) {s = 230;}

				else if ((LA17_1==252)) {s = 231;}

				else if ((LA17_1==DYNAMIC)) {s = 232;}

				else if ((LA17_1==250)) {s = 233;}

				else if ((LA17_1==CONST||LA17_1==VAR) && (EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((LA17_1==FUNCTION) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 235;}

				input.Seek(index17_1);
				break;
			}
		case 9:
			{
				input.Rewind();
				if ((LA17_1==GET) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 246;}

				else if ((LA17_1==IDENT) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 247;}

				else if ((LA17_1==USE) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 248;}

				else if ((LA17_1==XML) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 249;}

				else if ((LA17_1==DYNAMIC) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 250;}

				else if ((LA17_1==NAMESPACE) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 251;}

				else if ((LA17_1==IS) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 252;}

				else if ((LA17_1==AS) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 253;}

				else if ((LA17_1==SET) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 254;}

				else if ((LA17_1==SUPER) && (EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				else if ((LA17_1==LPAREN)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 10:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 11:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 12:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 13:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 14:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 15:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 16:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 17:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 18:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 19:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred9_AS3_fragment))) {s = 257;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 20:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 21:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 22:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 23:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 24:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 25:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 26:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 27:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 28:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 29:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 30:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 31:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 32:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 33:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 34:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 35:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 36:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 37:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 38:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 39:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 40:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 41:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 42:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 43:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 44:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 45:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 46:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 47:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 48:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 49:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 50:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 51:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 52:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 53:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 54:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 55:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 56:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 57:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 58:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 59:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 60:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 61:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 62:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 63:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 64:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 65:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 66:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 67:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 68:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 69:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 70:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 71:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 72:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 73:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 74:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 75:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 76:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 77:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 78:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 79:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 80:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 81:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 82:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 83:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 84:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 85:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 86:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 87:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 88:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 89:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 90:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 91:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 92:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 93:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 94:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 95:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 96:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 97:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 98:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 99:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 100:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((EvaluatePredicate(synpred11_AS3_fragment))) {s = 255;}

				input.Seek(index17_1);
				break;
			}
		case 101:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 102:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 103:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 104:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 105:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 106:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 107:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 108:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 109:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}
		case 110:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred10_AS3_fragment))) {s = 234;}

				else if ((true)) {s = 15;}

				input.Seek(index17_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 17, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA20 : DFA
	{
		private const string DFA20_eotS =
			"\x3F\xFFFF";
		private const string DFA20_eofS =
			"\x1\x2\x3E\xFFFF";
		private const string DFA20_minS =
			"\x1\xF\x1\x0\x3D\xFFFF";
		private const string DFA20_maxS =
			"\x1\x101\x1\x0\x3D\xFFFF";
		private const string DFA20_acceptS =
			"\x2\xFFFF\x1\x2\x3B\xFFFF\x1\x1";
		private const string DFA20_specialS =
			"\x1\xFFFF\x1\x0\x3D\xFFFF}>";
		private static readonly string[] DFA20_transitionS =
			{
				"\x1\x2\x5\xFFFF\x1\x2\x3\xFFFF\x1\x2\x8\xFFFF\x1\x2\x7\xFFFF\x1\x2\x1"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1\x2\x3\xFFFF\x1\x2\x3\xFFFF\x2"+
				"\x2\x11\xFFFF\x3\x2\x8\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x2\x2\x2"+
				"\xFFFF\x1\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x2"+
				"\x2\x2\xFFFF\x1\x2\x1\x1\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x7\xFFFF\x1\x2"+
				"\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x3\xFFFF\x1\x2\x8\xFFFF"+
				"\x1\x2\x6\xFFFF\x1\x2\x2\xFFFF\x2\x2\x3\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x2\x9\xFFFF\x1\x2\x2\xFFFF\x4\x2\x5\xFFFF\x1"+
				"\x2\x6\xFFFF\x2\x2\x6\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x5\xFFFF"+
				"\x1\x2\x5\xFFFF\x4\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x6\x2",
				"\x1\xFFFF",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA20_eot = DFA.UnpackEncodedString(DFA20_eotS);
		private static readonly short[] DFA20_eof = DFA.UnpackEncodedString(DFA20_eofS);
		private static readonly char[] DFA20_min = DFA.UnpackEncodedStringToUnsignedChars(DFA20_minS);
		private static readonly char[] DFA20_max = DFA.UnpackEncodedStringToUnsignedChars(DFA20_maxS);
		private static readonly short[] DFA20_accept = DFA.UnpackEncodedString(DFA20_acceptS);
		private static readonly short[] DFA20_special = DFA.UnpackEncodedString(DFA20_specialS);
		private static readonly short[][] DFA20_transition;

		static DFA20()
		{
			int numStates = DFA20_transitionS.Length;
			DFA20_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA20_transition[i] = DFA.UnpackEncodedString(DFA20_transitionS[i]);
			}
		}

		public DFA20( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 20;
			this.eot = DFA20_eot;
			this.eof = DFA20_eof;
			this.min = DFA20_min;
			this.max = DFA20_max;
			this.accept = DFA20_accept;
			this.special = DFA20_special;
			this.transition = DFA20_transition;
		}

		public override string Description { get { return "270:1: maybeBlock options {k=1; } : ( ( LCURLY )=> block |);"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition20(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		s = -1;
		int LA20_1 = input.LA(1);
		int index20_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((EvaluatePredicate(synpred12_AS3_fragment))) {s = 62;}

				else if ((true)) {s = 2;}

				input.Seek(index20_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 20, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}
	private class DFA43 : DFA
	{
		private const string DFA43_eotS =
			"\x3C\xFFFF";
		private const string DFA43_eofS =
			"\x3C\xFFFF";
		private const string DFA43_minS =
			"\xC\xF\x1\xFFFF\xA\x10\x1\xFFFF\x1\xF\xC\x10\x1\xF\x1\x10\x1\x2F\x9\x10"+
			"\x1\xF\xA\x10";
		private const string DFA43_maxS =
			"\x1\x101\x1\xE7\xA\xFB\x1\xFFFF\xA\xBD\x1\xFFFF\x1\x101\xC\xBD\x1\xE7"+
			"\x1\xBD\x1\x2F\x9\xBD\x1\xE7\xA\xBD";
		private const string DFA43_acceptS =
			"\xC\xFFFF\x1\x2\xA\xFFFF\x1\x1\x24\xFFFF";
		private const string DFA43_specialS =
			"\x3C\xFFFF}>";
		private static readonly string[] DFA43_transitionS =
			{
				"\x1\x8\x5\xFFFF\x1\xC\x14\xFFFF\x1\x1\x5\xFFFF\x2\xC\xA\xFFFF\x1\x5"+
				"\x1\xC\x11\xFFFF\x2\xC\x9\xFFFF\x1\xC\x3\xFFFF\x1\x9\x2\xFFFF\x1\xC"+
				"\x1\x2\x9\xFFFF\x1\xC\x3\xFFFF\x1\xC\x1\x7\x2\xFFFF\x2\xC\x7\xFFFF\x1"+
				"\xC\x2\xFFFF\x1\xC\x7\xFFFF\x1\xC\x7\xFFFF\x1\x6\x2\xFFFF\x1\xC\x4\xFFFF"+
				"\x1\xC\x3\xFFFF\x1\xC\x8\xFFFF\x1\xC\x6\xFFFF\x1\xC\x2\xFFFF\x2\xC\x6"+
				"\xFFFF\x1\xC\x5\xFFFF\x1\xC\x1\xA\xC\xFFFF\x2\xC\x1\xB\x6\xFFFF\x1\xC"+
				"\x6\xFFFF\x1\x3\x1\x1\xA\xFFFF\x1\x4\x5\xFFFF\x1\xC\x5\xFFFF\x1\xC\xB"+
				"\xFFFF\x3\xC",
				"\x1\x13\x2C\xFFFF\x1\x10\x21\xFFFF\x1\x14\x3\xFFFF\x1\xD\xE\xFFFF\x1"+
				"\x12\x1E\xFFFF\x1\x11\x2D\xFFFF\x1\x15\xE\xFFFF\x1\x16\xD\xFFFF\x1\xE"+
				"\xB\xFFFF\x1\xF",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x7"+
				"\xFFFF\x2\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"\x2\xC\x1\xFFFF\x2\xC\x3\xFFFF\x2\xC\x3\xFFFF\x4\xC\x7\xFFFF\x1\xC\x8"+
				"\xFFFF\x1\xC\x5\xFFFF\x2\xC\x1\xFFFF\x1\xC\x4\xFFFF\x1\xC\x7\xFFFF\x1"+
				"\xC\x16\xFFFF\x1\xC\x1\xFFFF\x1\xC\xB\xFFFF\x1\x17\x1\xC\x4\xFFFF\x4"+
				"\xC\x1\xFFFF\x1\xC\x7\xFFFF\x4\xC\x6\xFFFF\x2\xC\x1\xFFFF\x1\xC\x2\xFFFF"+
				"\x1\xC\x8\xFFFF\x1\xC\xD\xFFFF\x2\xC\xB\xFFFF\x1\xC\xA\xFFFF\x1\xC\x1"+
				"\xFFFF\x2\xC\x1\xFFFF\x4\xC\x3\xFFFF\x2\xC\x26\xFFFF\x1\xC\x7\xFFFF"+
				"\x1\xC\x1\xFFFF\x1\xC",
				"",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x15\xFFFF\x1\x18\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"",
				"\x1\x1F\x2C\xFFFF\x1\x1C\x21\xFFFF\x1\x20\x3\xFFFF\x1\x19\xE\xFFFF\x1"+
				"\x1E\x1E\xFFFF\x1\x1D\x2D\xFFFF\x1\x21\x5\xFFFF\x1\x24\x8\xFFFF\x1\x22"+
				"\xD\xFFFF\x1\x1A\xB\xFFFF\x1\x1B\x19\xFFFF\x1\x23",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x43\xFFFF\x1\x17\x51\xFFFF\x1\xC",
				"\x1\x2D\x2C\xFFFF\x1\x2A\x21\xFFFF\x1\x2E\x3\xFFFF\x1\x26\xD\xFFFF\x1"+
				"\x27\x1\x2C\x1E\xFFFF\x1\x2B\x1B\xFFFF\x1\x27\x2\xFFFF\x2\x27\xD\xFFFF"+
				"\x1\x2F\xE\xFFFF\x1\x30\xD\xFFFF\x1\x28\xB\xFFFF\x1\x29",
				"\x1\xC\x16\xFFFF\x1\xC\x7\xFFFF\x1\x31\x9\xFFFF\x1\x25\x31\xFFFF\x1"+
				"\x17\x51\xFFFF\x1\xC",
				"\x1\x31",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\x38\x2C\xFFFF\x1\x35\x21\xFFFF\x1\x39\x3\xFFFF\x1\x32\xE\xFFFF\x1"+
				"\x37\x1E\xFFFF\x1\x36\x2D\xFFFF\x1\x3A\xE\xFFFF\x1\x3B\xD\xFFFF\x1\x33"+
				"\xB\xFFFF\x1\x34",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC",
				"\x1\xC\x16\xFFFF\x1\xC\x11\xFFFF\x1\x25\x31\xFFFF\x1\x17\x51\xFFFF\x1"+
				"\xC"
			};

		private static readonly short[] DFA43_eot = DFA.UnpackEncodedString(DFA43_eotS);
		private static readonly short[] DFA43_eof = DFA.UnpackEncodedString(DFA43_eofS);
		private static readonly char[] DFA43_min = DFA.UnpackEncodedStringToUnsignedChars(DFA43_minS);
		private static readonly char[] DFA43_max = DFA.UnpackEncodedStringToUnsignedChars(DFA43_maxS);
		private static readonly short[] DFA43_accept = DFA.UnpackEncodedString(DFA43_acceptS);
		private static readonly short[] DFA43_special = DFA.UnpackEncodedString(DFA43_specialS);
		private static readonly short[][] DFA43_transition;

		static DFA43()
		{
			int numStates = DFA43_transitionS.Length;
			DFA43_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA43_transition[i] = DFA.UnpackEncodedString(DFA43_transitionS[i]);
			}
		}

		public DFA43( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 43;
			this.eot = DFA43_eot;
			this.eof = DFA43_eof;
			this.min = DFA43_min;
			this.max = DFA43_max;
			this.accept = DFA43_accept;
			this.special = DFA43_special;
			this.transition = DFA43_transition;
		}

		public override string Description { get { return "504:3: ( forInClause RPAREN statement -> ^( FOR_IN_LOOP FOR LPAREN forInClause RPAREN statement ) | traditionalForClause RPAREN statement -> ^( FOR_LOOP FOR LPAREN traditionalForClause RPAREN statement ) )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _as2CompilationUnit_in_compilationUnit476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as3CompilationUnit_in_compilationUnit482 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_as2CompilationUnit509 = new BitSet(new ulong[]{0x1000000400000000UL,0x1620400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _as2Type_in_as2CompilationUnit514 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2IncludeDirective_in_as2Type529 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2ClassDefinition_in_as2Type542 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _as2InterfaceDefinition_in_as2Type555 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _packageDecl_in_as3CompilationUnit569 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _packageBlockEntry_in_as3CompilationUnit573 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_as3CompilationUnit578 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PACKAGE_in_packageDecl590 = new BitSet(new ulong[]{0x1000000000008000UL,0x22000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _identifierStar_in_packageDecl592 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _LCURLY_in_packageDecl597 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _packageBlockEntry_in_packageDecl608 = new BitSet(new ulong[]{0x3113140402208000UL,0x2033522644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _RCURLY_in_packageDecl613 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_packageBlockEntry656 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _includeDirective_in_packageBlockEntry664 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _useNamespaceDirective_in_packageBlockEntry672 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_packageBlockEntry688 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespaceDefinition_in_packageBlockEntry704 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _classDefinition_in_packageBlockEntry726 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _interfaceDefinition_in_packageBlockEntry742 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDefinition_in_packageBlockEntry758 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDefinition_in_packageBlockEntry774 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_packageBlockEntry788 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EOF_in_endOfFile801 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IMPORT_in_importDefinition813 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _identifierStar_in_importDefinition815 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_importDefinition819 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SEMI_in_semi852 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_classDefinition864 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_classDefinition868 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_classDefinition879 = new BitSet(new ulong[]{0x0UL,0x20008000002000UL});
		public static readonly BitSet _classExtendsClause_in_classDefinition883 = new BitSet(new ulong[]{0x0UL,0x20008000000000UL});
		public static readonly BitSet _implementsClause_in_classDefinition888 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_classDefinition893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_as2ClassDefinition930 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_as2ClassDefinition934 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_as2ClassDefinition936 = new BitSet(new ulong[]{0x0UL,0x20008000002000UL});
		public static readonly BitSet _classExtendsClause_in_as2ClassDefinition940 = new BitSet(new ulong[]{0x0UL,0x20008000000000UL});
		public static readonly BitSet _implementsClause_in_as2ClassDefinition945 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_as2ClassDefinition950 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_interfaceDefinition981 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_interfaceDefinition985 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_interfaceDefinition987 = new BitSet(new ulong[]{0x0UL,0x20000000002000UL});
		public static readonly BitSet _interfaceExtendsClause_in_interfaceDefinition991 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_interfaceDefinition996 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_as2InterfaceDefinition1026 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_as2InterfaceDefinition1030 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_as2InterfaceDefinition1032 = new BitSet(new ulong[]{0x0UL,0x20000000002000UL});
		public static readonly BitSet _interfaceExtendsClause_in_as2InterfaceDefinition1036 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _typeBlock_in_as2InterfaceDefinition1041 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_classExtendsClause1069 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_classExtendsClause1071 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_interfaceExtendsClause1100 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_interfaceExtendsClause1102 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_interfaceExtendsClause1106 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_interfaceExtendsClause1108 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _IMPLEMENTS_in_implementsClause1140 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_implementsClause1142 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_implementsClause1146 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _identifier_in_implementsClause1148 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _LCURLY_in_typeBlock1180 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033122644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _typeBlockEntry_in_typeBlock1190 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033122644038000UL,0x6491902011090101UL,0xF57820A818107900UL,0x3UL});
		public static readonly BitSet _RCURLY_in_typeBlock1195 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _includeDirective_in_typeBlockEntry1237 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _importDefinition_in_typeBlockEntry1242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _annotation_in_typeBlockEntry1255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDefinition_in_typeBlockEntry1269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _methodDefinition_in_typeBlockEntry1290 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_typeBlockEntry1303 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INCLUDE_DIRECTIVE_in_as2IncludeDirective1314 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x1800UL});
		public static readonly BitSet _stringLiteral_in_as2IncludeDirective1318 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _248_in_includeDirective1329 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x1800UL});
		public static readonly BitSet _stringLiteral_in_includeDirective1331 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_includeDirective1335 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_methodDefinition1369 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_methodDefinition1373 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _accessorRole_in_methodDefinition1383 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _methodName_in_methodDefinition1388 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _parameterDeclarationList_in_methodDefinition1392 = new BitSet(new ulong[]{0x4000000000UL,0x20000000000000UL});
		public static readonly BitSet _typeExpression_in_methodDefinition1396 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _maybeBlock_in_methodDefinition1407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_maybeBlock1501 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_methodName1527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_namespaceDefinition1573 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_namespaceDefinition1575 = new BitSet(new ulong[]{0x0UL,0x1000400000000UL,0x1900000000000UL});
		public static readonly BitSet _namespaceName_in_namespaceDefinition1577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_useNamespaceDirective1602 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_useNamespaceDirective1604 = new BitSet(new ulong[]{0x0UL,0x1000400000000UL,0x1900000000000UL});
		public static readonly BitSet _namespaceName_in_useNamespaceDirective1606 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_useNamespaceDirective1608 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_variableDefinition1619 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_variableDefinition1625 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_variableDefinition1627 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _COMMA_in_variableDefinition1632 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_variableDefinition1634 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_variableDefinition1642 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varOrConst_in_declaration1671 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_declaration1673 = new BitSet(new ulong[]{0x8000000000UL});
		public static readonly BitSet _declarationTail_in_declaration1675 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_declarationTail1722 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _variableDeclarator_in_declarationTail1724 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _ASSIGN_in_variableInitializer1737 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_variableInitializer1739 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_variableDeclarator1768 = new BitSet(new ulong[]{0x4000010002UL});
		public static readonly BitSet _typeExpression_in_variableDeclarator1770 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _variableInitializer_in_variableDeclarator1773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_parameterDeclarationList1810 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x5200000000010000UL,0x8008002000UL});
		public static readonly BitSet _parameterDeclaration_in_parameterDeclarationList1816 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _COMMA_in_parameterDeclarationList1822 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x4200000000010000UL,0x8008002000UL});
		public static readonly BitSet _parameterDeclaration_in_parameterDeclarationList1824 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_parameterDeclarationList1835 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _basicParameterDeclaration_in_parameterDeclaration1862 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _parameterRestDeclaration_in_parameterDeclaration1866 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONST_in_basicParameterDeclaration1877 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_basicParameterDeclaration1880 = new BitSet(new ulong[]{0x4000010002UL});
		public static readonly BitSet _typeExpression_in_basicParameterDeclaration1882 = new BitSet(new ulong[]{0x10002UL});
		public static readonly BitSet _parameterDefault_in_basicParameterDeclaration1885 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ASSIGN_in_parameterDefault1919 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_parameterDefault1921 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REST_in_parameterRestDeclaration1932 = new BitSet(new ulong[]{0x1000004000008002UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_parameterRestDeclaration1934 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _typeExpression_in_parameterRestDeclaration1937 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_block1964 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6491902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _blockEntry_in_block1966 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6491902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _RCURLY_in_block1969 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_blockEntry1995 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_condition2006 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_condition2008 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_condition2010 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _block_in_statement2037 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declarationStatement_in_statement2043 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statement2050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement2056 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forEachStatement_in_statement2062 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_statement2068 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doWhileStatement_in_statement2074 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statement2081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statement2088 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statement2095 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statement2101 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statement2107 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statement2113 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statement2120 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _defaultXMLNamespaceStatement_in_statement2127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _semi_in_statement2142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_declarationStatement2158 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_declarationStatement2162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_expressionStatement2189 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_expressionStatement2193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement2217 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_ifStatement2219 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_ifStatement2221 = new BitSet(new ulong[]{0x2UL,0x8UL});
		public static readonly BitSet _elseClause_in_ifStatement2230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_elseClause2266 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_elseClause2268 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _253_in_throwStatement2298 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_throwStatement2300 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_throwStatement2304 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _254_in_tryStatement2335 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_tryStatement2339 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x84000000000000UL});
		public static readonly BitSet _catchBlock_in_tryStatement2343 = new BitSet(new ulong[]{0x2UL,0x0UL,0x0UL,0x84000000000000UL});
		public static readonly BitSet _finallyBlock_in_tryStatement2348 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _242_in_catchBlock2384 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_catchBlock2386 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_catchBlock2388 = new BitSet(new ulong[]{0x4000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _typeExpression_in_catchBlock2390 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_catchBlock2393 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_catchBlock2397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _247_in_finallyBlock2408 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_finallyBlock2410 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _RETURN_in_returnStatement2421 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_returnStatement2423 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_returnStatement2428 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CONTINUE_in_continueStatement2462 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_continueStatement2466 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAK_in_breakStatement2495 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_breakStatement2499 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switchStatement2528 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_switchStatement2530 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _switchBlock_in_switchStatement2534 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_switchBlock2565 = new BitSet(new ulong[]{0x10000100000000UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _caseStatement_in_switchBlock2570 = new BitSet(new ulong[]{0x10000100000000UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _defaultStatement_in_switchBlock2577 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _RCURLY_in_switchBlock2583 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CASE_in_caseStatement2608 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_caseStatement2610 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_caseStatement2612 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _switchStatementList_in_caseStatement2617 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFAULT_in_defaultStatement2630 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_defaultStatement2632 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _switchStatementList_in_defaultStatement2637 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_switchStatementList2649 = new BitSet(new ulong[]{0x3113140002208002UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _FOR_in_forEachStatement2672 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _EACH_in_forEachStatement2674 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_forEachStatement2678 = new BitSet(new ulong[]{0x1000040000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8018002000UL});
		public static readonly BitSet _forInClause_in_forEachStatement2682 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forEachStatement2686 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forEachStatement2690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement2717 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _LPAREN_in_forStatement2721 = new BitSet(new ulong[]{0x3003040000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208018103800UL,0x3UL});
		public static readonly BitSet _forInClause_in_forStatement2727 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forStatement2729 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forStatement2731 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _traditionalForClause_in_forStatement2757 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_forStatement2759 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_forStatement2761 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInit_in_traditionalForClause2795 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_traditionalForClause2798 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x6081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forCond_in_traditionalForClause2803 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_traditionalForClause2806 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forIter_in_traditionalForClause2811 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInClauseDecl_in_forInClause2825 = new BitSet(new ulong[]{0x0UL,0x80000000000UL});
		public static readonly BitSet _IN_in_forInClause2827 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _forInClauseTail_in_forInClause2829 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _varOrConst_in_forInClauseDecl2840 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_forInClauseDecl2842 = new BitSet(new ulong[]{0x4000000002UL});
		public static readonly BitSet _typeExpression_in_forInClauseDecl2844 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_forInClauseDecl2858 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forInClauseTail2870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _declaration_in_forInit2884 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forInit2888 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forCond2916 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionList_in_forIter2939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement2962 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_whileStatement2964 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_whileStatement2966 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DO_in_doWhileStatement2989 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_doWhileStatement2991 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x800000000UL});
		public static readonly BitSet _WHILE_in_doWhileStatement2993 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_doWhileStatement2995 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_doWhileStatement2997 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WITH_in_withStatement3025 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _condition_in_withStatement3027 = new BitSet(new ulong[]{0x3113140002208000UL,0x2033102644038000UL,0x6481902011090101UL,0xE00820A818107800UL,0x3UL});
		public static readonly BitSet _statement_in_withStatement3029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEFAULT_in_defaultXMLNamespaceStatement3040 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x8000000000UL});
		public static readonly BitSet _XML_in_defaultXMLNamespaceStatement3042 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_defaultXMLNamespaceStatement3044 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ASSIGN_in_defaultXMLNamespaceStatement3046 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_defaultXMLNamespaceStatement3048 = new BitSet(new ulong[]{0x0UL,0x0UL,0x2000000000000000UL});
		public static readonly BitSet _semi_in_defaultXMLNamespaceStatement3050 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COLON_in_typeExpression3075 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002010UL,0x2UL});
		public static readonly BitSet _typeIdentifier_in_typeExpression3078 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _257_in_typeExpression3082 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_typeExpression3086 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_typeIdentifier3127 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _propOrIdent_in_typeIdentifier3130 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _qualifiedIdent_in_identifier3148 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _propOrIdent_in_identifier3156 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _namespaceName_in_qualifiedIdent3196 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _DBL_COLON_in_qualifiedIdent3198 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_qualifiedIdent3200 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_qualifiedIdent3232 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_namespaceName3246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _reservedNamespace_in_namespaceName3250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_identifierStar3287 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _dotIdent_in_identifierStar3291 = new BitSet(new ulong[]{0x200000000000002UL});
		public static readonly BitSet _DOT_in_identifierStar3297 = new BitSet(new ulong[]{0x0UL,0x0UL,0x0UL,0x10UL});
		public static readonly BitSet _STAR_in_identifierStar3299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_dotIdent3334 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_dotIdent3336 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_ident3356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _USE_in_ident3369 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _XML_in_ident3374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DYNAMIC_in_ident3379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAMESPACE_in_ident3384 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IS_in_ident3389 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _AS_in_ident3394 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _GET_in_ident3399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SET_in_ident3404 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SUPER_in_ident3409 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_annotation3420 = new BitSet(new ulong[]{0x1000000000008000UL,0x2000440000000UL,0x4000000000010000UL,0x8008002000UL});
		public static readonly BitSet _ident_in_annotation3424 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000001UL});
		public static readonly BitSet _annotationParamList_in_annotation3428 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_annotation3433 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_annotationParamList3459 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640018000UL,0x5080000011010000UL,0x208008103800UL});
		public static readonly BitSet _annotationParam_in_annotationParamList3465 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _COMMA_in_annotationParamList3471 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640018000UL,0x4080000011010000UL,0x208008103800UL});
		public static readonly BitSet _annotationParam_in_annotationParamList3473 = new BitSet(new ulong[]{0x8000000000UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_annotationParamList3484 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_annotationParam3511 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _ASSIGN_in_annotationParam3513 = new BitSet(new ulong[]{0x2000000000000UL,0x200018000UL,0x80000011000000UL,0x200000101800UL});
		public static readonly BitSet _constant_in_annotationParam3515 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_annotationParam3530 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_annotationParam3539 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifier_in_modifiers3557 = new BitSet(new ulong[]{0x1000000000000002UL,0x1000400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _modifier_in_modifiers3560 = new BitSet(new ulong[]{0x1000000000000002UL,0x1000400000000UL,0x1900000000000UL,0x1470000000000100UL});
		public static readonly BitSet _namespaceName_in_modifier3586 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STATIC_in_modifier3591 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _246_in_modifier3596 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _244_in_modifier3601 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _245_in_modifier3606 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _252_in_modifier3611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DYNAMIC_in_modifier3616 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _250_in_modifier3621 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments3632 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expressionList_in_arguments3634 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_arguments3636 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_arguments3656 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_arguments3658 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_arrayLiteral3681 = new BitSet(new ulong[]{0x3003008000208000UL,0x2033100644018000UL,0x4089902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _elementList_in_arrayLiteral3683 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_arrayLiteral3686 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _COMMA_in_elementList3714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonemptyElementList_in_elementList3720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_nonemptyElementList3730 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_nonemptyElementList3733 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_nonemptyElementList3736 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _assignmentExpression_in_element3749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_objectLiteral3771 = new BitSet(new ulong[]{0x1002000000008000UL,0x2000640010000UL,0x4010000010010000UL,0x8008002000UL});
		public static readonly BitSet _fieldList_in_objectLiteral3773 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000000000000UL});
		public static readonly BitSet _RCURLY_in_objectLiteral3776 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literalField_in_fieldList3799 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_fieldList3802 = new BitSet(new ulong[]{0x1002008000008002UL,0x2000640010000UL,0x4000000010010000UL,0x8008002000UL});
		public static readonly BitSet _literalField_in_fieldList3805 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _fieldName_in_literalField3822 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_literalField3824 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _element_in_literalField3826 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ident_in_fieldName3850 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_fieldName3855 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression3867 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expressionList3895 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _COMMA_in_expressionList3898 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_expressionList3900 = new BitSet(new ulong[]{0x8000000002UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression3931 = new BitSet(new ulong[]{0x800000A1090002UL,0x8008000000000000UL,0x4000004200UL,0x29UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression3940 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression3942 = new BitSet(new ulong[]{0x800000A1090002UL,0x8008000000000000UL,0x4000004200UL,0x29UL});
		public static readonly BitSet _logicalOrExpression_in_conditionalExpression4035 = new BitSet(new ulong[]{0x2UL,0x0UL,0x4000000000000UL});
		public static readonly BitSet _QUESTION_in_conditionalExpression4049 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _conditionalSubExpression_in_conditionalExpression4054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_conditionalSubExpression4083 = new BitSet(new ulong[]{0x4000000000UL});
		public static readonly BitSet _COLON_in_conditionalSubExpression4085 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_conditionalSubExpression4087 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression4101 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL,0x0UL,0x800000000000000UL});
		public static readonly BitSet _logicalOrOperator_in_logicalOrExpression4106 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _logicalAndExpression_in_logicalOrExpression4108 = new BitSet(new ulong[]{0x2UL,0x4000000000000000UL,0x0UL,0x800000000000000UL});
		public static readonly BitSet _bitwiseOrExpression_in_logicalAndExpression4137 = new BitSet(new ulong[]{0x2UL,0x4000000000000UL,0x0UL,0x2000000000000UL});
		public static readonly BitSet _logicalAndOperator_in_logicalAndExpression4142 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseOrExpression_in_logicalAndExpression4144 = new BitSet(new ulong[]{0x2UL,0x4000000000000UL,0x0UL,0x2000000000000UL});
		public static readonly BitSet _bitwiseXorExpression_in_bitwiseOrExpression4173 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _BOR_in_bitwiseOrExpression4178 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseXorExpression_in_bitwiseOrExpression4180 = new BitSet(new ulong[]{0x800002UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXorExpression4194 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _BXOR_in_bitwiseXorExpression4199 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _bitwiseAndExpression_in_bitwiseXorExpression4201 = new BitSet(new ulong[]{0x40000002UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression4215 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _BAND_in_bitwiseAndExpression4220 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _equalityExpression_in_bitwiseAndExpression4222 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4236 = new BitSet(new ulong[]{0x2UL,0x40UL,0x800000UL,0x600UL});
		public static readonly BitSet _equalityOperator_in_equalityExpression4247 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4249 = new BitSet(new ulong[]{0x2UL,0x40UL,0x800000UL,0x600UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4287 = new BitSet(new ulong[]{0x8002UL,0x420000A0000000UL,0x2UL,0x200000000000000UL});
		public static readonly BitSet _relationalOperator_in_relationalExpression4290 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4292 = new BitSet(new ulong[]{0x8002UL,0x420000A0000000UL,0x2UL,0x200000000000000UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression4342 = new BitSet(new ulong[]{0x10000002UL,0x0UL,0x8000000000000000UL,0x4UL});
		public static readonly BitSet _shiftOperator_in_shiftExpression4347 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression4349 = new BitSet(new ulong[]{0x10000002UL,0x0UL,0x8000000000000000UL,0x4UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression4382 = new BitSet(new ulong[]{0x2UL,0x0UL,0x2000000100UL});
		public static readonly BitSet _additiveOperator_in_additiveExpression4385 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression4387 = new BitSet(new ulong[]{0x2UL,0x0UL,0x2000000100UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4416 = new BitSet(new ulong[]{0x40000000000002UL,0x0UL,0x800UL,0x10UL});
		public static readonly BitSet _multiplicativeOperator_in_multiplicativeExpression4422 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression4427 = new BitSet(new ulong[]{0x40000000000002UL,0x0UL,0x800UL,0x10UL});
		public static readonly BitSet _INC_in_unaryExpression4465 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_unaryExpression4474 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4476 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_unaryExpression4481 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4483 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _PLUS_in_unaryExpression4488 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression4490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpressionNotPlusMinus_in_unaryExpression4495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _243_in_unaryExpressionNotPlusMinus4506 = new BitSet(new ulong[]{0x3002000000008000UL,0x33000644018000UL,0x4081900011090001UL,0x208008103800UL,0x1UL});
		public static readonly BitSet _postfixExpression_in_unaryExpressionNotPlusMinus4508 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _257_in_unaryExpressionNotPlusMinus4521 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4523 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _255_in_unaryExpressionNotPlusMinus4536 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4538 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LNOT_in_unaryExpressionNotPlusMinus4551 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4553 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BNOT_in_unaryExpressionNotPlusMinus4566 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _unaryExpression_in_unaryExpressionNotPlusMinus4568 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpressionNotPlusMinus4581 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_postfixExpression4595 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _propOrIdent_in_postfixExpression4619 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _DOT_in_postfixExpression4674 = new BitSet(new ulong[]{0x2000000000000000UL,0x0UL,0x1UL,0x10UL});
		public static readonly BitSet _e4xExpression_in_postfixExpression4676 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _E4X_DESC_in_postfixExpression4719 = new BitSet(new ulong[]{0x2000000000000000UL,0x0UL,0x1UL,0x10UL});
		public static readonly BitSet _e4xExpression_in_postfixExpression4721 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _LBRACK_in_postfixExpression4778 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_postfixExpression4780 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_postfixExpression4782 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _arguments_in_postfixExpression4833 = new BitSet(new ulong[]{0x4201000000000002UL,0x10100000000000UL,0x1UL});
		public static readonly BitSet _INC_in_postfixExpression4877 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DEC_in_postfixExpression4895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_e4xExpression4924 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xAttributeIdentifier_in_e4xExpression4929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xFilterPredicate_in_e4xExpression4934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _E4X_ATTRI_in_e4xAttributeIdentifier4945 = new BitSet(new ulong[]{0x1000000000008000UL,0x13000440000000UL,0x4001900000010000UL,0x8008002010UL});
		public static readonly BitSet _qualifiedIdent_in_e4xAttributeIdentifier4951 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STAR_in_e4xAttributeIdentifier4957 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_e4xAttributeIdentifier4963 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_e4xAttributeIdentifier4965 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_e4xAttributeIdentifier4967 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_e4xFilterPredicate4982 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expression_in_e4xFilterPredicate4987 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_e4xFilterPredicate4991 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _256_in_primaryExpression5003 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_in_primaryExpression5008 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression5029 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression5034 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDefinition_in_primaryExpression5039 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_primaryExpression5044 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _encapsulatedExpression_in_primaryExpression5049 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _e4xAttributeIdentifier_in_primaryExpression5054 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qualifiedIdent_in_primaryExpression5059 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_propOrIdent5075 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_propOrIdent5077 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _xmlLiteral_in_constant5102 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _regexpLiteral_in_constant5107 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _number_in_constant5112 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteral_in_constant5125 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _TRUE_in_constant5138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FALSE_in_constant5143 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NULL_in_constant5148 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteralDouble_in_stringLiteral5162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stringLiteralSingle_in_stringLiteral5166 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_DOUBLE_in_stringLiteralDouble5183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _STRING_LITERAL_SINGLE_in_stringLiteralSingle5208 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _XML_LITERAL_in_xmlLiteral5269 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _REGEX_LITERAL_in_regexpLiteral5299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NEW_in_newExpression5320 = new BitSet(new ulong[]{0x3002000000008000UL,0x33000644018000UL,0x4081900011090001UL,0x208008103800UL,0x1UL});
		public static readonly BitSet _fullNewSubexpression_in_newExpression5322 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _arguments_in_newExpression5324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryExpression_in_fullNewSubexpression5349 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _DOT_in_fullNewSubexpression5365 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_fullNewSubexpression5367 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _brackets_in_fullNewSubexpression5384 = new BitSet(new ulong[]{0x200000000000002UL,0x10000000000000UL});
		public static readonly BitSet _DOT_in_propertyOperator5411 = new BitSet(new ulong[]{0x1000000000008000UL,0x3000440000000UL,0x4001900000010000UL,0x8008002000UL});
		public static readonly BitSet _qualifiedIdent_in_propertyOperator5413 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _brackets_in_propertyOperator5418 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_brackets5429 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _expressionList_in_brackets5431 = new BitSet(new ulong[]{0x0UL,0x0UL,0x8000000000000UL});
		public static readonly BitSet _RBRACK_in_brackets5433 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_encapsulatedExpression5444 = new BitSet(new ulong[]{0x3003000000208000UL,0x2033100644018000UL,0x4081902011090101UL,0x8008208008103800UL,0x3UL});
		public static readonly BitSet _assignmentExpression_in_encapsulatedExpression5446 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1000000000000000UL});
		public static readonly BitSet _RPAREN_in_encapsulatedExpression5448 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTION_in_functionDefinition5472 = new BitSet(new ulong[]{0x0UL,0x0UL,0x1UL});
		public static readonly BitSet _parameterDeclarationList_in_functionDefinition5474 = new BitSet(new ulong[]{0x4000000000UL,0x20000000000000UL});
		public static readonly BitSet _typeExpression_in_functionDefinition5476 = new BitSet(new ulong[]{0x0UL,0x20000000000000UL});
		public static readonly BitSet _block_in_functionDefinition5479 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred1_AS3535 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_synpred1_AS3537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred2_AS3548 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_synpred2_AS3550 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_synpred3_AS3681 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _IDENT_in_synpred3_AS3683 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred4_AS3697 = new BitSet(new ulong[]{0x0UL,0x0UL,0x10000UL});
		public static readonly BitSet _NAMESPACE_in_synpred4_AS3699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred5_AS3719 = new BitSet(new ulong[]{0x400000000UL});
		public static readonly BitSet _CLASS_in_synpred5_AS3721 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred6_AS3735 = new BitSet(new ulong[]{0x0UL,0x400000000000UL});
		public static readonly BitSet _INTERFACE_in_synpred6_AS3737 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred7_AS3751 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_synpred7_AS3753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred8_AS3767 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_synpred8_AS3769 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACK_in_synpred9_AS31248 = new BitSet(new ulong[]{0x0UL,0x400000000UL});
		public static readonly BitSet _IDENT_in_synpred9_AS31250 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred10_AS31261 = new BitSet(new ulong[]{0x40000000000UL,0x0UL,0x0UL,0x10000000UL});
		public static readonly BitSet _varOrConst_in_synpred10_AS31263 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _modifiers_in_synpred11_AS31283 = new BitSet(new ulong[]{0x0UL,0x4000000UL});
		public static readonly BitSet _FUNCTION_in_synpred11_AS31285 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_synpred12_AS31496 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LCURLY_in_synpred13_AS32032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ELSE_in_synpred14_AS32227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespaceName_in_synpred15_AS33189 = new BitSet(new ulong[]{0x800000000000UL});
		public static readonly BitSet _DBL_COLON_in_synpred15_AS33191 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentOperator_in_synpred16_AS33935 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
