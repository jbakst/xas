//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.5.0.1
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.5.0.1 AS3.g 2013-02-03 21:45:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.5.0.1")]
[System.CLSCompliant(false)]
public partial class AS3Lexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ACCESSOR_ROLE=4;
	public const int ADDITIVE_EXP=5;
	public const int ANNOTATION=6;
	public const int ANNOTATIONS=7;
	public const int ANNOTATION_PARAMS=8;
	public const int ARGUMENT=9;
	public const int ARGUMENTS=10;
	public const int ARRAY_ACC=11;
	public const int ARRAY_ACCESS=12;
	public const int ARRAY_LITERAL=13;
	public const int ARRAY_SUBSCRIPT=14;
	public const int AS=15;
	public const int ASSIGN=16;
	public const int ASSIGNMENT_EXPR=17;
	public const int BAND=18;
	public const int BAND_ASSIGN=19;
	public const int BLOCK=20;
	public const int BNOT=21;
	public const int BOM=22;
	public const int BOR=23;
	public const int BOR_ASSIGN=24;
	public const int BREAK=25;
	public const int BREAK_STATEMENT=26;
	public const int BSLASH=27;
	public const int BSR=28;
	public const int BSR_ASSIGN=29;
	public const int BXOR=30;
	public const int BXOR_ASSIGN=31;
	public const int CASE=32;
	public const int CASE_DEFAULT=33;
	public const int CLASS=34;
	public const int CLASS_DEF=35;
	public const int CLASS_MEMBER=36;
	public const int CLASS_NAME=37;
	public const int COLON=38;
	public const int COMMA=39;
	public const int COMPILATION_UNIT=40;
	public const int CONDITION=41;
	public const int CONST=42;
	public const int CONSTANT=43;
	public const int CONTINUE=44;
	public const int CONTINUE_STATEMENT=45;
	public const int CTRLCHAR_ESC=46;
	public const int DBL_COLON=47;
	public const int DEC=48;
	public const int DECIMAL_LITERAL=49;
	public const int DECLARATION=50;
	public const int DECL_STMT=51;
	public const int DEFAULT=52;
	public const int DEFAULT_XML_NAMESPACE=53;
	public const int DIV=54;
	public const int DIV_ASSIGN=55;
	public const int DO=56;
	public const int DOT=57;
	public const int DO_WHILE=58;
	public const int DO_WHILE_LOOP=59;
	public const int DYNAMIC=60;
	public const int E4X_ATTRI=61;
	public const int E4X_DESC=62;
	public const int E4X_EXPRESSION=63;
	public const int EACH=64;
	public const int ELEMENT=65;
	public const int ELIST=66;
	public const int ELSE=67;
	public const int ELSE_CLAUSE=68;
	public const int ENCPS_EXPR=69;
	public const int EQUAL=70;
	public const int ESC=71;
	public const int EXPONENT=72;
	public const int EXPR=73;
	public const int EXPRESSION=74;
	public const int EXPR_LIST=75;
	public const int EXPR_STMNT=76;
	public const int EXTENDS=77;
	public const int EXTENDS_CLAUSE=78;
	public const int FALSE=79;
	public const int FLOAT_LITERAL=80;
	public const int FOR=81;
	public const int FOR_CLAUSE=82;
	public const int FOR_CONDITION=83;
	public const int FOR_EACH_LOOP=84;
	public const int FOR_INIT=85;
	public const int FOR_IN_CLAUSE=86;
	public const int FOR_IN_LOOP=87;
	public const int FOR_ITERATOR=88;
	public const int FOR_LOOP=89;
	public const int FUNCTION=90;
	public const int FUNCTION_CALL=91;
	public const int FUNC_DEF=92;
	public const int GE=93;
	public const int GET=94;
	public const int GT=95;
	public const int HEX_DIGIT=96;
	public const int HEX_LITERAL=97;
	public const int IDENT=98;
	public const int IDENTIFIER=99;
	public const int IDENTIFIER_STAR=100;
	public const int IF=101;
	public const int IF_STMT=102;
	public const int IMPLEMENTS=103;
	public const int IMPLEMENTS_CLAUSE=104;
	public const int IMPORT=105;
	public const int IMPORT_DEF=106;
	public const int IN=107;
	public const int INC=108;
	public const int INCLUDE_DIRECTIVE=109;
	public const int INTERFACE=110;
	public const int INTERFACE_DEF=111;
	public const int INTERNAL=112;
	public const int IS=113;
	public const int LAND=114;
	public const int LAND_ASSIGN=115;
	public const int LBRACK=116;
	public const int LCURLY=117;
	public const int LE=118;
	public const int LITERAL_DOUBLE_STRING=119;
	public const int LITERAL_NUMBER=120;
	public const int LITERAL_REGEX=121;
	public const int LITERAL_SINGLE_STRING=122;
	public const int LITERAL_STRING=123;
	public const int LITERAL_XML=124;
	public const int LNOT=125;
	public const int LOR=126;
	public const int LOR_ASSIGN=127;
	public const int LPAREN=128;
	public const int LT=129;
	public const int METADATA=130;
	public const int METADATA_ITEM=131;
	public const int METHOD=132;
	public const int METHOD_BLOCK=133;
	public const int METHOD_DEF=134;
	public const int METHOD_NAME=135;
	public const int MINUS=136;
	public const int MINUS_ASSIGN=137;
	public const int ML_COMMENT=138;
	public const int MOD=139;
	public const int MODIFIERS=140;
	public const int MODIFIER_LIST=141;
	public const int MOD_ASSIGN=142;
	public const int NAME=143;
	public const int NAMESPACE=144;
	public const int NAMESPACE_DEF=145;
	public const int NAMESPACE_USAGE=146;
	public const int NEW=147;
	public const int NEW_EXPR=148;
	public const int NEW_EXPRESSION=149;
	public const int NL=150;
	public const int NOT_EQUAL=151;
	public const int NULL=152;
	public const int OBJECT_FIELD=153;
	public const int OBJECT_LITERAL=154;
	public const int OCTAL_ESC=155;
	public const int OCTAL_LITERAL=156;
	public const int OCT_DIGIT=157;
	public const int PACKAGE=158;
	public const int PACKAGE_DECL=159;
	public const int PARAM=160;
	public const int PARAMS=161;
	public const int PARAM_DECL=162;
	public const int PARAM_LIST=163;
	public const int PARAM_REST_DECL=164;
	public const int PLUS=165;
	public const int PLUS_ASSIGN=166;
	public const int POST_DEC=167;
	public const int POST_INC=168;
	public const int PRE_DEC=169;
	public const int PRE_INC=170;
	public const int PRIMARY_EXPRESSION=171;
	public const int PRIVATE=172;
	public const int PROP_ACCESS=173;
	public const int PROP_OR_IDENT=174;
	public const int PROTECTED=175;
	public const int PUBLIC=176;
	public const int QUALIFIED_NAME=177;
	public const int QUESTION=178;
	public const int RBRACK=179;
	public const int RCURLY=180;
	public const int REGEX=181;
	public const int REGEX_BODY=182;
	public const int REGEX_LITERAL=183;
	public const int REGEX_POSTFIX=184;
	public const int REST=185;
	public const int RETURN=186;
	public const int RETURN_STATEMENT=187;
	public const int RPAREN=188;
	public const int SEMI=189;
	public const int SET=190;
	public const int SL=191;
	public const int SL_ASSIGN=192;
	public const int SL_COMMENT=193;
	public const int SR=194;
	public const int SR_ASSIGN=195;
	public const int STAR=196;
	public const int STAR_ASSIGN=197;
	public const int STATEMENT=198;
	public const int STATEMENT_BLOCK=199;
	public const int STATIC=200;
	public const int STRICT_EQUAL=201;
	public const int STRICT_NOT_EQUAL=202;
	public const int STRING_LITERAL_DOUBLE=203;
	public const int STRING_LITERAL_SINGLE=204;
	public const int SUPER=205;
	public const int SWITCH=206;
	public const int SWITCH_BLOCK=207;
	public const int SWITCH_STATEMENT=208;
	public const int SWITCH_STATEMENT_LIST=209;
	public const int THROW=210;
	public const int THROW_STATEMENT=211;
	public const int TRUE=212;
	public const int TRY_STATEMENT=213;
	public const int TYPE_BLOCK=214;
	public const int TYPE_SPEC=215;
	public const int UNARY_MINUS=216;
	public const int UNARY_PLUS=217;
	public const int UNICODE_ESC=218;
	public const int USE=219;
	public const int VAR=220;
	public const int VARIABLE_DECLARATOR=221;
	public const int VARIABLE_DEF=222;
	public const int VAR_DEC=223;
	public const int VAR_DECLARATION=224;
	public const int VAR_INIT=225;
	public const int VAR_INITIALIZER=226;
	public const int WHILE=227;
	public const int WHILE_LOOP=228;
	public const int WITH=229;
	public const int WS=230;
	public const int XML=231;
	public const int XML_AS3_EXPRESSION=232;
	public const int XML_ATTRIBUTE=233;
	public const int XML_BINDING=234;
	public const int XML_CDATA=235;
	public const int XML_COMMENT=236;
	public const int XML_LITERAL=237;
	public const int XML_SUBTREE=238;
	public const int XML_TEXTNODE=239;
	public const int XML_WS=240;
	public const int T__241=241;
	public const int T__242=242;
	public const int T__243=243;
	public const int T__244=244;
	public const int T__245=245;
	public const int T__246=246;
	public const int T__247=247;
	public const int T__248=248;
	public const int T__249=249;
	public const int T__250=250;
	public const int T__251=251;
	public const int T__252=252;
	public const int T__253=253;
	public const int T__254=254;
	public const int T__255=255;
	public const int T__256=256;
	public const int T__257=257;

	            private IToken lastToken;

	            public IToken nextToken() {
	                CommonToken t = (CommonToken)base.NextToken();
	                if(t.Channel != Hidden){
	                    lastToken = t;
	                }
	                return t;
	            }

	            private bool constantIsOk() {
	                int type = lastToken.Type;
	                return type == ASSIGN || type == LPAREN || type == LBRACK || 
	                    type == RETURN || type == COLON || type == LNOT || type == LT || 
	                    type == GT || type == EQUAL || type == COMMA;
	            }


	// delegates
	// delegators

	public AS3Lexer()
	{
		OnCreated();
	}

	public AS3Lexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public AS3Lexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "AS3.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_T__241();
	partial void LeaveRule_T__241();

	// $ANTLR start "T__241"
	[GrammarRule("T__241")]
	private void mT__241()
	{
		EnterRule_T__241();
		EnterRule("T__241", 1);
		TraceIn("T__241", 1);
		try
		{
			int _type = T__241;
			int _channel = DefaultTokenChannel;
			// AS3.g:26:8: ( 'and' )
			DebugEnterAlt(1);
			// AS3.g:26:10: 'and'
			{
			DebugLocation(26, 10);
			Match("and"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__241", 1);
			LeaveRule("T__241", 1);
			LeaveRule_T__241();
		}
	}
	// $ANTLR end "T__241"

	partial void EnterRule_T__242();
	partial void LeaveRule_T__242();

	// $ANTLR start "T__242"
	[GrammarRule("T__242")]
	private void mT__242()
	{
		EnterRule_T__242();
		EnterRule("T__242", 2);
		TraceIn("T__242", 2);
		try
		{
			int _type = T__242;
			int _channel = DefaultTokenChannel;
			// AS3.g:27:8: ( 'catch' )
			DebugEnterAlt(1);
			// AS3.g:27:10: 'catch'
			{
			DebugLocation(27, 10);
			Match("catch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__242", 2);
			LeaveRule("T__242", 2);
			LeaveRule_T__242();
		}
	}
	// $ANTLR end "T__242"

	partial void EnterRule_T__243();
	partial void LeaveRule_T__243();

	// $ANTLR start "T__243"
	[GrammarRule("T__243")]
	private void mT__243()
	{
		EnterRule_T__243();
		EnterRule("T__243", 3);
		TraceIn("T__243", 3);
		try
		{
			int _type = T__243;
			int _channel = DefaultTokenChannel;
			// AS3.g:28:8: ( 'delete' )
			DebugEnterAlt(1);
			// AS3.g:28:10: 'delete'
			{
			DebugLocation(28, 10);
			Match("delete"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__243", 3);
			LeaveRule("T__243", 3);
			LeaveRule_T__243();
		}
	}
	// $ANTLR end "T__243"

	partial void EnterRule_T__244();
	partial void LeaveRule_T__244();

	// $ANTLR start "T__244"
	[GrammarRule("T__244")]
	private void mT__244()
	{
		EnterRule_T__244();
		EnterRule("T__244", 4);
		TraceIn("T__244", 4);
		try
		{
			int _type = T__244;
			int _channel = DefaultTokenChannel;
			// AS3.g:29:8: ( 'enumerable' )
			DebugEnterAlt(1);
			// AS3.g:29:10: 'enumerable'
			{
			DebugLocation(29, 10);
			Match("enumerable"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__244", 4);
			LeaveRule("T__244", 4);
			LeaveRule_T__244();
		}
	}
	// $ANTLR end "T__244"

	partial void EnterRule_T__245();
	partial void LeaveRule_T__245();

	// $ANTLR start "T__245"
	[GrammarRule("T__245")]
	private void mT__245()
	{
		EnterRule_T__245();
		EnterRule("T__245", 5);
		TraceIn("T__245", 5);
		try
		{
			int _type = T__245;
			int _channel = DefaultTokenChannel;
			// AS3.g:30:8: ( 'explicit' )
			DebugEnterAlt(1);
			// AS3.g:30:10: 'explicit'
			{
			DebugLocation(30, 10);
			Match("explicit"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__245", 5);
			LeaveRule("T__245", 5);
			LeaveRule_T__245();
		}
	}
	// $ANTLR end "T__245"

	partial void EnterRule_T__246();
	partial void LeaveRule_T__246();

	// $ANTLR start "T__246"
	[GrammarRule("T__246")]
	private void mT__246()
	{
		EnterRule_T__246();
		EnterRule("T__246", 6);
		TraceIn("T__246", 6);
		try
		{
			int _type = T__246;
			int _channel = DefaultTokenChannel;
			// AS3.g:31:8: ( 'final' )
			DebugEnterAlt(1);
			// AS3.g:31:10: 'final'
			{
			DebugLocation(31, 10);
			Match("final"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__246", 6);
			LeaveRule("T__246", 6);
			LeaveRule_T__246();
		}
	}
	// $ANTLR end "T__246"

	partial void EnterRule_T__247();
	partial void LeaveRule_T__247();

	// $ANTLR start "T__247"
	[GrammarRule("T__247")]
	private void mT__247()
	{
		EnterRule_T__247();
		EnterRule("T__247", 7);
		TraceIn("T__247", 7);
		try
		{
			int _type = T__247;
			int _channel = DefaultTokenChannel;
			// AS3.g:32:8: ( 'finally' )
			DebugEnterAlt(1);
			// AS3.g:32:10: 'finally'
			{
			DebugLocation(32, 10);
			Match("finally"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__247", 7);
			LeaveRule("T__247", 7);
			LeaveRule_T__247();
		}
	}
	// $ANTLR end "T__247"

	partial void EnterRule_T__248();
	partial void LeaveRule_T__248();

	// $ANTLR start "T__248"
	[GrammarRule("T__248")]
	private void mT__248()
	{
		EnterRule_T__248();
		EnterRule("T__248", 8);
		TraceIn("T__248", 8);
		try
		{
			int _type = T__248;
			int _channel = DefaultTokenChannel;
			// AS3.g:33:8: ( 'include' )
			DebugEnterAlt(1);
			// AS3.g:33:10: 'include'
			{
			DebugLocation(33, 10);
			Match("include"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__248", 8);
			LeaveRule("T__248", 8);
			LeaveRule_T__248();
		}
	}
	// $ANTLR end "T__248"

	partial void EnterRule_T__249();
	partial void LeaveRule_T__249();

	// $ANTLR start "T__249"
	[GrammarRule("T__249")]
	private void mT__249()
	{
		EnterRule_T__249();
		EnterRule("T__249", 9);
		TraceIn("T__249", 9);
		try
		{
			int _type = T__249;
			int _channel = DefaultTokenChannel;
			// AS3.g:34:8: ( 'instanceof' )
			DebugEnterAlt(1);
			// AS3.g:34:10: 'instanceof'
			{
			DebugLocation(34, 10);
			Match("instanceof"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__249", 9);
			LeaveRule("T__249", 9);
			LeaveRule_T__249();
		}
	}
	// $ANTLR end "T__249"

	partial void EnterRule_T__250();
	partial void LeaveRule_T__250();

	// $ANTLR start "T__250"
	[GrammarRule("T__250")]
	private void mT__250()
	{
		EnterRule_T__250();
		EnterRule("T__250", 10);
		TraceIn("T__250", 10);
		try
		{
			int _type = T__250;
			int _channel = DefaultTokenChannel;
			// AS3.g:35:8: ( 'intrinsic' )
			DebugEnterAlt(1);
			// AS3.g:35:10: 'intrinsic'
			{
			DebugLocation(35, 10);
			Match("intrinsic"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__250", 10);
			LeaveRule("T__250", 10);
			LeaveRule_T__250();
		}
	}
	// $ANTLR end "T__250"

	partial void EnterRule_T__251();
	partial void LeaveRule_T__251();

	// $ANTLR start "T__251"
	[GrammarRule("T__251")]
	private void mT__251()
	{
		EnterRule_T__251();
		EnterRule("T__251", 11);
		TraceIn("T__251", 11);
		try
		{
			int _type = T__251;
			int _channel = DefaultTokenChannel;
			// AS3.g:36:8: ( 'or' )
			DebugEnterAlt(1);
			// AS3.g:36:10: 'or'
			{
			DebugLocation(36, 10);
			Match("or"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__251", 11);
			LeaveRule("T__251", 11);
			LeaveRule_T__251();
		}
	}
	// $ANTLR end "T__251"

	partial void EnterRule_T__252();
	partial void LeaveRule_T__252();

	// $ANTLR start "T__252"
	[GrammarRule("T__252")]
	private void mT__252()
	{
		EnterRule_T__252();
		EnterRule("T__252", 12);
		TraceIn("T__252", 12);
		try
		{
			int _type = T__252;
			int _channel = DefaultTokenChannel;
			// AS3.g:37:8: ( 'override' )
			DebugEnterAlt(1);
			// AS3.g:37:10: 'override'
			{
			DebugLocation(37, 10);
			Match("override"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__252", 12);
			LeaveRule("T__252", 12);
			LeaveRule_T__252();
		}
	}
	// $ANTLR end "T__252"

	partial void EnterRule_T__253();
	partial void LeaveRule_T__253();

	// $ANTLR start "T__253"
	[GrammarRule("T__253")]
	private void mT__253()
	{
		EnterRule_T__253();
		EnterRule("T__253", 13);
		TraceIn("T__253", 13);
		try
		{
			int _type = T__253;
			int _channel = DefaultTokenChannel;
			// AS3.g:38:8: ( 'throw' )
			DebugEnterAlt(1);
			// AS3.g:38:10: 'throw'
			{
			DebugLocation(38, 10);
			Match("throw"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__253", 13);
			LeaveRule("T__253", 13);
			LeaveRule_T__253();
		}
	}
	// $ANTLR end "T__253"

	partial void EnterRule_T__254();
	partial void LeaveRule_T__254();

	// $ANTLR start "T__254"
	[GrammarRule("T__254")]
	private void mT__254()
	{
		EnterRule_T__254();
		EnterRule("T__254", 14);
		TraceIn("T__254", 14);
		try
		{
			int _type = T__254;
			int _channel = DefaultTokenChannel;
			// AS3.g:39:8: ( 'try' )
			DebugEnterAlt(1);
			// AS3.g:39:10: 'try'
			{
			DebugLocation(39, 10);
			Match("try"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__254", 14);
			LeaveRule("T__254", 14);
			LeaveRule_T__254();
		}
	}
	// $ANTLR end "T__254"

	partial void EnterRule_T__255();
	partial void LeaveRule_T__255();

	// $ANTLR start "T__255"
	[GrammarRule("T__255")]
	private void mT__255()
	{
		EnterRule_T__255();
		EnterRule("T__255", 15);
		TraceIn("T__255", 15);
		try
		{
			int _type = T__255;
			int _channel = DefaultTokenChannel;
			// AS3.g:40:8: ( 'typeof' )
			DebugEnterAlt(1);
			// AS3.g:40:10: 'typeof'
			{
			DebugLocation(40, 10);
			Match("typeof"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__255", 15);
			LeaveRule("T__255", 15);
			LeaveRule_T__255();
		}
	}
	// $ANTLR end "T__255"

	partial void EnterRule_T__256();
	partial void LeaveRule_T__256();

	// $ANTLR start "T__256"
	[GrammarRule("T__256")]
	private void mT__256()
	{
		EnterRule_T__256();
		EnterRule("T__256", 16);
		TraceIn("T__256", 16);
		try
		{
			int _type = T__256;
			int _channel = DefaultTokenChannel;
			// AS3.g:41:8: ( 'undefined' )
			DebugEnterAlt(1);
			// AS3.g:41:10: 'undefined'
			{
			DebugLocation(41, 10);
			Match("undefined"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__256", 16);
			LeaveRule("T__256", 16);
			LeaveRule_T__256();
		}
	}
	// $ANTLR end "T__256"

	partial void EnterRule_T__257();
	partial void LeaveRule_T__257();

	// $ANTLR start "T__257"
	[GrammarRule("T__257")]
	private void mT__257()
	{
		EnterRule_T__257();
		EnterRule("T__257", 17);
		TraceIn("T__257", 17);
		try
		{
			int _type = T__257;
			int _channel = DefaultTokenChannel;
			// AS3.g:42:8: ( 'void' )
			DebugEnterAlt(1);
			// AS3.g:42:10: 'void'
			{
			DebugLocation(42, 10);
			Match("void"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("T__257", 17);
			LeaveRule("T__257", 17);
			LeaveRule_T__257();
		}
	}
	// $ANTLR end "T__257"

	partial void EnterRule_PACKAGE();
	partial void LeaveRule_PACKAGE();

	// $ANTLR start "PACKAGE"
	[GrammarRule("PACKAGE")]
	private void mPACKAGE()
	{
		EnterRule_PACKAGE();
		EnterRule("PACKAGE", 18);
		TraceIn("PACKAGE", 18);
		try
		{
			int _type = PACKAGE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1036:10: ( 'package' )
			DebugEnterAlt(1);
			// AS3.g:1036:12: 'package'
			{
			DebugLocation(1036, 12);
			Match("package"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PACKAGE", 18);
			LeaveRule("PACKAGE", 18);
			LeaveRule_PACKAGE();
		}
	}
	// $ANTLR end "PACKAGE"

	partial void EnterRule_PUBLIC();
	partial void LeaveRule_PUBLIC();

	// $ANTLR start "PUBLIC"
	[GrammarRule("PUBLIC")]
	private void mPUBLIC()
	{
		EnterRule_PUBLIC();
		EnterRule("PUBLIC", 19);
		TraceIn("PUBLIC", 19);
		try
		{
			int _type = PUBLIC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1037:9: ( 'public' )
			DebugEnterAlt(1);
			// AS3.g:1037:11: 'public'
			{
			DebugLocation(1037, 11);
			Match("public"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PUBLIC", 19);
			LeaveRule("PUBLIC", 19);
			LeaveRule_PUBLIC();
		}
	}
	// $ANTLR end "PUBLIC"

	partial void EnterRule_PRIVATE();
	partial void LeaveRule_PRIVATE();

	// $ANTLR start "PRIVATE"
	[GrammarRule("PRIVATE")]
	private void mPRIVATE()
	{
		EnterRule_PRIVATE();
		EnterRule("PRIVATE", 20);
		TraceIn("PRIVATE", 20);
		try
		{
			int _type = PRIVATE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1038:10: ( 'private' )
			DebugEnterAlt(1);
			// AS3.g:1038:12: 'private'
			{
			DebugLocation(1038, 12);
			Match("private"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PRIVATE", 20);
			LeaveRule("PRIVATE", 20);
			LeaveRule_PRIVATE();
		}
	}
	// $ANTLR end "PRIVATE"

	partial void EnterRule_PROTECTED();
	partial void LeaveRule_PROTECTED();

	// $ANTLR start "PROTECTED"
	[GrammarRule("PROTECTED")]
	private void mPROTECTED()
	{
		EnterRule_PROTECTED();
		EnterRule("PROTECTED", 21);
		TraceIn("PROTECTED", 21);
		try
		{
			int _type = PROTECTED;
			int _channel = DefaultTokenChannel;
			// AS3.g:1039:11: ( 'protected' )
			DebugEnterAlt(1);
			// AS3.g:1039:13: 'protected'
			{
			DebugLocation(1039, 13);
			Match("protected"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PROTECTED", 21);
			LeaveRule("PROTECTED", 21);
			LeaveRule_PROTECTED();
		}
	}
	// $ANTLR end "PROTECTED"

	partial void EnterRule_INTERNAL();
	partial void LeaveRule_INTERNAL();

	// $ANTLR start "INTERNAL"
	[GrammarRule("INTERNAL")]
	private void mINTERNAL()
	{
		EnterRule_INTERNAL();
		EnterRule("INTERNAL", 22);
		TraceIn("INTERNAL", 22);
		try
		{
			int _type = INTERNAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1040:10: ( 'internal' )
			DebugEnterAlt(1);
			// AS3.g:1040:12: 'internal'
			{
			DebugLocation(1040, 12);
			Match("internal"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INTERNAL", 22);
			LeaveRule("INTERNAL", 22);
			LeaveRule_INTERNAL();
		}
	}
	// $ANTLR end "INTERNAL"

	partial void EnterRule_FUNCTION();
	partial void LeaveRule_FUNCTION();

	// $ANTLR start "FUNCTION"
	[GrammarRule("FUNCTION")]
	private void mFUNCTION()
	{
		EnterRule_FUNCTION();
		EnterRule("FUNCTION", 23);
		TraceIn("FUNCTION", 23);
		try
		{
			int _type = FUNCTION;
			int _channel = DefaultTokenChannel;
			// AS3.g:1041:10: ( 'function' )
			DebugEnterAlt(1);
			// AS3.g:1041:12: 'function'
			{
			DebugLocation(1041, 12);
			Match("function"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FUNCTION", 23);
			LeaveRule("FUNCTION", 23);
			LeaveRule_FUNCTION();
		}
	}
	// $ANTLR end "FUNCTION"

	partial void EnterRule_EXTENDS();
	partial void LeaveRule_EXTENDS();

	// $ANTLR start "EXTENDS"
	[GrammarRule("EXTENDS")]
	private void mEXTENDS()
	{
		EnterRule_EXTENDS();
		EnterRule("EXTENDS", 24);
		TraceIn("EXTENDS", 24);
		try
		{
			int _type = EXTENDS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1042:10: ( 'extends' )
			DebugEnterAlt(1);
			// AS3.g:1042:12: 'extends'
			{
			DebugLocation(1042, 12);
			Match("extends"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXTENDS", 24);
			LeaveRule("EXTENDS", 24);
			LeaveRule_EXTENDS();
		}
	}
	// $ANTLR end "EXTENDS"

	partial void EnterRule_IMPLEMENTS();
	partial void LeaveRule_IMPLEMENTS();

	// $ANTLR start "IMPLEMENTS"
	[GrammarRule("IMPLEMENTS")]
	private void mIMPLEMENTS()
	{
		EnterRule_IMPLEMENTS();
		EnterRule("IMPLEMENTS", 25);
		TraceIn("IMPLEMENTS", 25);
		try
		{
			int _type = IMPLEMENTS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1043:12: ( 'implements' )
			DebugEnterAlt(1);
			// AS3.g:1043:14: 'implements'
			{
			DebugLocation(1043, 14);
			Match("implements"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IMPLEMENTS", 25);
			LeaveRule("IMPLEMENTS", 25);
			LeaveRule_IMPLEMENTS();
		}
	}
	// $ANTLR end "IMPLEMENTS"

	partial void EnterRule_VAR();
	partial void LeaveRule_VAR();

	// $ANTLR start "VAR"
	[GrammarRule("VAR")]
	private void mVAR()
	{
		EnterRule_VAR();
		EnterRule("VAR", 26);
		TraceIn("VAR", 26);
		try
		{
			int _type = VAR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1044:6: ( 'var' )
			DebugEnterAlt(1);
			// AS3.g:1044:8: 'var'
			{
			DebugLocation(1044, 8);
			Match("var"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("VAR", 26);
			LeaveRule("VAR", 26);
			LeaveRule_VAR();
		}
	}
	// $ANTLR end "VAR"

	partial void EnterRule_STATIC();
	partial void LeaveRule_STATIC();

	// $ANTLR start "STATIC"
	[GrammarRule("STATIC")]
	private void mSTATIC()
	{
		EnterRule_STATIC();
		EnterRule("STATIC", 27);
		TraceIn("STATIC", 27);
		try
		{
			int _type = STATIC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1045:9: ( 'static' )
			DebugEnterAlt(1);
			// AS3.g:1045:11: 'static'
			{
			DebugLocation(1045, 11);
			Match("static"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STATIC", 27);
			LeaveRule("STATIC", 27);
			LeaveRule_STATIC();
		}
	}
	// $ANTLR end "STATIC"

	partial void EnterRule_IF();
	partial void LeaveRule_IF();

	// $ANTLR start "IF"
	[GrammarRule("IF")]
	private void mIF()
	{
		EnterRule_IF();
		EnterRule("IF", 28);
		TraceIn("IF", 28);
		try
		{
			int _type = IF;
			int _channel = DefaultTokenChannel;
			// AS3.g:1046:5: ( 'if' )
			DebugEnterAlt(1);
			// AS3.g:1046:7: 'if'
			{
			DebugLocation(1046, 7);
			Match("if"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IF", 28);
			LeaveRule("IF", 28);
			LeaveRule_IF();
		}
	}
	// $ANTLR end "IF"

	partial void EnterRule_IMPORT();
	partial void LeaveRule_IMPORT();

	// $ANTLR start "IMPORT"
	[GrammarRule("IMPORT")]
	private void mIMPORT()
	{
		EnterRule_IMPORT();
		EnterRule("IMPORT", 29);
		TraceIn("IMPORT", 29);
		try
		{
			int _type = IMPORT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1047:9: ( 'import' )
			DebugEnterAlt(1);
			// AS3.g:1047:11: 'import'
			{
			DebugLocation(1047, 11);
			Match("import"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IMPORT", 29);
			LeaveRule("IMPORT", 29);
			LeaveRule_IMPORT();
		}
	}
	// $ANTLR end "IMPORT"

	partial void EnterRule_FOR();
	partial void LeaveRule_FOR();

	// $ANTLR start "FOR"
	[GrammarRule("FOR")]
	private void mFOR()
	{
		EnterRule_FOR();
		EnterRule("FOR", 30);
		TraceIn("FOR", 30);
		try
		{
			int _type = FOR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1048:6: ( 'for' )
			DebugEnterAlt(1);
			// AS3.g:1048:8: 'for'
			{
			DebugLocation(1048, 8);
			Match("for"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FOR", 30);
			LeaveRule("FOR", 30);
			LeaveRule_FOR();
		}
	}
	// $ANTLR end "FOR"

	partial void EnterRule_EACH();
	partial void LeaveRule_EACH();

	// $ANTLR start "EACH"
	[GrammarRule("EACH")]
	private void mEACH()
	{
		EnterRule_EACH();
		EnterRule("EACH", 31);
		TraceIn("EACH", 31);
		try
		{
			int _type = EACH;
			int _channel = DefaultTokenChannel;
			// AS3.g:1049:7: ( 'each' )
			DebugEnterAlt(1);
			// AS3.g:1049:9: 'each'
			{
			DebugLocation(1049, 9);
			Match("each"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EACH", 31);
			LeaveRule("EACH", 31);
			LeaveRule_EACH();
		}
	}
	// $ANTLR end "EACH"

	partial void EnterRule_IN();
	partial void LeaveRule_IN();

	// $ANTLR start "IN"
	[GrammarRule("IN")]
	private void mIN()
	{
		EnterRule_IN();
		EnterRule("IN", 32);
		TraceIn("IN", 32);
		try
		{
			int _type = IN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1050:5: ( 'in' )
			DebugEnterAlt(1);
			// AS3.g:1050:7: 'in'
			{
			DebugLocation(1050, 7);
			Match("in"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IN", 32);
			LeaveRule("IN", 32);
			LeaveRule_IN();
		}
	}
	// $ANTLR end "IN"

	partial void EnterRule_WHILE();
	partial void LeaveRule_WHILE();

	// $ANTLR start "WHILE"
	[GrammarRule("WHILE")]
	private void mWHILE()
	{
		EnterRule_WHILE();
		EnterRule("WHILE", 33);
		TraceIn("WHILE", 33);
		try
		{
			int _type = WHILE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1051:8: ( 'while' )
			DebugEnterAlt(1);
			// AS3.g:1051:10: 'while'
			{
			DebugLocation(1051, 10);
			Match("while"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHILE", 33);
			LeaveRule("WHILE", 33);
			LeaveRule_WHILE();
		}
	}
	// $ANTLR end "WHILE"

	partial void EnterRule_DO();
	partial void LeaveRule_DO();

	// $ANTLR start "DO"
	[GrammarRule("DO")]
	private void mDO()
	{
		EnterRule_DO();
		EnterRule("DO", 34);
		TraceIn("DO", 34);
		try
		{
			int _type = DO;
			int _channel = DefaultTokenChannel;
			// AS3.g:1052:5: ( 'do' )
			DebugEnterAlt(1);
			// AS3.g:1052:7: 'do'
			{
			DebugLocation(1052, 7);
			Match("do"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DO", 34);
			LeaveRule("DO", 34);
			LeaveRule_DO();
		}
	}
	// $ANTLR end "DO"

	partial void EnterRule_SWITCH();
	partial void LeaveRule_SWITCH();

	// $ANTLR start "SWITCH"
	[GrammarRule("SWITCH")]
	private void mSWITCH()
	{
		EnterRule_SWITCH();
		EnterRule("SWITCH", 35);
		TraceIn("SWITCH", 35);
		try
		{
			int _type = SWITCH;
			int _channel = DefaultTokenChannel;
			// AS3.g:1053:9: ( 'switch' )
			DebugEnterAlt(1);
			// AS3.g:1053:11: 'switch'
			{
			DebugLocation(1053, 11);
			Match("switch"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SWITCH", 35);
			LeaveRule("SWITCH", 35);
			LeaveRule_SWITCH();
		}
	}
	// $ANTLR end "SWITCH"

	partial void EnterRule_CASE();
	partial void LeaveRule_CASE();

	// $ANTLR start "CASE"
	[GrammarRule("CASE")]
	private void mCASE()
	{
		EnterRule_CASE();
		EnterRule("CASE", 36);
		TraceIn("CASE", 36);
		try
		{
			int _type = CASE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1054:7: ( 'case' )
			DebugEnterAlt(1);
			// AS3.g:1054:9: 'case'
			{
			DebugLocation(1054, 9);
			Match("case"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CASE", 36);
			LeaveRule("CASE", 36);
			LeaveRule_CASE();
		}
	}
	// $ANTLR end "CASE"

	partial void EnterRule_DEFAULT();
	partial void LeaveRule_DEFAULT();

	// $ANTLR start "DEFAULT"
	[GrammarRule("DEFAULT")]
	private void mDEFAULT()
	{
		EnterRule_DEFAULT();
		EnterRule("DEFAULT", 37);
		TraceIn("DEFAULT", 37);
		try
		{
			int _type = DEFAULT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1055:10: ( 'default' )
			DebugEnterAlt(1);
			// AS3.g:1055:12: 'default'
			{
			DebugLocation(1055, 12);
			Match("default"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEFAULT", 37);
			LeaveRule("DEFAULT", 37);
			LeaveRule_DEFAULT();
		}
	}
	// $ANTLR end "DEFAULT"

	partial void EnterRule_ELSE();
	partial void LeaveRule_ELSE();

	// $ANTLR start "ELSE"
	[GrammarRule("ELSE")]
	private void mELSE()
	{
		EnterRule_ELSE();
		EnterRule("ELSE", 38);
		TraceIn("ELSE", 38);
		try
		{
			int _type = ELSE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1056:7: ( 'else' )
			DebugEnterAlt(1);
			// AS3.g:1056:9: 'else'
			{
			DebugLocation(1056, 9);
			Match("else"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ELSE", 38);
			LeaveRule("ELSE", 38);
			LeaveRule_ELSE();
		}
	}
	// $ANTLR end "ELSE"

	partial void EnterRule_CONST();
	partial void LeaveRule_CONST();

	// $ANTLR start "CONST"
	[GrammarRule("CONST")]
	private void mCONST()
	{
		EnterRule_CONST();
		EnterRule("CONST", 39);
		TraceIn("CONST", 39);
		try
		{
			int _type = CONST;
			int _channel = DefaultTokenChannel;
			// AS3.g:1057:8: ( 'const' )
			DebugEnterAlt(1);
			// AS3.g:1057:10: 'const'
			{
			DebugLocation(1057, 10);
			Match("const"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONST", 39);
			LeaveRule("CONST", 39);
			LeaveRule_CONST();
		}
	}
	// $ANTLR end "CONST"

	partial void EnterRule_CLASS();
	partial void LeaveRule_CLASS();

	// $ANTLR start "CLASS"
	[GrammarRule("CLASS")]
	private void mCLASS()
	{
		EnterRule_CLASS();
		EnterRule("CLASS", 40);
		TraceIn("CLASS", 40);
		try
		{
			int _type = CLASS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1058:8: ( 'class' )
			DebugEnterAlt(1);
			// AS3.g:1058:10: 'class'
			{
			DebugLocation(1058, 10);
			Match("class"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CLASS", 40);
			LeaveRule("CLASS", 40);
			LeaveRule_CLASS();
		}
	}
	// $ANTLR end "CLASS"

	partial void EnterRule_INTERFACE();
	partial void LeaveRule_INTERFACE();

	// $ANTLR start "INTERFACE"
	[GrammarRule("INTERFACE")]
	private void mINTERFACE()
	{
		EnterRule_INTERFACE();
		EnterRule("INTERFACE", 41);
		TraceIn("INTERFACE", 41);
		try
		{
			int _type = INTERFACE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1059:11: ( 'interface' )
			DebugEnterAlt(1);
			// AS3.g:1059:13: 'interface'
			{
			DebugLocation(1059, 13);
			Match("interface"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INTERFACE", 41);
			LeaveRule("INTERFACE", 41);
			LeaveRule_INTERFACE();
		}
	}
	// $ANTLR end "INTERFACE"

	partial void EnterRule_TRUE();
	partial void LeaveRule_TRUE();

	// $ANTLR start "TRUE"
	[GrammarRule("TRUE")]
	private void mTRUE()
	{
		EnterRule_TRUE();
		EnterRule("TRUE", 42);
		TraceIn("TRUE", 42);
		try
		{
			int _type = TRUE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1060:7: ( 'true' )
			DebugEnterAlt(1);
			// AS3.g:1060:9: 'true'
			{
			DebugLocation(1060, 9);
			Match("true"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("TRUE", 42);
			LeaveRule("TRUE", 42);
			LeaveRule_TRUE();
		}
	}
	// $ANTLR end "TRUE"

	partial void EnterRule_FALSE();
	partial void LeaveRule_FALSE();

	// $ANTLR start "FALSE"
	[GrammarRule("FALSE")]
	private void mFALSE()
	{
		EnterRule_FALSE();
		EnterRule("FALSE", 43);
		TraceIn("FALSE", 43);
		try
		{
			int _type = FALSE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1061:8: ( 'false' )
			DebugEnterAlt(1);
			// AS3.g:1061:10: 'false'
			{
			DebugLocation(1061, 10);
			Match("false"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FALSE", 43);
			LeaveRule("FALSE", 43);
			LeaveRule_FALSE();
		}
	}
	// $ANTLR end "FALSE"

	partial void EnterRule_DYNAMIC();
	partial void LeaveRule_DYNAMIC();

	// $ANTLR start "DYNAMIC"
	[GrammarRule("DYNAMIC")]
	private void mDYNAMIC()
	{
		EnterRule_DYNAMIC();
		EnterRule("DYNAMIC", 44);
		TraceIn("DYNAMIC", 44);
		try
		{
			int _type = DYNAMIC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1062:10: ( 'dynamic' )
			DebugEnterAlt(1);
			// AS3.g:1062:12: 'dynamic'
			{
			DebugLocation(1062, 12);
			Match("dynamic"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DYNAMIC", 44);
			LeaveRule("DYNAMIC", 44);
			LeaveRule_DYNAMIC();
		}
	}
	// $ANTLR end "DYNAMIC"

	partial void EnterRule_USE();
	partial void LeaveRule_USE();

	// $ANTLR start "USE"
	[GrammarRule("USE")]
	private void mUSE()
	{
		EnterRule_USE();
		EnterRule("USE", 45);
		TraceIn("USE", 45);
		try
		{
			int _type = USE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1063:6: ( 'use' )
			DebugEnterAlt(1);
			// AS3.g:1063:8: 'use'
			{
			DebugLocation(1063, 8);
			Match("use"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("USE", 45);
			LeaveRule("USE", 45);
			LeaveRule_USE();
		}
	}
	// $ANTLR end "USE"

	partial void EnterRule_XML();
	partial void LeaveRule_XML();

	// $ANTLR start "XML"
	[GrammarRule("XML")]
	private void mXML()
	{
		EnterRule_XML();
		EnterRule("XML", 46);
		TraceIn("XML", 46);
		try
		{
			int _type = XML;
			int _channel = DefaultTokenChannel;
			// AS3.g:1064:6: ( 'xml' )
			DebugEnterAlt(1);
			// AS3.g:1064:8: 'xml'
			{
			DebugLocation(1064, 8);
			Match("xml"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("XML", 46);
			LeaveRule("XML", 46);
			LeaveRule_XML();
		}
	}
	// $ANTLR end "XML"

	partial void EnterRule_NAMESPACE();
	partial void LeaveRule_NAMESPACE();

	// $ANTLR start "NAMESPACE"
	[GrammarRule("NAMESPACE")]
	private void mNAMESPACE()
	{
		EnterRule_NAMESPACE();
		EnterRule("NAMESPACE", 47);
		TraceIn("NAMESPACE", 47);
		try
		{
			int _type = NAMESPACE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1065:11: ( 'namespace' )
			DebugEnterAlt(1);
			// AS3.g:1065:13: 'namespace'
			{
			DebugLocation(1065, 13);
			Match("namespace"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NAMESPACE", 47);
			LeaveRule("NAMESPACE", 47);
			LeaveRule_NAMESPACE();
		}
	}
	// $ANTLR end "NAMESPACE"

	partial void EnterRule_IS();
	partial void LeaveRule_IS();

	// $ANTLR start "IS"
	[GrammarRule("IS")]
	private void mIS()
	{
		EnterRule_IS();
		EnterRule("IS", 48);
		TraceIn("IS", 48);
		try
		{
			int _type = IS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1066:5: ( 'is' )
			DebugEnterAlt(1);
			// AS3.g:1066:7: 'is'
			{
			DebugLocation(1066, 7);
			Match("is"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IS", 48);
			LeaveRule("IS", 48);
			LeaveRule_IS();
		}
	}
	// $ANTLR end "IS"

	partial void EnterRule_AS();
	partial void LeaveRule_AS();

	// $ANTLR start "AS"
	[GrammarRule("AS")]
	private void mAS()
	{
		EnterRule_AS();
		EnterRule("AS", 49);
		TraceIn("AS", 49);
		try
		{
			int _type = AS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1067:5: ( 'as' )
			DebugEnterAlt(1);
			// AS3.g:1067:7: 'as'
			{
			DebugLocation(1067, 7);
			Match("as"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("AS", 49);
			LeaveRule("AS", 49);
			LeaveRule_AS();
		}
	}
	// $ANTLR end "AS"

	partial void EnterRule_GET();
	partial void LeaveRule_GET();

	// $ANTLR start "GET"
	[GrammarRule("GET")]
	private void mGET()
	{
		EnterRule_GET();
		EnterRule("GET", 50);
		TraceIn("GET", 50);
		try
		{
			int _type = GET;
			int _channel = DefaultTokenChannel;
			// AS3.g:1068:6: ( 'get' )
			DebugEnterAlt(1);
			// AS3.g:1068:8: 'get'
			{
			DebugLocation(1068, 8);
			Match("get"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GET", 50);
			LeaveRule("GET", 50);
			LeaveRule_GET();
		}
	}
	// $ANTLR end "GET"

	partial void EnterRule_SET();
	partial void LeaveRule_SET();

	// $ANTLR start "SET"
	[GrammarRule("SET")]
	private void mSET()
	{
		EnterRule_SET();
		EnterRule("SET", 51);
		TraceIn("SET", 51);
		try
		{
			int _type = SET;
			int _channel = DefaultTokenChannel;
			// AS3.g:1069:6: ( 'set' )
			DebugEnterAlt(1);
			// AS3.g:1069:8: 'set'
			{
			DebugLocation(1069, 8);
			Match("set"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SET", 51);
			LeaveRule("SET", 51);
			LeaveRule_SET();
		}
	}
	// $ANTLR end "SET"

	partial void EnterRule_WITH();
	partial void LeaveRule_WITH();

	// $ANTLR start "WITH"
	[GrammarRule("WITH")]
	private void mWITH()
	{
		EnterRule_WITH();
		EnterRule("WITH", 52);
		TraceIn("WITH", 52);
		try
		{
			int _type = WITH;
			int _channel = DefaultTokenChannel;
			// AS3.g:1070:7: ( 'with' )
			DebugEnterAlt(1);
			// AS3.g:1070:9: 'with'
			{
			DebugLocation(1070, 9);
			Match("with"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WITH", 52);
			LeaveRule("WITH", 52);
			LeaveRule_WITH();
		}
	}
	// $ANTLR end "WITH"

	partial void EnterRule_RETURN();
	partial void LeaveRule_RETURN();

	// $ANTLR start "RETURN"
	[GrammarRule("RETURN")]
	private void mRETURN()
	{
		EnterRule_RETURN();
		EnterRule("RETURN", 53);
		TraceIn("RETURN", 53);
		try
		{
			int _type = RETURN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1071:9: ( 'return' )
			DebugEnterAlt(1);
			// AS3.g:1071:11: 'return'
			{
			DebugLocation(1071, 11);
			Match("return"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RETURN", 53);
			LeaveRule("RETURN", 53);
			LeaveRule_RETURN();
		}
	}
	// $ANTLR end "RETURN"

	partial void EnterRule_CONTINUE();
	partial void LeaveRule_CONTINUE();

	// $ANTLR start "CONTINUE"
	[GrammarRule("CONTINUE")]
	private void mCONTINUE()
	{
		EnterRule_CONTINUE();
		EnterRule("CONTINUE", 54);
		TraceIn("CONTINUE", 54);
		try
		{
			int _type = CONTINUE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1072:10: ( 'continue' )
			DebugEnterAlt(1);
			// AS3.g:1072:12: 'continue'
			{
			DebugLocation(1072, 12);
			Match("continue"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CONTINUE", 54);
			LeaveRule("CONTINUE", 54);
			LeaveRule_CONTINUE();
		}
	}
	// $ANTLR end "CONTINUE"

	partial void EnterRule_BREAK();
	partial void LeaveRule_BREAK();

	// $ANTLR start "BREAK"
	[GrammarRule("BREAK")]
	private void mBREAK()
	{
		EnterRule_BREAK();
		EnterRule("BREAK", 55);
		TraceIn("BREAK", 55);
		try
		{
			int _type = BREAK;
			int _channel = DefaultTokenChannel;
			// AS3.g:1073:8: ( 'break' )
			DebugEnterAlt(1);
			// AS3.g:1073:10: 'break'
			{
			DebugLocation(1073, 10);
			Match("break"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BREAK", 55);
			LeaveRule("BREAK", 55);
			LeaveRule_BREAK();
		}
	}
	// $ANTLR end "BREAK"

	partial void EnterRule_NULL();
	partial void LeaveRule_NULL();

	// $ANTLR start "NULL"
	[GrammarRule("NULL")]
	private void mNULL()
	{
		EnterRule_NULL();
		EnterRule("NULL", 56);
		TraceIn("NULL", 56);
		try
		{
			int _type = NULL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1074:7: ( 'null' )
			DebugEnterAlt(1);
			// AS3.g:1074:9: 'null'
			{
			DebugLocation(1074, 9);
			Match("null"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NULL", 56);
			LeaveRule("NULL", 56);
			LeaveRule_NULL();
		}
	}
	// $ANTLR end "NULL"

	partial void EnterRule_NEW();
	partial void LeaveRule_NEW();

	// $ANTLR start "NEW"
	[GrammarRule("NEW")]
	private void mNEW()
	{
		EnterRule_NEW();
		EnterRule("NEW", 57);
		TraceIn("NEW", 57);
		try
		{
			int _type = NEW;
			int _channel = DefaultTokenChannel;
			// AS3.g:1075:10: ( 'new' )
			DebugEnterAlt(1);
			// AS3.g:1075:12: 'new'
			{
			DebugLocation(1075, 12);
			Match("new"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NEW", 57);
			LeaveRule("NEW", 57);
			LeaveRule_NEW();
		}
	}
	// $ANTLR end "NEW"

	partial void EnterRule_SUPER();
	partial void LeaveRule_SUPER();

	// $ANTLR start "SUPER"
	[GrammarRule("SUPER")]
	private void mSUPER()
	{
		EnterRule_SUPER();
		EnterRule("SUPER", 58);
		TraceIn("SUPER", 58);
		try
		{
			int _type = SUPER;
			int _channel = DefaultTokenChannel;
			// AS3.g:1076:8: ( 'super' )
			DebugEnterAlt(1);
			// AS3.g:1076:10: 'super'
			{
			DebugLocation(1076, 10);
			Match("super"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SUPER", 58);
			LeaveRule("SUPER", 58);
			LeaveRule_SUPER();
		}
	}
	// $ANTLR end "SUPER"

	partial void EnterRule_QUESTION();
	partial void LeaveRule_QUESTION();

	// $ANTLR start "QUESTION"
	[GrammarRule("QUESTION")]
	private void mQUESTION()
	{
		EnterRule_QUESTION();
		EnterRule("QUESTION", 59);
		TraceIn("QUESTION", 59);
		try
		{
			int _type = QUESTION;
			int _channel = DefaultTokenChannel;
			// AS3.g:1079:11: ( '?' )
			DebugEnterAlt(1);
			// AS3.g:1079:13: '?'
			{
			DebugLocation(1079, 13);
			Match('?'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("QUESTION", 59);
			LeaveRule("QUESTION", 59);
			LeaveRule_QUESTION();
		}
	}
	// $ANTLR end "QUESTION"

	partial void EnterRule_LPAREN();
	partial void LeaveRule_LPAREN();

	// $ANTLR start "LPAREN"
	[GrammarRule("LPAREN")]
	private void mLPAREN()
	{
		EnterRule_LPAREN();
		EnterRule("LPAREN", 60);
		TraceIn("LPAREN", 60);
		try
		{
			int _type = LPAREN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1080:10: ( '(' )
			DebugEnterAlt(1);
			// AS3.g:1080:12: '('
			{
			DebugLocation(1080, 12);
			Match('('); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LPAREN", 60);
			LeaveRule("LPAREN", 60);
			LeaveRule_LPAREN();
		}
	}
	// $ANTLR end "LPAREN"

	partial void EnterRule_RPAREN();
	partial void LeaveRule_RPAREN();

	// $ANTLR start "RPAREN"
	[GrammarRule("RPAREN")]
	private void mRPAREN()
	{
		EnterRule_RPAREN();
		EnterRule("RPAREN", 61);
		TraceIn("RPAREN", 61);
		try
		{
			int _type = RPAREN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1081:10: ( ')' )
			DebugEnterAlt(1);
			// AS3.g:1081:12: ')'
			{
			DebugLocation(1081, 12);
			Match(')'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RPAREN", 61);
			LeaveRule("RPAREN", 61);
			LeaveRule_RPAREN();
		}
	}
	// $ANTLR end "RPAREN"

	partial void EnterRule_LBRACK();
	partial void LeaveRule_LBRACK();

	// $ANTLR start "LBRACK"
	[GrammarRule("LBRACK")]
	private void mLBRACK()
	{
		EnterRule_LBRACK();
		EnterRule("LBRACK", 62);
		TraceIn("LBRACK", 62);
		try
		{
			int _type = LBRACK;
			int _channel = DefaultTokenChannel;
			// AS3.g:1082:10: ( '[' )
			DebugEnterAlt(1);
			// AS3.g:1082:12: '['
			{
			DebugLocation(1082, 12);
			Match('['); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LBRACK", 62);
			LeaveRule("LBRACK", 62);
			LeaveRule_LBRACK();
		}
	}
	// $ANTLR end "LBRACK"

	partial void EnterRule_RBRACK();
	partial void LeaveRule_RBRACK();

	// $ANTLR start "RBRACK"
	[GrammarRule("RBRACK")]
	private void mRBRACK()
	{
		EnterRule_RBRACK();
		EnterRule("RBRACK", 63);
		TraceIn("RBRACK", 63);
		try
		{
			int _type = RBRACK;
			int _channel = DefaultTokenChannel;
			// AS3.g:1083:10: ( ']' )
			DebugEnterAlt(1);
			// AS3.g:1083:12: ']'
			{
			DebugLocation(1083, 12);
			Match(']'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RBRACK", 63);
			LeaveRule("RBRACK", 63);
			LeaveRule_RBRACK();
		}
	}
	// $ANTLR end "RBRACK"

	partial void EnterRule_LCURLY();
	partial void LeaveRule_LCURLY();

	// $ANTLR start "LCURLY"
	[GrammarRule("LCURLY")]
	private void mLCURLY()
	{
		EnterRule_LCURLY();
		EnterRule("LCURLY", 64);
		TraceIn("LCURLY", 64);
		try
		{
			int _type = LCURLY;
			int _channel = DefaultTokenChannel;
			// AS3.g:1084:10: ( '{' )
			DebugEnterAlt(1);
			// AS3.g:1084:12: '{'
			{
			DebugLocation(1084, 12);
			Match('{'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LCURLY", 64);
			LeaveRule("LCURLY", 64);
			LeaveRule_LCURLY();
		}
	}
	// $ANTLR end "LCURLY"

	partial void EnterRule_RCURLY();
	partial void LeaveRule_RCURLY();

	// $ANTLR start "RCURLY"
	[GrammarRule("RCURLY")]
	private void mRCURLY()
	{
		EnterRule_RCURLY();
		EnterRule("RCURLY", 65);
		TraceIn("RCURLY", 65);
		try
		{
			int _type = RCURLY;
			int _channel = DefaultTokenChannel;
			// AS3.g:1085:10: ( '}' )
			DebugEnterAlt(1);
			// AS3.g:1085:12: '}'
			{
			DebugLocation(1085, 12);
			Match('}'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("RCURLY", 65);
			LeaveRule("RCURLY", 65);
			LeaveRule_RCURLY();
		}
	}
	// $ANTLR end "RCURLY"

	partial void EnterRule_COLON();
	partial void LeaveRule_COLON();

	// $ANTLR start "COLON"
	[GrammarRule("COLON")]
	private void mCOLON()
	{
		EnterRule_COLON();
		EnterRule("COLON", 66);
		TraceIn("COLON", 66);
		try
		{
			int _type = COLON;
			int _channel = DefaultTokenChannel;
			// AS3.g:1086:9: ( ':' )
			DebugEnterAlt(1);
			// AS3.g:1086:11: ':'
			{
			DebugLocation(1086, 11);
			Match(':'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COLON", 66);
			LeaveRule("COLON", 66);
			LeaveRule_COLON();
		}
	}
	// $ANTLR end "COLON"

	partial void EnterRule_DBL_COLON();
	partial void LeaveRule_DBL_COLON();

	// $ANTLR start "DBL_COLON"
	[GrammarRule("DBL_COLON")]
	private void mDBL_COLON()
	{
		EnterRule_DBL_COLON();
		EnterRule("DBL_COLON", 67);
		TraceIn("DBL_COLON", 67);
		try
		{
			int _type = DBL_COLON;
			int _channel = DefaultTokenChannel;
			// AS3.g:1087:12: ( '::' )
			DebugEnterAlt(1);
			// AS3.g:1087:14: '::'
			{
			DebugLocation(1087, 14);
			Match("::"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DBL_COLON", 67);
			LeaveRule("DBL_COLON", 67);
			LeaveRule_DBL_COLON();
		}
	}
	// $ANTLR end "DBL_COLON"

	partial void EnterRule_COMMA();
	partial void LeaveRule_COMMA();

	// $ANTLR start "COMMA"
	[GrammarRule("COMMA")]
	private void mCOMMA()
	{
		EnterRule_COMMA();
		EnterRule("COMMA", 68);
		TraceIn("COMMA", 68);
		try
		{
			int _type = COMMA;
			int _channel = DefaultTokenChannel;
			// AS3.g:1088:9: ( ',' )
			DebugEnterAlt(1);
			// AS3.g:1088:11: ','
			{
			DebugLocation(1088, 11);
			Match(','); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("COMMA", 68);
			LeaveRule("COMMA", 68);
			LeaveRule_COMMA();
		}
	}
	// $ANTLR end "COMMA"

	partial void EnterRule_ASSIGN();
	partial void LeaveRule_ASSIGN();

	// $ANTLR start "ASSIGN"
	[GrammarRule("ASSIGN")]
	private void mASSIGN()
	{
		EnterRule_ASSIGN();
		EnterRule("ASSIGN", 69);
		TraceIn("ASSIGN", 69);
		try
		{
			int _type = ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1089:10: ( '=' )
			DebugEnterAlt(1);
			// AS3.g:1089:12: '='
			{
			DebugLocation(1089, 12);
			Match('='); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ASSIGN", 69);
			LeaveRule("ASSIGN", 69);
			LeaveRule_ASSIGN();
		}
	}
	// $ANTLR end "ASSIGN"

	partial void EnterRule_EQUAL();
	partial void LeaveRule_EQUAL();

	// $ANTLR start "EQUAL"
	[GrammarRule("EQUAL")]
	private void mEQUAL()
	{
		EnterRule_EQUAL();
		EnterRule("EQUAL", 70);
		TraceIn("EQUAL", 70);
		try
		{
			int _type = EQUAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1090:9: ( '==' )
			DebugEnterAlt(1);
			// AS3.g:1090:11: '=='
			{
			DebugLocation(1090, 11);
			Match("=="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EQUAL", 70);
			LeaveRule("EQUAL", 70);
			LeaveRule_EQUAL();
		}
	}
	// $ANTLR end "EQUAL"

	partial void EnterRule_STRICT_EQUAL();
	partial void LeaveRule_STRICT_EQUAL();

	// $ANTLR start "STRICT_EQUAL"
	[GrammarRule("STRICT_EQUAL")]
	private void mSTRICT_EQUAL()
	{
		EnterRule_STRICT_EQUAL();
		EnterRule("STRICT_EQUAL", 71);
		TraceIn("STRICT_EQUAL", 71);
		try
		{
			int _type = STRICT_EQUAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1091:15: ( '===' )
			DebugEnterAlt(1);
			// AS3.g:1091:17: '==='
			{
			DebugLocation(1091, 17);
			Match("==="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRICT_EQUAL", 71);
			LeaveRule("STRICT_EQUAL", 71);
			LeaveRule_STRICT_EQUAL();
		}
	}
	// $ANTLR end "STRICT_EQUAL"

	partial void EnterRule_LNOT();
	partial void LeaveRule_LNOT();

	// $ANTLR start "LNOT"
	[GrammarRule("LNOT")]
	private void mLNOT()
	{
		EnterRule_LNOT();
		EnterRule("LNOT", 72);
		TraceIn("LNOT", 72);
		try
		{
			int _type = LNOT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1092:8: ( '!' )
			DebugEnterAlt(1);
			// AS3.g:1092:10: '!'
			{
			DebugLocation(1092, 10);
			Match('!'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LNOT", 72);
			LeaveRule("LNOT", 72);
			LeaveRule_LNOT();
		}
	}
	// $ANTLR end "LNOT"

	partial void EnterRule_BNOT();
	partial void LeaveRule_BNOT();

	// $ANTLR start "BNOT"
	[GrammarRule("BNOT")]
	private void mBNOT()
	{
		EnterRule_BNOT();
		EnterRule("BNOT", 73);
		TraceIn("BNOT", 73);
		try
		{
			int _type = BNOT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1093:8: ( '~' )
			DebugEnterAlt(1);
			// AS3.g:1093:10: '~'
			{
			DebugLocation(1093, 10);
			Match('~'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BNOT", 73);
			LeaveRule("BNOT", 73);
			LeaveRule_BNOT();
		}
	}
	// $ANTLR end "BNOT"

	partial void EnterRule_NOT_EQUAL();
	partial void LeaveRule_NOT_EQUAL();

	// $ANTLR start "NOT_EQUAL"
	[GrammarRule("NOT_EQUAL")]
	private void mNOT_EQUAL()
	{
		EnterRule_NOT_EQUAL();
		EnterRule("NOT_EQUAL", 74);
		TraceIn("NOT_EQUAL", 74);
		try
		{
			int _type = NOT_EQUAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1094:12: ( '!=' )
			DebugEnterAlt(1);
			// AS3.g:1094:14: '!='
			{
			DebugLocation(1094, 14);
			Match("!="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NOT_EQUAL", 74);
			LeaveRule("NOT_EQUAL", 74);
			LeaveRule_NOT_EQUAL();
		}
	}
	// $ANTLR end "NOT_EQUAL"

	partial void EnterRule_STRICT_NOT_EQUAL();
	partial void LeaveRule_STRICT_NOT_EQUAL();

	// $ANTLR start "STRICT_NOT_EQUAL"
	[GrammarRule("STRICT_NOT_EQUAL")]
	private void mSTRICT_NOT_EQUAL()
	{
		EnterRule_STRICT_NOT_EQUAL();
		EnterRule("STRICT_NOT_EQUAL", 75);
		TraceIn("STRICT_NOT_EQUAL", 75);
		try
		{
			int _type = STRICT_NOT_EQUAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1095:18: ( '!==' )
			DebugEnterAlt(1);
			// AS3.g:1095:20: '!=='
			{
			DebugLocation(1095, 20);
			Match("!=="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRICT_NOT_EQUAL", 75);
			LeaveRule("STRICT_NOT_EQUAL", 75);
			LeaveRule_STRICT_NOT_EQUAL();
		}
	}
	// $ANTLR end "STRICT_NOT_EQUAL"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 76);
		TraceIn("PLUS", 76);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1096:8: ( '+' )
			DebugEnterAlt(1);
			// AS3.g:1096:10: '+'
			{
			DebugLocation(1096, 10);
			Match('+'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 76);
			LeaveRule("PLUS", 76);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_PLUS_ASSIGN();
	partial void LeaveRule_PLUS_ASSIGN();

	// $ANTLR start "PLUS_ASSIGN"
	[GrammarRule("PLUS_ASSIGN")]
	private void mPLUS_ASSIGN()
	{
		EnterRule_PLUS_ASSIGN();
		EnterRule("PLUS_ASSIGN", 77);
		TraceIn("PLUS_ASSIGN", 77);
		try
		{
			int _type = PLUS_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1097:14: ( '+=' )
			DebugEnterAlt(1);
			// AS3.g:1097:16: '+='
			{
			DebugLocation(1097, 16);
			Match("+="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS_ASSIGN", 77);
			LeaveRule("PLUS_ASSIGN", 77);
			LeaveRule_PLUS_ASSIGN();
		}
	}
	// $ANTLR end "PLUS_ASSIGN"

	partial void EnterRule_INC();
	partial void LeaveRule_INC();

	// $ANTLR start "INC"
	[GrammarRule("INC")]
	private void mINC()
	{
		EnterRule_INC();
		EnterRule("INC", 78);
		TraceIn("INC", 78);
		try
		{
			int _type = INC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1098:7: ( '++' )
			DebugEnterAlt(1);
			// AS3.g:1098:9: '++'
			{
			DebugLocation(1098, 9);
			Match("++"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INC", 78);
			LeaveRule("INC", 78);
			LeaveRule_INC();
		}
	}
	// $ANTLR end "INC"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 79);
		TraceIn("MINUS", 79);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1099:9: ( '-' )
			DebugEnterAlt(1);
			// AS3.g:1099:11: '-'
			{
			DebugLocation(1099, 11);
			Match('-'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 79);
			LeaveRule("MINUS", 79);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_MINUS_ASSIGN();
	partial void LeaveRule_MINUS_ASSIGN();

	// $ANTLR start "MINUS_ASSIGN"
	[GrammarRule("MINUS_ASSIGN")]
	private void mMINUS_ASSIGN()
	{
		EnterRule_MINUS_ASSIGN();
		EnterRule("MINUS_ASSIGN", 80);
		TraceIn("MINUS_ASSIGN", 80);
		try
		{
			int _type = MINUS_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1100:15: ( '-=' )
			DebugEnterAlt(1);
			// AS3.g:1100:17: '-='
			{
			DebugLocation(1100, 17);
			Match("-="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS_ASSIGN", 80);
			LeaveRule("MINUS_ASSIGN", 80);
			LeaveRule_MINUS_ASSIGN();
		}
	}
	// $ANTLR end "MINUS_ASSIGN"

	partial void EnterRule_DEC();
	partial void LeaveRule_DEC();

	// $ANTLR start "DEC"
	[GrammarRule("DEC")]
	private void mDEC()
	{
		EnterRule_DEC();
		EnterRule("DEC", 81);
		TraceIn("DEC", 81);
		try
		{
			int _type = DEC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1101:7: ( '--' )
			DebugEnterAlt(1);
			// AS3.g:1101:9: '--'
			{
			DebugLocation(1101, 9);
			Match("--"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DEC", 81);
			LeaveRule("DEC", 81);
			LeaveRule_DEC();
		}
	}
	// $ANTLR end "DEC"

	partial void EnterRule_STAR();
	partial void LeaveRule_STAR();

	// $ANTLR start "STAR"
	[GrammarRule("STAR")]
	private void mSTAR()
	{
		EnterRule_STAR();
		EnterRule("STAR", 82);
		TraceIn("STAR", 82);
		try
		{
			int _type = STAR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1102:8: ( '*' )
			DebugEnterAlt(1);
			// AS3.g:1102:10: '*'
			{
			DebugLocation(1102, 10);
			Match('*'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STAR", 82);
			LeaveRule("STAR", 82);
			LeaveRule_STAR();
		}
	}
	// $ANTLR end "STAR"

	partial void EnterRule_STAR_ASSIGN();
	partial void LeaveRule_STAR_ASSIGN();

	// $ANTLR start "STAR_ASSIGN"
	[GrammarRule("STAR_ASSIGN")]
	private void mSTAR_ASSIGN()
	{
		EnterRule_STAR_ASSIGN();
		EnterRule("STAR_ASSIGN", 83);
		TraceIn("STAR_ASSIGN", 83);
		try
		{
			int _type = STAR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1103:14: ( '*=' )
			DebugEnterAlt(1);
			// AS3.g:1103:16: '*='
			{
			DebugLocation(1103, 16);
			Match("*="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STAR_ASSIGN", 83);
			LeaveRule("STAR_ASSIGN", 83);
			LeaveRule_STAR_ASSIGN();
		}
	}
	// $ANTLR end "STAR_ASSIGN"

	partial void EnterRule_MOD();
	partial void LeaveRule_MOD();

	// $ANTLR start "MOD"
	[GrammarRule("MOD")]
	private void mMOD()
	{
		EnterRule_MOD();
		EnterRule("MOD", 84);
		TraceIn("MOD", 84);
		try
		{
			int _type = MOD;
			int _channel = DefaultTokenChannel;
			// AS3.g:1104:7: ( '%' )
			DebugEnterAlt(1);
			// AS3.g:1104:9: '%'
			{
			DebugLocation(1104, 9);
			Match('%'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MOD", 84);
			LeaveRule("MOD", 84);
			LeaveRule_MOD();
		}
	}
	// $ANTLR end "MOD"

	partial void EnterRule_MOD_ASSIGN();
	partial void LeaveRule_MOD_ASSIGN();

	// $ANTLR start "MOD_ASSIGN"
	[GrammarRule("MOD_ASSIGN")]
	private void mMOD_ASSIGN()
	{
		EnterRule_MOD_ASSIGN();
		EnterRule("MOD_ASSIGN", 85);
		TraceIn("MOD_ASSIGN", 85);
		try
		{
			int _type = MOD_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1105:13: ( '%=' )
			DebugEnterAlt(1);
			// AS3.g:1105:15: '%='
			{
			DebugLocation(1105, 15);
			Match("%="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MOD_ASSIGN", 85);
			LeaveRule("MOD_ASSIGN", 85);
			LeaveRule_MOD_ASSIGN();
		}
	}
	// $ANTLR end "MOD_ASSIGN"

	partial void EnterRule_SR();
	partial void LeaveRule_SR();

	// $ANTLR start "SR"
	[GrammarRule("SR")]
	private void mSR()
	{
		EnterRule_SR();
		EnterRule("SR", 86);
		TraceIn("SR", 86);
		try
		{
			int _type = SR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1106:6: ( '>>' )
			DebugEnterAlt(1);
			// AS3.g:1106:8: '>>'
			{
			DebugLocation(1106, 8);
			Match(">>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SR", 86);
			LeaveRule("SR", 86);
			LeaveRule_SR();
		}
	}
	// $ANTLR end "SR"

	partial void EnterRule_SR_ASSIGN();
	partial void LeaveRule_SR_ASSIGN();

	// $ANTLR start "SR_ASSIGN"
	[GrammarRule("SR_ASSIGN")]
	private void mSR_ASSIGN()
	{
		EnterRule_SR_ASSIGN();
		EnterRule("SR_ASSIGN", 87);
		TraceIn("SR_ASSIGN", 87);
		try
		{
			int _type = SR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1107:12: ( '>>=' )
			DebugEnterAlt(1);
			// AS3.g:1107:14: '>>='
			{
			DebugLocation(1107, 14);
			Match(">>="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SR_ASSIGN", 87);
			LeaveRule("SR_ASSIGN", 87);
			LeaveRule_SR_ASSIGN();
		}
	}
	// $ANTLR end "SR_ASSIGN"

	partial void EnterRule_BSR();
	partial void LeaveRule_BSR();

	// $ANTLR start "BSR"
	[GrammarRule("BSR")]
	private void mBSR()
	{
		EnterRule_BSR();
		EnterRule("BSR", 88);
		TraceIn("BSR", 88);
		try
		{
			int _type = BSR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1108:7: ( '>>>' )
			DebugEnterAlt(1);
			// AS3.g:1108:9: '>>>'
			{
			DebugLocation(1108, 9);
			Match(">>>"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BSR", 88);
			LeaveRule("BSR", 88);
			LeaveRule_BSR();
		}
	}
	// $ANTLR end "BSR"

	partial void EnterRule_BSR_ASSIGN();
	partial void LeaveRule_BSR_ASSIGN();

	// $ANTLR start "BSR_ASSIGN"
	[GrammarRule("BSR_ASSIGN")]
	private void mBSR_ASSIGN()
	{
		EnterRule_BSR_ASSIGN();
		EnterRule("BSR_ASSIGN", 89);
		TraceIn("BSR_ASSIGN", 89);
		try
		{
			int _type = BSR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1109:13: ( '>>>=' )
			DebugEnterAlt(1);
			// AS3.g:1109:15: '>>>='
			{
			DebugLocation(1109, 15);
			Match(">>>="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BSR_ASSIGN", 89);
			LeaveRule("BSR_ASSIGN", 89);
			LeaveRule_BSR_ASSIGN();
		}
	}
	// $ANTLR end "BSR_ASSIGN"

	partial void EnterRule_GE();
	partial void LeaveRule_GE();

	// $ANTLR start "GE"
	[GrammarRule("GE")]
	private void mGE()
	{
		EnterRule_GE();
		EnterRule("GE", 90);
		TraceIn("GE", 90);
		try
		{
			int _type = GE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1110:6: ( '>=' )
			DebugEnterAlt(1);
			// AS3.g:1110:8: '>='
			{
			DebugLocation(1110, 8);
			Match(">="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GE", 90);
			LeaveRule("GE", 90);
			LeaveRule_GE();
		}
	}
	// $ANTLR end "GE"

	partial void EnterRule_GT();
	partial void LeaveRule_GT();

	// $ANTLR start "GT"
	[GrammarRule("GT")]
	private void mGT()
	{
		EnterRule_GT();
		EnterRule("GT", 91);
		TraceIn("GT", 91);
		try
		{
			int _type = GT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1111:6: ( '>' )
			DebugEnterAlt(1);
			// AS3.g:1111:8: '>'
			{
			DebugLocation(1111, 8);
			Match('>'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("GT", 91);
			LeaveRule("GT", 91);
			LeaveRule_GT();
		}
	}
	// $ANTLR end "GT"

	partial void EnterRule_BXOR();
	partial void LeaveRule_BXOR();

	// $ANTLR start "BXOR"
	[GrammarRule("BXOR")]
	private void mBXOR()
	{
		EnterRule_BXOR();
		EnterRule("BXOR", 92);
		TraceIn("BXOR", 92);
		try
		{
			int _type = BXOR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1112:8: ( '^' )
			DebugEnterAlt(1);
			// AS3.g:1112:10: '^'
			{
			DebugLocation(1112, 10);
			Match('^'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BXOR", 92);
			LeaveRule("BXOR", 92);
			LeaveRule_BXOR();
		}
	}
	// $ANTLR end "BXOR"

	partial void EnterRule_BXOR_ASSIGN();
	partial void LeaveRule_BXOR_ASSIGN();

	// $ANTLR start "BXOR_ASSIGN"
	[GrammarRule("BXOR_ASSIGN")]
	private void mBXOR_ASSIGN()
	{
		EnterRule_BXOR_ASSIGN();
		EnterRule("BXOR_ASSIGN", 93);
		TraceIn("BXOR_ASSIGN", 93);
		try
		{
			int _type = BXOR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1113:14: ( '^=' )
			DebugEnterAlt(1);
			// AS3.g:1113:16: '^='
			{
			DebugLocation(1113, 16);
			Match("^="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BXOR_ASSIGN", 93);
			LeaveRule("BXOR_ASSIGN", 93);
			LeaveRule_BXOR_ASSIGN();
		}
	}
	// $ANTLR end "BXOR_ASSIGN"

	partial void EnterRule_BOR();
	partial void LeaveRule_BOR();

	// $ANTLR start "BOR"
	[GrammarRule("BOR")]
	private void mBOR()
	{
		EnterRule_BOR();
		EnterRule("BOR", 94);
		TraceIn("BOR", 94);
		try
		{
			int _type = BOR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1114:7: ( '|' )
			DebugEnterAlt(1);
			// AS3.g:1114:9: '|'
			{
			DebugLocation(1114, 9);
			Match('|'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOR", 94);
			LeaveRule("BOR", 94);
			LeaveRule_BOR();
		}
	}
	// $ANTLR end "BOR"

	partial void EnterRule_BOR_ASSIGN();
	partial void LeaveRule_BOR_ASSIGN();

	// $ANTLR start "BOR_ASSIGN"
	[GrammarRule("BOR_ASSIGN")]
	private void mBOR_ASSIGN()
	{
		EnterRule_BOR_ASSIGN();
		EnterRule("BOR_ASSIGN", 95);
		TraceIn("BOR_ASSIGN", 95);
		try
		{
			int _type = BOR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1115:13: ( '|=' )
			DebugEnterAlt(1);
			// AS3.g:1115:15: '|='
			{
			DebugLocation(1115, 15);
			Match("|="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOR_ASSIGN", 95);
			LeaveRule("BOR_ASSIGN", 95);
			LeaveRule_BOR_ASSIGN();
		}
	}
	// $ANTLR end "BOR_ASSIGN"

	partial void EnterRule_LOR();
	partial void LeaveRule_LOR();

	// $ANTLR start "LOR"
	[GrammarRule("LOR")]
	private void mLOR()
	{
		EnterRule_LOR();
		EnterRule("LOR", 96);
		TraceIn("LOR", 96);
		try
		{
			int _type = LOR;
			int _channel = DefaultTokenChannel;
			// AS3.g:1116:7: ( '||' )
			DebugEnterAlt(1);
			// AS3.g:1116:9: '||'
			{
			DebugLocation(1116, 9);
			Match("||"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LOR", 96);
			LeaveRule("LOR", 96);
			LeaveRule_LOR();
		}
	}
	// $ANTLR end "LOR"

	partial void EnterRule_BAND();
	partial void LeaveRule_BAND();

	// $ANTLR start "BAND"
	[GrammarRule("BAND")]
	private void mBAND()
	{
		EnterRule_BAND();
		EnterRule("BAND", 97);
		TraceIn("BAND", 97);
		try
		{
			int _type = BAND;
			int _channel = DefaultTokenChannel;
			// AS3.g:1117:8: ( '&' )
			DebugEnterAlt(1);
			// AS3.g:1117:10: '&'
			{
			DebugLocation(1117, 10);
			Match('&'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BAND", 97);
			LeaveRule("BAND", 97);
			LeaveRule_BAND();
		}
	}
	// $ANTLR end "BAND"

	partial void EnterRule_BAND_ASSIGN();
	partial void LeaveRule_BAND_ASSIGN();

	// $ANTLR start "BAND_ASSIGN"
	[GrammarRule("BAND_ASSIGN")]
	private void mBAND_ASSIGN()
	{
		EnterRule_BAND_ASSIGN();
		EnterRule("BAND_ASSIGN", 98);
		TraceIn("BAND_ASSIGN", 98);
		try
		{
			int _type = BAND_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1118:14: ( '&=' )
			DebugEnterAlt(1);
			// AS3.g:1118:16: '&='
			{
			DebugLocation(1118, 16);
			Match("&="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BAND_ASSIGN", 98);
			LeaveRule("BAND_ASSIGN", 98);
			LeaveRule_BAND_ASSIGN();
		}
	}
	// $ANTLR end "BAND_ASSIGN"

	partial void EnterRule_LAND();
	partial void LeaveRule_LAND();

	// $ANTLR start "LAND"
	[GrammarRule("LAND")]
	private void mLAND()
	{
		EnterRule_LAND();
		EnterRule("LAND", 99);
		TraceIn("LAND", 99);
		try
		{
			int _type = LAND;
			int _channel = DefaultTokenChannel;
			// AS3.g:1119:8: ( '&&' )
			DebugEnterAlt(1);
			// AS3.g:1119:10: '&&'
			{
			DebugLocation(1119, 10);
			Match("&&"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LAND", 99);
			LeaveRule("LAND", 99);
			LeaveRule_LAND();
		}
	}
	// $ANTLR end "LAND"

	partial void EnterRule_LAND_ASSIGN();
	partial void LeaveRule_LAND_ASSIGN();

	// $ANTLR start "LAND_ASSIGN"
	[GrammarRule("LAND_ASSIGN")]
	private void mLAND_ASSIGN()
	{
		EnterRule_LAND_ASSIGN();
		EnterRule("LAND_ASSIGN", 100);
		TraceIn("LAND_ASSIGN", 100);
		try
		{
			int _type = LAND_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1120:14: ( '&&=' )
			DebugEnterAlt(1);
			// AS3.g:1120:16: '&&='
			{
			DebugLocation(1120, 16);
			Match("&&="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LAND_ASSIGN", 100);
			LeaveRule("LAND_ASSIGN", 100);
			LeaveRule_LAND_ASSIGN();
		}
	}
	// $ANTLR end "LAND_ASSIGN"

	partial void EnterRule_LOR_ASSIGN();
	partial void LeaveRule_LOR_ASSIGN();

	// $ANTLR start "LOR_ASSIGN"
	[GrammarRule("LOR_ASSIGN")]
	private void mLOR_ASSIGN()
	{
		EnterRule_LOR_ASSIGN();
		EnterRule("LOR_ASSIGN", 101);
		TraceIn("LOR_ASSIGN", 101);
		try
		{
			int _type = LOR_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1121:13: ( '||=' )
			DebugEnterAlt(1);
			// AS3.g:1121:15: '||='
			{
			DebugLocation(1121, 15);
			Match("||="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LOR_ASSIGN", 101);
			LeaveRule("LOR_ASSIGN", 101);
			LeaveRule_LOR_ASSIGN();
		}
	}
	// $ANTLR end "LOR_ASSIGN"

	partial void EnterRule_E4X_ATTRI();
	partial void LeaveRule_E4X_ATTRI();

	// $ANTLR start "E4X_ATTRI"
	[GrammarRule("E4X_ATTRI")]
	private void mE4X_ATTRI()
	{
		EnterRule_E4X_ATTRI();
		EnterRule("E4X_ATTRI", 102);
		TraceIn("E4X_ATTRI", 102);
		try
		{
			int _type = E4X_ATTRI;
			int _channel = DefaultTokenChannel;
			// AS3.g:1122:12: ( '@' )
			DebugEnterAlt(1);
			// AS3.g:1122:14: '@'
			{
			DebugLocation(1122, 14);
			Match('@'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("E4X_ATTRI", 102);
			LeaveRule("E4X_ATTRI", 102);
			LeaveRule_E4X_ATTRI();
		}
	}
	// $ANTLR end "E4X_ATTRI"

	partial void EnterRule_SEMI();
	partial void LeaveRule_SEMI();

	// $ANTLR start "SEMI"
	[GrammarRule("SEMI")]
	private void mSEMI()
	{
		EnterRule_SEMI();
		EnterRule("SEMI", 103);
		TraceIn("SEMI", 103);
		try
		{
			int _type = SEMI;
			int _channel = DefaultTokenChannel;
			// AS3.g:1123:8: ( ';' )
			DebugEnterAlt(1);
			// AS3.g:1123:10: ';'
			{
			DebugLocation(1123, 10);
			Match(';'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SEMI", 103);
			LeaveRule("SEMI", 103);
			LeaveRule_SEMI();
		}
	}
	// $ANTLR end "SEMI"

	partial void EnterRule_BSLASH();
	partial void LeaveRule_BSLASH();

	// $ANTLR start "BSLASH"
	[GrammarRule("BSLASH")]
	private void mBSLASH()
	{
		EnterRule_BSLASH();
		EnterRule("BSLASH", 104);
		TraceIn("BSLASH", 104);
		try
		{
			int _type = BSLASH;
			int _channel = DefaultTokenChannel;
			// AS3.g:1124:17: ( '\\\\' )
			DebugEnterAlt(1);
			// AS3.g:1124:21: '\\\\'
			{
			DebugLocation(1124, 21);
			Match('\\'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BSLASH", 104);
			LeaveRule("BSLASH", 104);
			LeaveRule_BSLASH();
		}
	}
	// $ANTLR end "BSLASH"

	partial void EnterRule_DOT();
	partial void LeaveRule_DOT();

	// $ANTLR start "DOT"
	[GrammarRule("DOT")]
	private void mDOT()
	{
		EnterRule_DOT();
		EnterRule("DOT", 105);
		TraceIn("DOT", 105);
		try
		{
			int _type = DOT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1126:6: ( '.' )
			DebugEnterAlt(1);
			// AS3.g:1126:8: '.'
			{
			DebugLocation(1126, 8);
			Match('.'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DOT", 105);
			LeaveRule("DOT", 105);
			LeaveRule_DOT();
		}
	}
	// $ANTLR end "DOT"

	partial void EnterRule_E4X_DESC();
	partial void LeaveRule_E4X_DESC();

	// $ANTLR start "E4X_DESC"
	[GrammarRule("E4X_DESC")]
	private void mE4X_DESC()
	{
		EnterRule_E4X_DESC();
		EnterRule("E4X_DESC", 106);
		TraceIn("E4X_DESC", 106);
		try
		{
			int _type = E4X_DESC;
			int _channel = DefaultTokenChannel;
			// AS3.g:1127:10: ( '..' )
			DebugEnterAlt(1);
			// AS3.g:1127:12: '..'
			{
			DebugLocation(1127, 12);
			Match(".."); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("E4X_DESC", 106);
			LeaveRule("E4X_DESC", 106);
			LeaveRule_E4X_DESC();
		}
	}
	// $ANTLR end "E4X_DESC"

	partial void EnterRule_REST();
	partial void LeaveRule_REST();

	// $ANTLR start "REST"
	[GrammarRule("REST")]
	private void mREST()
	{
		EnterRule_REST();
		EnterRule("REST", 107);
		TraceIn("REST", 107);
		try
		{
			int _type = REST;
			int _channel = DefaultTokenChannel;
			// AS3.g:1128:7: ( '...' )
			DebugEnterAlt(1);
			// AS3.g:1128:9: '...'
			{
			DebugLocation(1128, 9);
			Match("..."); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REST", 107);
			LeaveRule("REST", 107);
			LeaveRule_REST();
		}
	}
	// $ANTLR end "REST"

	partial void EnterRule_REGEX_LITERAL();
	partial void LeaveRule_REGEX_LITERAL();

	// $ANTLR start "REGEX_LITERAL"
	[GrammarRule("REGEX_LITERAL")]
	private void mREGEX_LITERAL()
	{
		EnterRule_REGEX_LITERAL();
		EnterRule("REGEX_LITERAL", 108);
		TraceIn("REGEX_LITERAL", 108);
		try
		{
			int _type = REGEX_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1131:2: ({...}? => '/' REGEX_BODY '/' ( REGEX_POSTFIX )? )
			DebugEnterAlt(1);
			// AS3.g:1131:4: {...}? => '/' REGEX_BODY '/' ( REGEX_POSTFIX )?
			{
			DebugLocation(1131, 4);
			if (!(( constantIsOk() )))
			{
				if (state.backtracking>0) {state.failed=true; return;}
				throw new FailedPredicateException(input, "REGEX_LITERAL", " constantIsOk() ");
			}
			DebugLocation(1131, 26);
			Match('/'); if (state.failed) return;
			DebugLocation(1131, 30);
			mREGEX_BODY(); if (state.failed) return;
			DebugLocation(1131, 41);
			Match('/'); if (state.failed) return;
			DebugLocation(1131, 45);
			// AS3.g:1131:45: ( REGEX_POSTFIX )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_1 = input.LA(1);

			if ((LA1_1=='$'||(LA1_1>='0' && LA1_1<='9')||(LA1_1>='A' && LA1_1<='Z')||LA1_1=='_'||(LA1_1>='a' && LA1_1<='z')))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1131:45: REGEX_POSTFIX
				{
				DebugLocation(1131, 45);
				mREGEX_POSTFIX(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("REGEX_LITERAL", 108);
			LeaveRule("REGEX_LITERAL", 108);
			LeaveRule_REGEX_LITERAL();
		}
	}
	// $ANTLR end "REGEX_LITERAL"

	partial void EnterRule_REGEX_POSTFIX();
	partial void LeaveRule_REGEX_POSTFIX();

	// $ANTLR start "REGEX_POSTFIX"
	[GrammarRule("REGEX_POSTFIX")]
	private void mREGEX_POSTFIX()
	{
		EnterRule_REGEX_POSTFIX();
		EnterRule("REGEX_POSTFIX", 109);
		TraceIn("REGEX_POSTFIX", 109);
		try
		{
			// AS3.g:1136:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )+ )
			DebugEnterAlt(1);
			// AS3.g:1136:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )+
			{
			DebugLocation(1136, 7);
			// AS3.g:1136:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )+
			int cnt2=0;
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1=='$'||(LA2_1>='0' && LA2_1<='9')||(LA2_1>='A' && LA2_1<='Z')||LA2_1=='_'||(LA2_1>='a' && LA2_1<='z')))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch (alt2)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1136, 7);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt2 >= 1)
						goto loop2;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee2 = new EarlyExitException( 2, input );
					DebugRecognitionException(eee2);
					throw eee2;
				}
				cnt2++;
			}
			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

		}
		finally
		{
			TraceOut("REGEX_POSTFIX", 109);
			LeaveRule("REGEX_POSTFIX", 109);
			LeaveRule_REGEX_POSTFIX();
		}
	}
	// $ANTLR end "REGEX_POSTFIX"

	partial void EnterRule_REGEX_BODY();
	partial void LeaveRule_REGEX_BODY();

	// $ANTLR start "REGEX_BODY"
	[GrammarRule("REGEX_BODY")]
	private void mREGEX_BODY()
	{
		EnterRule_REGEX_BODY();
		EnterRule("REGEX_BODY", 110);
		TraceIn("REGEX_BODY", 110);
		try
		{
			// AS3.g:1140:2: ( ( (~ ( '\\n' | '\\r' | '*' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) ) ( (~ ( '\\n' | '\\r' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) )* )
			DebugEnterAlt(1);
			// AS3.g:1140:4: ( (~ ( '\\n' | '\\r' | '*' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) ) ( (~ ( '\\n' | '\\r' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) )*
			{
			DebugLocation(1140, 4);
			// AS3.g:1140:4: ( (~ ( '\\n' | '\\r' | '*' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) )
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_1 = input.LA(1);

			if (((LA3_1>='\u0000' && LA3_1<='\t')||(LA3_1>='\u000B' && LA3_1<='\f')||(LA3_1>='\u000E' && LA3_1<=')')||(LA3_1>='+' && LA3_1<='.')||(LA3_1>='0' && LA3_1<='[')||(LA3_1>=']' && LA3_1<='\uFFFF')))
			{
				alt3 = 1;
			}
			else if ((LA3_1=='\\'))
			{
				alt3 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 3, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1140:6: (~ ( '\\n' | '\\r' | '*' | '/' | '\\\\' ) )
				{
				DebugLocation(1140, 6);
				input.Consume();
				state.failed=false;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1141:5: '\\\\' (~ ( '\\n' | '\\r' ) )
				{
				DebugLocation(1141, 5);
				Match('\\'); if (state.failed) return;
				DebugLocation(1141, 9);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(1143, 3);
			// AS3.g:1143:3: ( (~ ( '\\n' | '\\r' | '/' | '\\\\' ) ) | '\\\\' (~ ( '\\n' | '\\r' ) ) )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=3;
				try { DebugEnterDecision(4, false);
				int LA4_1 = input.LA(1);

				if (((LA4_1>='\u0000' && LA4_1<='\t')||(LA4_1>='\u000B' && LA4_1<='\f')||(LA4_1>='\u000E' && LA4_1<='.')||(LA4_1>='0' && LA4_1<='[')||(LA4_1>=']' && LA4_1<='\uFFFF')))
				{
					alt4 = 1;
				}
				else if ((LA4_1=='\\'))
				{
					alt4 = 2;
				}


				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1143:5: (~ ( '\\n' | '\\r' | '/' | '\\\\' ) )
					{
					DebugLocation(1143, 5);
					input.Consume();
					state.failed=false;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1144:5: '\\\\' (~ ( '\\n' | '\\r' ) )
					{
					DebugLocation(1144, 5);
					Match('\\'); if (state.failed) return;
					DebugLocation(1144, 9);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }


			}

		}
		finally
		{
			TraceOut("REGEX_BODY", 110);
			LeaveRule("REGEX_BODY", 110);
			LeaveRule_REGEX_BODY();
		}
	}
	// $ANTLR end "REGEX_BODY"

	partial void EnterRule_DIV_ASSIGN();
	partial void LeaveRule_DIV_ASSIGN();

	// $ANTLR start "DIV_ASSIGN"
	[GrammarRule("DIV_ASSIGN")]
	private void mDIV_ASSIGN()
	{
		EnterRule_DIV_ASSIGN();
		EnterRule("DIV_ASSIGN", 111);
		TraceIn("DIV_ASSIGN", 111);
		try
		{
			int _type = DIV_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1148:13: ( '/=' )
			DebugEnterAlt(1);
			// AS3.g:1148:15: '/='
			{
			DebugLocation(1148, 15);
			Match("/="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV_ASSIGN", 111);
			LeaveRule("DIV_ASSIGN", 111);
			LeaveRule_DIV_ASSIGN();
		}
	}
	// $ANTLR end "DIV_ASSIGN"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 112);
		TraceIn("DIV", 112);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// AS3.g:1150:17: ( '/' )
			DebugEnterAlt(1);
			// AS3.g:1150:19: '/'
			{
			DebugLocation(1150, 19);
			Match('/'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 112);
			LeaveRule("DIV", 112);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_XML_LITERAL();
	partial void LeaveRule_XML_LITERAL();

	// $ANTLR start "XML_LITERAL"
	[GrammarRule("XML_LITERAL")]
	private void mXML_LITERAL()
	{
		EnterRule_XML_LITERAL();
		EnterRule("XML_LITERAL", 113);
		TraceIn("XML_LITERAL", 113);
		try
		{
			int _type = XML_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1154:2: ( ( XML_LITERAL )=> '<' IDENT ( XML_WS | XML_ATTRIBUTE )* ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' ) )
			DebugEnterAlt(1);
			// AS3.g:1154:4: ( XML_LITERAL )=> '<' IDENT ( XML_WS | XML_ATTRIBUTE )* ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' )
			{
			DebugLocation(1155, 7);
			Match('<'); if (state.failed) return;
			DebugLocation(1155, 11);
			mIDENT(); if (state.failed) return;
			DebugLocation(1155, 17);
			// AS3.g:1155:17: ( XML_WS | XML_ATTRIBUTE )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=3;
				try { DebugEnterDecision(5, false);
				int LA5_1 = input.LA(1);

				if (((LA5_1>='\t' && LA5_1<='\n')||(LA5_1>='\f' && LA5_1<='\r')||LA5_1==' '))
				{
					alt5 = 1;
				}
				else if ((LA5_1=='$'||(LA5_1>='A' && LA5_1<='Z')||LA5_1=='_'||(LA5_1>='a' && LA5_1<='z')))
				{
					alt5 = 2;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1155:18: XML_WS
					{
					DebugLocation(1155, 18);
					mXML_WS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1155:27: XML_ATTRIBUTE
					{
					DebugLocation(1155, 27);
					mXML_ATTRIBUTE(); if (state.failed) return;

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }

			DebugLocation(1156, 3);
			// AS3.g:1156:3: ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' )
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_1 = input.LA(1);

			if ((LA7_1=='>'))
			{
				alt7 = 1;
			}
			else if ((LA7_1=='/'))
			{
				alt7 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1156:5: '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>'
				{
				DebugLocation(1156, 5);
				Match('>'); if (state.failed) return;
				DebugLocation(1156, 9);
				// AS3.g:1156:9: ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )*
				try { DebugEnterSubRule(6);
				while (true)
				{
					int alt6=6;
					try { DebugEnterDecision(6, false);
					int LA6_1 = input.LA(1);

					if ((LA6_1=='<'))
					{
						int LA6_2 = input.LA(2);

						if ((LA6_2=='!'))
						{
							int LA6_3 = input.LA(3);

							if ((LA6_3=='-'))
							{
								alt6 = 3;
							}
							else if ((LA6_3=='['))
							{
								alt6 = 4;
							}


						}
						else if ((LA6_2=='$'||(LA6_2>='A' && LA6_2<='Z')||LA6_2=='_'||(LA6_2>='a' && LA6_2<='z')))
						{
							alt6 = 1;
						}


					}
					else if (((LA6_1>='\u0000' && LA6_1<=';')||(LA6_1>='=' && LA6_1<='z')||(LA6_1>='|' && LA6_1<='\uFFFF')))
					{
						alt6 = 2;
					}
					else if ((LA6_1=='{'))
					{
						alt6 = 5;
					}


					} finally { DebugExitDecision(6); }
					switch ( alt6 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:1156:10: XML_SUBTREE
						{
						DebugLocation(1156, 10);
						mXML_SUBTREE(); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// AS3.g:1156:24: XML_TEXTNODE
						{
						DebugLocation(1156, 24);
						mXML_TEXTNODE(); if (state.failed) return;

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// AS3.g:1156:39: XML_COMMENT
						{
						DebugLocation(1156, 39);
						mXML_COMMENT(); if (state.failed) return;

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// AS3.g:1156:53: XML_CDATA
						{
						DebugLocation(1156, 53);
						mXML_CDATA(); if (state.failed) return;

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// AS3.g:1156:65: XML_BINDING
						{
						DebugLocation(1156, 65);
						mXML_BINDING(); if (state.failed) return;

						}
						break;

					default:
						goto loop6;
					}
				}

				loop6:
					;

				} finally { DebugExitSubRule(6); }

				DebugLocation(1157, 13);
				Match("</"); if (state.failed) return;

				DebugLocation(1157, 18);
				mIDENT(); if (state.failed) return;
				DebugLocation(1157, 24);
				Match('>'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1158:5: '/>'
				{
				DebugLocation(1158, 5);
				Match("/>"); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("XML_LITERAL", 113);
			LeaveRule("XML_LITERAL", 113);
			LeaveRule_XML_LITERAL();
		}
	}
	// $ANTLR end "XML_LITERAL"

	partial void EnterRule_XML_SUBTREE();
	partial void LeaveRule_XML_SUBTREE();

	// $ANTLR start "XML_SUBTREE"
	[GrammarRule("XML_SUBTREE")]
	private void mXML_SUBTREE()
	{
		EnterRule_XML_SUBTREE();
		EnterRule("XML_SUBTREE", 114);
		TraceIn("XML_SUBTREE", 114);
		try
		{
			// AS3.g:1164:2: ( '<' IDENT ( XML_WS | XML_ATTRIBUTE )* ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' ) )
			DebugEnterAlt(1);
			// AS3.g:1164:4: '<' IDENT ( XML_WS | XML_ATTRIBUTE )* ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' )
			{
			DebugLocation(1164, 4);
			Match('<'); if (state.failed) return;
			DebugLocation(1164, 8);
			mIDENT(); if (state.failed) return;
			DebugLocation(1164, 14);
			// AS3.g:1164:14: ( XML_WS | XML_ATTRIBUTE )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=3;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if (((LA8_1>='\t' && LA8_1<='\n')||(LA8_1>='\f' && LA8_1<='\r')||LA8_1==' '))
				{
					alt8 = 1;
				}
				else if ((LA8_1=='$'||(LA8_1>='A' && LA8_1<='Z')||LA8_1=='_'||(LA8_1>='a' && LA8_1<='z')))
				{
					alt8 = 2;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1164:15: XML_WS
					{
					DebugLocation(1164, 15);
					mXML_WS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1164:24: XML_ATTRIBUTE
					{
					DebugLocation(1164, 24);
					mXML_ATTRIBUTE(); if (state.failed) return;

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(1165, 3);
			// AS3.g:1165:3: ( '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>' | '/>' )
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1=='>'))
			{
				alt10 = 1;
			}
			else if ((LA10_1=='/'))
			{
				alt10 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1165:5: '>' ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )* '</' IDENT '>'
				{
				DebugLocation(1165, 5);
				Match('>'); if (state.failed) return;
				DebugLocation(1165, 9);
				// AS3.g:1165:9: ( XML_SUBTREE | XML_TEXTNODE | XML_COMMENT | XML_CDATA | XML_BINDING )*
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=6;
					try { DebugEnterDecision(9, false);
					int LA9_1 = input.LA(1);

					if ((LA9_1=='<'))
					{
						int LA9_2 = input.LA(2);

						if ((LA9_2=='!'))
						{
							int LA9_3 = input.LA(3);

							if ((LA9_3=='-'))
							{
								alt9 = 3;
							}
							else if ((LA9_3=='['))
							{
								alt9 = 4;
							}


						}
						else if ((LA9_2=='$'||(LA9_2>='A' && LA9_2<='Z')||LA9_2=='_'||(LA9_2>='a' && LA9_2<='z')))
						{
							alt9 = 1;
						}


					}
					else if (((LA9_1>='\u0000' && LA9_1<=';')||(LA9_1>='=' && LA9_1<='z')||(LA9_1>='|' && LA9_1<='\uFFFF')))
					{
						alt9 = 2;
					}
					else if ((LA9_1=='{'))
					{
						alt9 = 5;
					}


					} finally { DebugExitDecision(9); }
					switch ( alt9 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:1165:10: XML_SUBTREE
						{
						DebugLocation(1165, 10);
						mXML_SUBTREE(); if (state.failed) return;

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// AS3.g:1165:24: XML_TEXTNODE
						{
						DebugLocation(1165, 24);
						mXML_TEXTNODE(); if (state.failed) return;

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// AS3.g:1165:39: XML_COMMENT
						{
						DebugLocation(1165, 39);
						mXML_COMMENT(); if (state.failed) return;

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// AS3.g:1165:53: XML_CDATA
						{
						DebugLocation(1165, 53);
						mXML_CDATA(); if (state.failed) return;

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// AS3.g:1165:65: XML_BINDING
						{
						DebugLocation(1165, 65);
						mXML_BINDING(); if (state.failed) return;

						}
						break;

					default:
						goto loop9;
					}
				}

				loop9:
					;

				} finally { DebugExitSubRule(9); }

				DebugLocation(1166, 4);
				Match("</"); if (state.failed) return;

				DebugLocation(1166, 9);
				mIDENT(); if (state.failed) return;
				DebugLocation(1166, 15);
				Match('>'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1167:5: '/>'
				{
				DebugLocation(1167, 5);
				Match("/>"); if (state.failed) return;


				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

		}
		finally
		{
			TraceOut("XML_SUBTREE", 114);
			LeaveRule("XML_SUBTREE", 114);
			LeaveRule_XML_SUBTREE();
		}
	}
	// $ANTLR end "XML_SUBTREE"

	partial void EnterRule_XML_ATTRIBUTE();
	partial void LeaveRule_XML_ATTRIBUTE();

	// $ANTLR start "XML_ATTRIBUTE"
	[GrammarRule("XML_ATTRIBUTE")]
	private void mXML_ATTRIBUTE()
	{
		EnterRule_XML_ATTRIBUTE();
		EnterRule("XML_ATTRIBUTE", 115);
		TraceIn("XML_ATTRIBUTE", 115);
		try
		{
			// AS3.g:1172:2: ( IDENT ( XML_WS )* ASSIGN ( XML_WS )* ( STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | XML_BINDING ) )
			DebugEnterAlt(1);
			// AS3.g:1172:4: IDENT ( XML_WS )* ASSIGN ( XML_WS )* ( STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | XML_BINDING )
			{
			DebugLocation(1172, 4);
			mIDENT(); if (state.failed) return;
			DebugLocation(1172, 10);
			// AS3.g:1172:10: ( XML_WS )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if (((LA11_1>='\t' && LA11_1<='\n')||(LA11_1>='\f' && LA11_1<='\r')||LA11_1==' '))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1172, 10);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(1172, 18);
			mASSIGN(); if (state.failed) return;
			DebugLocation(1172, 25);
			// AS3.g:1172:25: ( XML_WS )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if (((LA12_1>='\t' && LA12_1<='\n')||(LA12_1>='\f' && LA12_1<='\r')||LA12_1==' '))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1172, 25);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(1172, 33);
			// AS3.g:1172:33: ( STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | XML_BINDING )
			int alt13=3;
			try { DebugEnterSubRule(13);
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case '\"':
				{
				alt13 = 1;
				}
				break;
			case '\'':
				{
				alt13 = 2;
				}
				break;
			case '{':
				{
				alt13 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1172:34: STRING_LITERAL_DOUBLE
				{
				DebugLocation(1172, 34);
				mSTRING_LITERAL_DOUBLE(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1172:58: STRING_LITERAL_SINGLE
				{
				DebugLocation(1172, 58);
				mSTRING_LITERAL_SINGLE(); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:1172:82: XML_BINDING
				{
				DebugLocation(1172, 82);
				mXML_BINDING(); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(13); }


			}

		}
		finally
		{
			TraceOut("XML_ATTRIBUTE", 115);
			LeaveRule("XML_ATTRIBUTE", 115);
			LeaveRule_XML_ATTRIBUTE();
		}
	}
	// $ANTLR end "XML_ATTRIBUTE"

	partial void EnterRule_XML_BINDING();
	partial void LeaveRule_XML_BINDING();

	// $ANTLR start "XML_BINDING"
	[GrammarRule("XML_BINDING")]
	private void mXML_BINDING()
	{
		EnterRule_XML_BINDING();
		EnterRule("XML_BINDING", 116);
		TraceIn("XML_BINDING", 116);
		try
		{
			// AS3.g:1176:2: ( '{' XML_AS3_EXPRESSION '}' )
			DebugEnterAlt(1);
			// AS3.g:1176:4: '{' XML_AS3_EXPRESSION '}'
			{
			DebugLocation(1176, 4);
			Match('{'); if (state.failed) return;
			DebugLocation(1176, 8);
			mXML_AS3_EXPRESSION(); if (state.failed) return;
			DebugLocation(1176, 27);
			Match('}'); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("XML_BINDING", 116);
			LeaveRule("XML_BINDING", 116);
			LeaveRule_XML_BINDING();
		}
	}
	// $ANTLR end "XML_BINDING"

	partial void EnterRule_XML_AS3_EXPRESSION();
	partial void LeaveRule_XML_AS3_EXPRESSION();

	// $ANTLR start "XML_AS3_EXPRESSION"
	[GrammarRule("XML_AS3_EXPRESSION")]
	private void mXML_AS3_EXPRESSION()
	{
		EnterRule_XML_AS3_EXPRESSION();
		EnterRule("XML_AS3_EXPRESSION", 117);
		TraceIn("XML_AS3_EXPRESSION", 117);
		try
		{
			// AS3.g:1181:2: ( (~ ( '{' | '}' ) )* )
			DebugEnterAlt(1);
			// AS3.g:1182:4: (~ ( '{' | '}' ) )*
			{
			DebugLocation(1182, 4);
			// AS3.g:1182:4: (~ ( '{' | '}' ) )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_1 = input.LA(1);

				if (((LA14_1>='\u0000' && LA14_1<='z')||LA14_1=='|'||(LA14_1>='~' && LA14_1<='\uFFFF')))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1182, 4);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

		}
		finally
		{
			TraceOut("XML_AS3_EXPRESSION", 117);
			LeaveRule("XML_AS3_EXPRESSION", 117);
			LeaveRule_XML_AS3_EXPRESSION();
		}
	}
	// $ANTLR end "XML_AS3_EXPRESSION"

	partial void EnterRule_XML_TEXTNODE();
	partial void LeaveRule_XML_TEXTNODE();

	// $ANTLR start "XML_TEXTNODE"
	[GrammarRule("XML_TEXTNODE")]
	private void mXML_TEXTNODE()
	{
		EnterRule_XML_TEXTNODE();
		EnterRule("XML_TEXTNODE", 118);
		TraceIn("XML_TEXTNODE", 118);
		try
		{
			// AS3.g:1186:2: ( ( XML_WS | ( '/' ~ '>' )=> '/' |~ ( '<' | '{' | '/' | XML_WS ) ) )
			DebugEnterAlt(1);
			// AS3.g:1186:4: ( XML_WS | ( '/' ~ '>' )=> '/' |~ ( '<' | '{' | '/' | XML_WS ) )
			{
			DebugLocation(1186, 4);
			// AS3.g:1186:4: ( XML_WS | ( '/' ~ '>' )=> '/' |~ ( '<' | '{' | '/' | XML_WS ) )
			int alt15=3;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_1 = input.LA(1);

			if (((LA15_1>='\t' && LA15_1<='\n')||(LA15_1>='\f' && LA15_1<='\r')||LA15_1==' '))
			{
				alt15 = 1;
			}
			else if ((LA15_1=='/') && (EvaluatePredicate(synpred2_AS3_fragment)))
			{
				alt15 = 2;
			}
			else if (((LA15_1>='\u0000' && LA15_1<='\b')||LA15_1=='\u000B'||(LA15_1>='\u000E' && LA15_1<='\u001F')||(LA15_1>='!' && LA15_1<='.')||(LA15_1>='0' && LA15_1<=';')||(LA15_1>='=' && LA15_1<='z')||(LA15_1>='|' && LA15_1<='\uFFFF')))
			{
				alt15 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 15, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1187:4: XML_WS
				{
				DebugLocation(1187, 4);
				mXML_WS(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1188:5: ( '/' ~ '>' )=> '/'
				{
				DebugLocation(1188, 19);
				Match('/'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:1189:5: ~ ( '<' | '{' | '/' | XML_WS )
				{
				DebugLocation(1189, 5);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(15); }


			}

		}
		finally
		{
			TraceOut("XML_TEXTNODE", 118);
			LeaveRule("XML_TEXTNODE", 118);
			LeaveRule_XML_TEXTNODE();
		}
	}
	// $ANTLR end "XML_TEXTNODE"

	partial void EnterRule_XML_COMMENT();
	partial void LeaveRule_XML_COMMENT();

	// $ANTLR start "XML_COMMENT"
	[GrammarRule("XML_COMMENT")]
	private void mXML_COMMENT()
	{
		EnterRule_XML_COMMENT();
		EnterRule("XML_COMMENT", 119);
		TraceIn("XML_COMMENT", 119);
		try
		{
			// AS3.g:1194:2: ( '<!--' ( XML_WS |~ ( '-' | XML_WS ) | ( '-' ~ '-' )=> '-' )* '-->' )
			DebugEnterAlt(1);
			// AS3.g:1194:4: '<!--' ( XML_WS |~ ( '-' | XML_WS ) | ( '-' ~ '-' )=> '-' )* '-->'
			{
			DebugLocation(1194, 4);
			Match("<!--"); if (state.failed) return;

			DebugLocation(1195, 3);
			// AS3.g:1195:3: ( XML_WS |~ ( '-' | XML_WS ) | ( '-' ~ '-' )=> '-' )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=4;
				try { DebugEnterDecision(16, false);
				int LA16_1 = input.LA(1);

				if ((LA16_1=='-'))
				{
					int LA16_2 = input.LA(2);

					if ((LA16_2=='-'))
					{
						int LA16_3 = input.LA(3);

						if ((LA16_3=='>'))
						{
							int LA16_4 = input.LA(4);

							if ((LA16_4=='-') && (EvaluatePredicate(synpred3_AS3_fragment)))
							{
								alt16 = 3;
							}
							else if (((LA16_4>='\t' && LA16_4<='\n')||(LA16_4>='\f' && LA16_4<='\r')||LA16_4==' ') && (EvaluatePredicate(synpred3_AS3_fragment)))
							{
								alt16 = 3;
							}
							else if (((LA16_4>='\u0000' && LA16_4<='\b')||LA16_4=='\u000B'||(LA16_4>='\u000E' && LA16_4<='\u001F')||(LA16_4>='!' && LA16_4<=',')||(LA16_4>='.' && LA16_4<='\uFFFF')) && (EvaluatePredicate(synpred3_AS3_fragment)))
							{
								alt16 = 3;
							}


						}
						else if ((LA16_3=='-') && (EvaluatePredicate(synpred3_AS3_fragment)))
						{
							alt16 = 3;
						}
						else if (((LA16_3>='\t' && LA16_3<='\n')||(LA16_3>='\f' && LA16_3<='\r')||LA16_3==' ') && (EvaluatePredicate(synpred3_AS3_fragment)))
						{
							alt16 = 3;
						}
						else if (((LA16_3>='\u0000' && LA16_3<='\b')||LA16_3=='\u000B'||(LA16_3>='\u000E' && LA16_3<='\u001F')||(LA16_3>='!' && LA16_3<=',')||(LA16_3>='.' && LA16_3<='=')||(LA16_3>='?' && LA16_3<='\uFFFF')) && (EvaluatePredicate(synpred3_AS3_fragment)))
						{
							alt16 = 3;
						}


					}
					else if (((LA16_2>='\t' && LA16_2<='\n')||(LA16_2>='\f' && LA16_2<='\r')||LA16_2==' ') && (EvaluatePredicate(synpred3_AS3_fragment)))
					{
						alt16 = 3;
					}
					else if (((LA16_2>='\u0000' && LA16_2<='\b')||LA16_2=='\u000B'||(LA16_2>='\u000E' && LA16_2<='\u001F')||(LA16_2>='!' && LA16_2<=',')||(LA16_2>='.' && LA16_2<='\uFFFF')) && (EvaluatePredicate(synpred3_AS3_fragment)))
					{
						alt16 = 3;
					}


				}
				else if (((LA16_1>='\t' && LA16_1<='\n')||(LA16_1>='\f' && LA16_1<='\r')||LA16_1==' '))
				{
					alt16 = 1;
				}
				else if (((LA16_1>='\u0000' && LA16_1<='\b')||LA16_1=='\u000B'||(LA16_1>='\u000E' && LA16_1<='\u001F')||(LA16_1>='!' && LA16_1<=',')||(LA16_1>='.' && LA16_1<='\uFFFF')))
				{
					alt16 = 2;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1196:4: XML_WS
					{
					DebugLocation(1196, 4);
					mXML_WS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1197:5: ~ ( '-' | XML_WS )
					{
					DebugLocation(1197, 5);
					input.Consume();
					state.failed=false;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// AS3.g:1198:5: ( '-' ~ '-' )=> '-'
					{
					DebugLocation(1198, 19);
					Match('-'); if (state.failed) return;

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(1200, 3);
			Match("-->"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("XML_COMMENT", 119);
			LeaveRule("XML_COMMENT", 119);
			LeaveRule_XML_COMMENT();
		}
	}
	// $ANTLR end "XML_COMMENT"

	partial void EnterRule_XML_CDATA();
	partial void LeaveRule_XML_CDATA();

	// $ANTLR start "XML_CDATA"
	[GrammarRule("XML_CDATA")]
	private void mXML_CDATA()
	{
		EnterRule_XML_CDATA();
		EnterRule("XML_CDATA", 120);
		TraceIn("XML_CDATA", 120);
		try
		{
			// AS3.g:1204:2: ( '<![CDATA[' ( XML_WS | ( ']' ~ ']' )=> ']' |~ ( ']' | XML_WS ) )* ']]>' )
			DebugEnterAlt(1);
			// AS3.g:1204:4: '<![CDATA[' ( XML_WS | ( ']' ~ ']' )=> ']' |~ ( ']' | XML_WS ) )* ']]>'
			{
			DebugLocation(1204, 4);
			Match("<![CDATA["); if (state.failed) return;

			DebugLocation(1205, 3);
			// AS3.g:1205:3: ( XML_WS | ( ']' ~ ']' )=> ']' |~ ( ']' | XML_WS ) )*
			try { DebugEnterSubRule(17);
			while (true)
			{
				int alt17=4;
				try { DebugEnterDecision(17, false);
				int LA17_1 = input.LA(1);

				if ((LA17_1==']'))
				{
					int LA17_2 = input.LA(2);

					if ((LA17_2==']'))
					{
						int LA17_3 = input.LA(3);

						if ((LA17_3=='>'))
						{
							int LA17_4 = input.LA(4);

							if ((LA17_4==']') && (EvaluatePredicate(synpred4_AS3_fragment)))
							{
								alt17 = 2;
							}
							else if (((LA17_4>='\t' && LA17_4<='\n')||(LA17_4>='\f' && LA17_4<='\r')||LA17_4==' ') && (EvaluatePredicate(synpred4_AS3_fragment)))
							{
								alt17 = 2;
							}
							else if (((LA17_4>='\u0000' && LA17_4<='\b')||LA17_4=='\u000B'||(LA17_4>='\u000E' && LA17_4<='\u001F')||(LA17_4>='!' && LA17_4<='\\')||(LA17_4>='^' && LA17_4<='\uFFFF')) && (EvaluatePredicate(synpred4_AS3_fragment)))
							{
								alt17 = 2;
							}


						}
						else if ((LA17_3==']') && (EvaluatePredicate(synpred4_AS3_fragment)))
						{
							alt17 = 2;
						}
						else if (((LA17_3>='\t' && LA17_3<='\n')||(LA17_3>='\f' && LA17_3<='\r')||LA17_3==' ') && (EvaluatePredicate(synpred4_AS3_fragment)))
						{
							alt17 = 2;
						}
						else if (((LA17_3>='\u0000' && LA17_3<='\b')||LA17_3=='\u000B'||(LA17_3>='\u000E' && LA17_3<='\u001F')||(LA17_3>='!' && LA17_3<='=')||(LA17_3>='?' && LA17_3<='\\')||(LA17_3>='^' && LA17_3<='\uFFFF')) && (EvaluatePredicate(synpred4_AS3_fragment)))
						{
							alt17 = 2;
						}


					}
					else if (((LA17_2>='\t' && LA17_2<='\n')||(LA17_2>='\f' && LA17_2<='\r')||LA17_2==' ') && (EvaluatePredicate(synpred4_AS3_fragment)))
					{
						alt17 = 2;
					}
					else if (((LA17_2>='\u0000' && LA17_2<='\b')||LA17_2=='\u000B'||(LA17_2>='\u000E' && LA17_2<='\u001F')||(LA17_2>='!' && LA17_2<='\\')||(LA17_2>='^' && LA17_2<='\uFFFF')) && (EvaluatePredicate(synpred4_AS3_fragment)))
					{
						alt17 = 2;
					}


				}
				else if (((LA17_1>='\t' && LA17_1<='\n')||(LA17_1>='\f' && LA17_1<='\r')||LA17_1==' '))
				{
					alt17 = 1;
				}
				else if (((LA17_1>='\u0000' && LA17_1<='\b')||LA17_1=='\u000B'||(LA17_1>='\u000E' && LA17_1<='\u001F')||(LA17_1>='!' && LA17_1<='\\')||(LA17_1>='^' && LA17_1<='\uFFFF')))
				{
					alt17 = 3;
				}


				} finally { DebugExitDecision(17); }
				switch ( alt17 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1205:6: XML_WS
					{
					DebugLocation(1205, 6);
					mXML_WS(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1206:12: ( ']' ~ ']' )=> ']'
					{
					DebugLocation(1206, 26);
					Match(']'); if (state.failed) return;

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// AS3.g:1207:12: ~ ( ']' | XML_WS )
					{
					DebugLocation(1207, 12);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop17;
				}
			}

			loop17:
				;

			} finally { DebugExitSubRule(17); }

			DebugLocation(1209, 3);
			Match("]]>"); if (state.failed) return;


			}

		}
		finally
		{
			TraceOut("XML_CDATA", 120);
			LeaveRule("XML_CDATA", 120);
			LeaveRule_XML_CDATA();
		}
	}
	// $ANTLR end "XML_CDATA"

	partial void EnterRule_XML_WS();
	partial void LeaveRule_XML_WS();

	// $ANTLR start "XML_WS"
	[GrammarRule("XML_WS")]
	private void mXML_WS()
	{
		EnterRule_XML_WS();
		EnterRule("XML_WS", 121);
		TraceIn("XML_WS", 121);
		try
		{
			// AS3.g:1213:5: ( ' ' | '\\t' | '\\f' | '\\r' | '\\n' )
			DebugEnterAlt(1);
			// AS3.g:
			{
			DebugLocation(1213, 5);
			if ((input.LA(1)>='\t' && input.LA(1)<='\n')||(input.LA(1)>='\f' && input.LA(1)<='\r')||input.LA(1)==' ')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("XML_WS", 121);
			LeaveRule("XML_WS", 121);
			LeaveRule_XML_WS();
		}
	}
	// $ANTLR end "XML_WS"

	partial void EnterRule_SL();
	partial void LeaveRule_SL();

	// $ANTLR start "SL"
	[GrammarRule("SL")]
	private void mSL()
	{
		EnterRule_SL();
		EnterRule("SL", 122);
		TraceIn("SL", 122);
		try
		{
			int _type = SL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1222:6: ( '<<' )
			DebugEnterAlt(1);
			// AS3.g:1222:8: '<<'
			{
			DebugLocation(1222, 8);
			Match("<<"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SL", 122);
			LeaveRule("SL", 122);
			LeaveRule_SL();
		}
	}
	// $ANTLR end "SL"

	partial void EnterRule_SL_ASSIGN();
	partial void LeaveRule_SL_ASSIGN();

	// $ANTLR start "SL_ASSIGN"
	[GrammarRule("SL_ASSIGN")]
	private void mSL_ASSIGN()
	{
		EnterRule_SL_ASSIGN();
		EnterRule("SL_ASSIGN", 123);
		TraceIn("SL_ASSIGN", 123);
		try
		{
			int _type = SL_ASSIGN;
			int _channel = DefaultTokenChannel;
			// AS3.g:1223:11: ( '<<=' )
			DebugEnterAlt(1);
			// AS3.g:1223:13: '<<='
			{
			DebugLocation(1223, 13);
			Match("<<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SL_ASSIGN", 123);
			LeaveRule("SL_ASSIGN", 123);
			LeaveRule_SL_ASSIGN();
		}
	}
	// $ANTLR end "SL_ASSIGN"

	partial void EnterRule_LE();
	partial void LeaveRule_LE();

	// $ANTLR start "LE"
	[GrammarRule("LE")]
	private void mLE()
	{
		EnterRule_LE();
		EnterRule("LE", 124);
		TraceIn("LE", 124);
		try
		{
			int _type = LE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1224:6: ( '<=' )
			DebugEnterAlt(1);
			// AS3.g:1224:8: '<='
			{
			DebugLocation(1224, 8);
			Match("<="); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LE", 124);
			LeaveRule("LE", 124);
			LeaveRule_LE();
		}
	}
	// $ANTLR end "LE"

	partial void EnterRule_LT();
	partial void LeaveRule_LT();

	// $ANTLR start "LT"
	[GrammarRule("LT")]
	private void mLT()
	{
		EnterRule_LT();
		EnterRule("LT", 125);
		TraceIn("LT", 125);
		try
		{
			int _type = LT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1225:6: ( '<' )
			DebugEnterAlt(1);
			// AS3.g:1225:8: '<'
			{
			DebugLocation(1225, 8);
			Match('<'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("LT", 125);
			LeaveRule("LT", 125);
			LeaveRule_LT();
		}
	}
	// $ANTLR end "LT"

	partial void EnterRule_IDENT();
	partial void LeaveRule_IDENT();

	// $ANTLR start "IDENT"
	[GrammarRule("IDENT")]
	private void mIDENT()
	{
		EnterRule_IDENT();
		EnterRule("IDENT", 126);
		TraceIn("IDENT", 126);
		try
		{
			int _type = IDENT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1229:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '$' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )* )
			DebugEnterAlt(1);
			// AS3.g:1230:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '$' ) ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )*
			{
			DebugLocation(1230, 9);
			if (input.LA(1)=='$'||(input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(1231, 6);
			// AS3.g:1231:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' | '$' )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1=='$'||(LA18_1>='0' && LA18_1<='9')||(LA18_1>='A' && LA18_1<='Z')||LA18_1=='_'||(LA18_1>='a' && LA18_1<='z')))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1231, 6);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("IDENT", 126);
			LeaveRule("IDENT", 126);
			LeaveRule_IDENT();
		}
	}
	// $ANTLR end "IDENT"

	partial void EnterRule_STRING_LITERAL_DOUBLE();
	partial void LeaveRule_STRING_LITERAL_DOUBLE();

	// $ANTLR start "STRING_LITERAL_DOUBLE"
	[GrammarRule("STRING_LITERAL_DOUBLE")]
	private void mSTRING_LITERAL_DOUBLE()
	{
		EnterRule_STRING_LITERAL_DOUBLE();
		EnterRule("STRING_LITERAL_DOUBLE", 127);
		TraceIn("STRING_LITERAL_DOUBLE", 127);
		try
		{
			int _type = STRING_LITERAL_DOUBLE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1235:2: ( '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"' )
			DebugEnterAlt(1);
			// AS3.g:1235:4: '\"' ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )* '\"'
			{
			DebugLocation(1235, 4);
			Match('\"'); if (state.failed) return;
			DebugLocation(1235, 8);
			// AS3.g:1235:8: ( ESC |~ ( '\"' | '\\\\' | '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=3;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1=='\\'))
				{
					alt19 = 1;
				}
				else if (((LA19_1>='\u0000' && LA19_1<='\t')||(LA19_1>='\u000B' && LA19_1<='\f')||(LA19_1>='\u000E' && LA19_1<='!')||(LA19_1>='#' && LA19_1<='[')||(LA19_1>=']' && LA19_1<='\uFFFF')))
				{
					alt19 = 2;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1235:9: ESC
					{
					DebugLocation(1235, 9);
					mESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1235:13: ~ ( '\"' | '\\\\' | '\\n' | '\\r' )
					{
					DebugLocation(1235, 13);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(1235, 37);
			Match('\"'); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL_DOUBLE", 127);
			LeaveRule("STRING_LITERAL_DOUBLE", 127);
			LeaveRule_STRING_LITERAL_DOUBLE();
		}
	}
	// $ANTLR end "STRING_LITERAL_DOUBLE"

	partial void EnterRule_STRING_LITERAL_SINGLE();
	partial void LeaveRule_STRING_LITERAL_SINGLE();

	// $ANTLR start "STRING_LITERAL_SINGLE"
	[GrammarRule("STRING_LITERAL_SINGLE")]
	private void mSTRING_LITERAL_SINGLE()
	{
		EnterRule_STRING_LITERAL_SINGLE();
		EnterRule("STRING_LITERAL_SINGLE", 128);
		TraceIn("STRING_LITERAL_SINGLE", 128);
		try
		{
			int _type = STRING_LITERAL_SINGLE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1239:2: ( '\\'' ( ESC |~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) )* '\\'' )
			DebugEnterAlt(1);
			// AS3.g:1239:4: '\\'' ( ESC |~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) )* '\\''
			{
			DebugLocation(1239, 4);
			Match('\''); if (state.failed) return;
			DebugLocation(1239, 9);
			// AS3.g:1239:9: ( ESC |~ ( '\\'' | '\\\\' | '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=3;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1=='\\'))
				{
					alt20 = 1;
				}
				else if (((LA20_1>='\u0000' && LA20_1<='\t')||(LA20_1>='\u000B' && LA20_1<='\f')||(LA20_1>='\u000E' && LA20_1<='&')||(LA20_1>='(' && LA20_1<='[')||(LA20_1>=']' && LA20_1<='\uFFFF')))
				{
					alt20 = 2;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1239:10: ESC
					{
					DebugLocation(1239, 10);
					mESC(); if (state.failed) return;

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// AS3.g:1239:14: ~ ( '\\'' | '\\\\' | '\\n' | '\\r' )
					{
					DebugLocation(1239, 14);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(1239, 39);
			Match('\''); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("STRING_LITERAL_SINGLE", 128);
			LeaveRule("STRING_LITERAL_SINGLE", 128);
			LeaveRule_STRING_LITERAL_SINGLE();
		}
	}
	// $ANTLR end "STRING_LITERAL_SINGLE"

	partial void EnterRule_HEX_LITERAL();
	partial void LeaveRule_HEX_LITERAL();

	// $ANTLR start "HEX_LITERAL"
	[GrammarRule("HEX_LITERAL")]
	private void mHEX_LITERAL()
	{
		EnterRule_HEX_LITERAL();
		EnterRule("HEX_LITERAL", 129);
		TraceIn("HEX_LITERAL", 129);
		try
		{
			int _type = HEX_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1243:13: ( '0' ( 'x' | 'X' ) ( HEX_DIGIT )+ )
			DebugEnterAlt(1);
			// AS3.g:1243:15: '0' ( 'x' | 'X' ) ( HEX_DIGIT )+
			{
			DebugLocation(1243, 15);
			Match('0'); if (state.failed) return;
			DebugLocation(1243, 19);
			if (input.LA(1)=='X'||input.LA(1)=='x')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(1243, 29);
			// AS3.g:1243:29: ( HEX_DIGIT )+
			int cnt21=0;
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if (((LA21_1>='0' && LA21_1<='9')||(LA21_1>='A' && LA21_1<='F')||(LA21_1>='a' && LA21_1<='f')))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch (alt21)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1243, 29);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt21 >= 1)
						goto loop21;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee21 = new EarlyExitException( 21, input );
					DebugRecognitionException(eee21);
					throw eee21;
				}
				cnt21++;
			}
			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("HEX_LITERAL", 129);
			LeaveRule("HEX_LITERAL", 129);
			LeaveRule_HEX_LITERAL();
		}
	}
	// $ANTLR end "HEX_LITERAL"

	partial void EnterRule_DECIMAL_LITERAL();
	partial void LeaveRule_DECIMAL_LITERAL();

	// $ANTLR start "DECIMAL_LITERAL"
	[GrammarRule("DECIMAL_LITERAL")]
	private void mDECIMAL_LITERAL()
	{
		EnterRule_DECIMAL_LITERAL();
		EnterRule("DECIMAL_LITERAL", 130);
		TraceIn("DECIMAL_LITERAL", 130);
		try
		{
			int _type = DECIMAL_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1245:17: ( ( '0' | '1' .. '9' ( '0' .. '9' )* ) )
			DebugEnterAlt(1);
			// AS3.g:1245:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )
			{
			DebugLocation(1245, 19);
			// AS3.g:1245:19: ( '0' | '1' .. '9' ( '0' .. '9' )* )
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1=='0'))
			{
				alt23 = 1;
			}
			else if (((LA23_1>='1' && LA23_1<='9')))
			{
				alt23 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 23, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1245:20: '0'
				{
				DebugLocation(1245, 20);
				Match('0'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1245:26: '1' .. '9' ( '0' .. '9' )*
				{
				DebugLocation(1245, 29);
				MatchRange('1','9'); if (state.failed) return;
				DebugLocation(1245, 38);
				// AS3.g:1245:38: ( '0' .. '9' )*
				try { DebugEnterSubRule(22);
				while (true)
				{
					int alt22=2;
					try { DebugEnterDecision(22, false);
					int LA22_1 = input.LA(1);

					if (((LA22_1>='0' && LA22_1<='9')))
					{
						alt22 = 1;
					}


					} finally { DebugExitDecision(22); }
					switch ( alt22 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:
						{
						DebugLocation(1245, 38);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop22;
					}
				}

				loop22:
					;

				} finally { DebugExitSubRule(22); }


				}
				break;

			}
			} finally { DebugExitSubRule(23); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DECIMAL_LITERAL", 130);
			LeaveRule("DECIMAL_LITERAL", 130);
			LeaveRule_DECIMAL_LITERAL();
		}
	}
	// $ANTLR end "DECIMAL_LITERAL"

	partial void EnterRule_OCTAL_LITERAL();
	partial void LeaveRule_OCTAL_LITERAL();

	// $ANTLR start "OCTAL_LITERAL"
	[GrammarRule("OCTAL_LITERAL")]
	private void mOCTAL_LITERAL()
	{
		EnterRule_OCTAL_LITERAL();
		EnterRule("OCTAL_LITERAL", 131);
		TraceIn("OCTAL_LITERAL", 131);
		try
		{
			int _type = OCTAL_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1247:15: ( '0' ( '0' .. '7' )+ )
			DebugEnterAlt(1);
			// AS3.g:1247:17: '0' ( '0' .. '7' )+
			{
			DebugLocation(1247, 17);
			Match('0'); if (state.failed) return;
			DebugLocation(1247, 21);
			// AS3.g:1247:21: ( '0' .. '7' )+
			int cnt24=0;
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if (((LA24_1>='0' && LA24_1<='7')))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1247, 21);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt24 >= 1)
						goto loop24;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee24 = new EarlyExitException( 24, input );
					DebugRecognitionException(eee24);
					throw eee24;
				}
				cnt24++;
			}
			loop24:
				;

			} finally { DebugExitSubRule(24); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("OCTAL_LITERAL", 131);
			LeaveRule("OCTAL_LITERAL", 131);
			LeaveRule_OCTAL_LITERAL();
		}
	}
	// $ANTLR end "OCTAL_LITERAL"

	partial void EnterRule_FLOAT_LITERAL();
	partial void LeaveRule_FLOAT_LITERAL();

	// $ANTLR start "FLOAT_LITERAL"
	[GrammarRule("FLOAT_LITERAL")]
	private void mFLOAT_LITERAL()
	{
		EnterRule_FLOAT_LITERAL();
		EnterRule("FLOAT_LITERAL", 132);
		TraceIn("FLOAT_LITERAL", 132);
		try
		{
			int _type = FLOAT_LITERAL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1250:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? )
			int alt30=2;
			try { DebugEnterDecision(30, false);
			int LA30_1 = input.LA(1);

			if (((LA30_1>='0' && LA30_1<='9')))
			{
				alt30 = 1;
			}
			else if ((LA30_1=='.'))
			{
				alt30 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 30, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(30); }
			switch (alt30)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1250:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
				{
				DebugLocation(1250, 9);
				// AS3.g:1250:9: ( '0' .. '9' )+
				int cnt25=0;
				try { DebugEnterSubRule(25);
				while (true)
				{
					int alt25=2;
					try { DebugEnterDecision(25, false);
					int LA25_1 = input.LA(1);

					if (((LA25_1>='0' && LA25_1<='9')))
					{
						alt25 = 1;
					}


					} finally { DebugExitDecision(25); }
					switch (alt25)
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:
						{
						DebugLocation(1250, 9);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt25 >= 1)
							goto loop25;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee25 = new EarlyExitException( 25, input );
						DebugRecognitionException(eee25);
						throw eee25;
					}
					cnt25++;
				}
				loop25:
					;

				} finally { DebugExitSubRule(25); }

				DebugLocation(1250, 21);
				Match('.'); if (state.failed) return;
				DebugLocation(1250, 25);
				// AS3.g:1250:25: ( '0' .. '9' )*
				try { DebugEnterSubRule(26);
				while (true)
				{
					int alt26=2;
					try { DebugEnterDecision(26, false);
					int LA26_1 = input.LA(1);

					if (((LA26_1>='0' && LA26_1<='9')))
					{
						alt26 = 1;
					}


					} finally { DebugExitDecision(26); }
					switch ( alt26 )
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:
						{
						DebugLocation(1250, 25);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						goto loop26;
					}
				}

				loop26:
					;

				} finally { DebugExitSubRule(26); }

				DebugLocation(1250, 37);
				// AS3.g:1250:37: ( EXPONENT )?
				int alt27=2;
				try { DebugEnterSubRule(27);
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1=='E'||LA27_1=='e'))
				{
					alt27 = 1;
				}
				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1250:37: EXPONENT
					{
					DebugLocation(1250, 37);
					mEXPONENT(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(27); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1251:9: '.' ( '0' .. '9' )+ ( EXPONENT )?
				{
				DebugLocation(1251, 9);
				Match('.'); if (state.failed) return;
				DebugLocation(1251, 13);
				// AS3.g:1251:13: ( '0' .. '9' )+
				int cnt28=0;
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, false);
					int LA28_1 = input.LA(1);

					if (((LA28_1>='0' && LA28_1<='9')))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch (alt28)
					{
					case 1:
						DebugEnterAlt(1);
						// AS3.g:
						{
						DebugLocation(1251, 13);
						input.Consume();
						state.failed=false;

						}
						break;

					default:
						if (cnt28 >= 1)
							goto loop28;

						if (state.backtracking>0) {state.failed=true; return;}
						EarlyExitException eee28 = new EarlyExitException( 28, input );
						DebugRecognitionException(eee28);
						throw eee28;
					}
					cnt28++;
				}
				loop28:
					;

				} finally { DebugExitSubRule(28); }

				DebugLocation(1251, 25);
				// AS3.g:1251:25: ( EXPONENT )?
				int alt29=2;
				try { DebugEnterSubRule(29);
				try { DebugEnterDecision(29, false);
				int LA29_1 = input.LA(1);

				if ((LA29_1=='E'||LA29_1=='e'))
				{
					alt29 = 1;
				}
				} finally { DebugExitDecision(29); }
				switch (alt29)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1251:25: EXPONENT
					{
					DebugLocation(1251, 25);
					mEXPONENT(); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(29); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT_LITERAL", 132);
			LeaveRule("FLOAT_LITERAL", 132);
			LeaveRule_FLOAT_LITERAL();
		}
	}
	// $ANTLR end "FLOAT_LITERAL"

	partial void EnterRule_WS();
	partial void LeaveRule_WS();

	// $ANTLR start "WS"
	[GrammarRule("WS")]
	private void mWS()
	{
		EnterRule_WS();
		EnterRule("WS", 133);
		TraceIn("WS", 133);
		try
		{
			int _type = WS;
			int _channel = DefaultTokenChannel;
			// AS3.g:1256:4: ( ( ' ' | '\\t' | '\\f' )+ )
			DebugEnterAlt(1);
			// AS3.g:1256:6: ( ' ' | '\\t' | '\\f' )+
			{
			DebugLocation(1256, 6);
			// AS3.g:1256:6: ( ' ' | '\\t' | '\\f' )+
			int cnt31=0;
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				int LA31_1 = input.LA(1);

				if ((LA31_1=='\t'||LA31_1=='\f'||LA31_1==' '))
				{
					alt31 = 1;
				}


				} finally { DebugExitDecision(31); }
				switch (alt31)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1256, 6);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt31 >= 1)
						goto loop31;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee31 = new EarlyExitException( 31, input );
					DebugRecognitionException(eee31);
					throw eee31;
				}
				cnt31++;
			}
			loop31:
				;

			} finally { DebugExitSubRule(31); }

			DebugLocation(1261, 3);
			if (state.backtracking == 0)
			{
				_channel=Hidden;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WS", 133);
			LeaveRule("WS", 133);
			LeaveRule_WS();
		}
	}
	// $ANTLR end "WS"

	partial void EnterRule_NL();
	partial void LeaveRule_NL();

	// $ANTLR start "NL"
	[GrammarRule("NL")]
	private void mNL()
	{
		EnterRule_NL();
		EnterRule("NL", 134);
		TraceIn("NL", 134);
		try
		{
			int _type = NL;
			int _channel = DefaultTokenChannel;
			// AS3.g:1264:2: ( ( '\\r' '\\n' | '\\r' | '\\n' ) )
			DebugEnterAlt(1);
			// AS3.g:1264:4: ( '\\r' '\\n' | '\\r' | '\\n' )
			{
			DebugLocation(1264, 4);
			// AS3.g:1264:4: ( '\\r' '\\n' | '\\r' | '\\n' )
			int alt32=3;
			try { DebugEnterSubRule(32);
			try { DebugEnterDecision(32, false);
			int LA32_1 = input.LA(1);

			if ((LA32_1=='\r'))
			{
				int LA32_2 = input.LA(2);

				if ((LA32_2=='\n'))
				{
					alt32 = 1;
				}
				else
				{
					alt32 = 2;
				}
			}
			else if ((LA32_1=='\n'))
			{
				alt32 = 3;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 32, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(32); }
			switch (alt32)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1265:4: '\\r' '\\n'
				{
				DebugLocation(1265, 4);
				Match('\r'); if (state.failed) return;
				DebugLocation(1265, 9);
				Match('\n'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1266:5: '\\r'
				{
				DebugLocation(1266, 5);
				Match('\r'); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:1267:5: '\\n'
				{
				DebugLocation(1267, 5);
				Match('\n'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(32); }

			DebugLocation(1269, 3);
			if (state.backtracking == 0)
			{
				_channel=Hidden;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("NL", 134);
			LeaveRule("NL", 134);
			LeaveRule_NL();
		}
	}
	// $ANTLR end "NL"

	partial void EnterRule_BOM();
	partial void LeaveRule_BOM();

	// $ANTLR start "BOM"
	[GrammarRule("BOM")]
	private void mBOM()
	{
		EnterRule_BOM();
		EnterRule("BOM", 135);
		TraceIn("BOM", 135);
		try
		{
			int _type = BOM;
			int _channel = DefaultTokenChannel;
			// AS3.g:1273:5: ( ( '\\u00EF' '\\u00BB' '\\u00BF' | '\\uFEFF' ) )
			DebugEnterAlt(1);
			// AS3.g:1273:7: ( '\\u00EF' '\\u00BB' '\\u00BF' | '\\uFEFF' )
			{
			DebugLocation(1273, 7);
			// AS3.g:1273:7: ( '\\u00EF' '\\u00BB' '\\u00BF' | '\\uFEFF' )
			int alt33=2;
			try { DebugEnterSubRule(33);
			try { DebugEnterDecision(33, false);
			int LA33_1 = input.LA(1);

			if ((LA33_1=='\u00EF'))
			{
				alt33 = 1;
			}
			else if ((LA33_1=='\uFEFF'))
			{
				alt33 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 33, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(33); }
			switch (alt33)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1273:9: '\\u00EF' '\\u00BB' '\\u00BF'
				{
				DebugLocation(1273, 9);
				Match('\u00EF'); if (state.failed) return;
				DebugLocation(1273, 19);
				Match('\u00BB'); if (state.failed) return;
				DebugLocation(1273, 28);
				Match('\u00BF'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1274:5: '\\uFEFF'
				{
				DebugLocation(1274, 5);
				Match('\uFEFF'); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(33); }

			DebugLocation(1276, 3);
			if (state.backtracking == 0)
			{
				 _channel=Hidden; 
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("BOM", 135);
			LeaveRule("BOM", 135);
			LeaveRule_BOM();
		}
	}
	// $ANTLR end "BOM"

	partial void EnterRule_INCLUDE_DIRECTIVE();
	partial void LeaveRule_INCLUDE_DIRECTIVE();

	// $ANTLR start "INCLUDE_DIRECTIVE"
	[GrammarRule("INCLUDE_DIRECTIVE")]
	private void mINCLUDE_DIRECTIVE()
	{
		EnterRule_INCLUDE_DIRECTIVE();
		EnterRule("INCLUDE_DIRECTIVE", 136);
		TraceIn("INCLUDE_DIRECTIVE", 136);
		try
		{
			int _type = INCLUDE_DIRECTIVE;
			int _channel = DefaultTokenChannel;
			// AS3.g:1280:2: ( '#include' )
			DebugEnterAlt(1);
			// AS3.g:1280:4: '#include'
			{
			DebugLocation(1280, 4);
			Match("#include"); if (state.failed) return;


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INCLUDE_DIRECTIVE", 136);
			LeaveRule("INCLUDE_DIRECTIVE", 136);
			LeaveRule_INCLUDE_DIRECTIVE();
		}
	}
	// $ANTLR end "INCLUDE_DIRECTIVE"

	partial void EnterRule_SL_COMMENT();
	partial void LeaveRule_SL_COMMENT();

	// $ANTLR start "SL_COMMENT"
	[GrammarRule("SL_COMMENT")]
	private void mSL_COMMENT()
	{
		EnterRule_SL_COMMENT();
		EnterRule("SL_COMMENT", 137);
		TraceIn("SL_COMMENT", 137);
		try
		{
			int _type = SL_COMMENT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1285:2: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\n' | '\\r' ( '\\n' )? )? )
			DebugEnterAlt(1);
			// AS3.g:1285:4: '//' (~ ( '\\n' | '\\r' ) )* ( '\\n' | '\\r' ( '\\n' )? )?
			{
			DebugLocation(1285, 4);
			Match("//"); if (state.failed) return;

			DebugLocation(1285, 9);
			// AS3.g:1285:9: (~ ( '\\n' | '\\r' ) )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				int LA34_1 = input.LA(1);

				if (((LA34_1>='\u0000' && LA34_1<='\t')||(LA34_1>='\u000B' && LA34_1<='\f')||(LA34_1>='\u000E' && LA34_1<='\uFFFF')))
				{
					alt34 = 1;
				}


				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1285, 9);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }

			DebugLocation(1285, 25);
			// AS3.g:1285:25: ( '\\n' | '\\r' ( '\\n' )? )?
			int alt36=3;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1=='\n'))
			{
				alt36 = 1;
			}
			else if ((LA36_1=='\r'))
			{
				alt36 = 2;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1285:26: '\\n'
				{
				DebugLocation(1285, 26);
				Match('\n'); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1285:31: '\\r' ( '\\n' )?
				{
				DebugLocation(1285, 31);
				Match('\r'); if (state.failed) return;
				DebugLocation(1285, 35);
				// AS3.g:1285:35: ( '\\n' )?
				int alt35=2;
				try { DebugEnterSubRule(35);
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1=='\n'))
				{
					alt35 = 1;
				}
				} finally { DebugExitDecision(35); }
				switch (alt35)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1285:36: '\\n'
					{
					DebugLocation(1285, 36);
					Match('\n'); if (state.failed) return;

					}
					break;

				}
				} finally { DebugExitSubRule(35); }


				}
				break;

			}
			} finally { DebugExitSubRule(36); }

			DebugLocation(1286, 3);
			if (state.backtracking == 0)
			{
				_channel=Hidden;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("SL_COMMENT", 137);
			LeaveRule("SL_COMMENT", 137);
			LeaveRule_SL_COMMENT();
		}
	}
	// $ANTLR end "SL_COMMENT"

	partial void EnterRule_ML_COMMENT();
	partial void LeaveRule_ML_COMMENT();

	// $ANTLR start "ML_COMMENT"
	[GrammarRule("ML_COMMENT")]
	private void mML_COMMENT()
	{
		EnterRule_ML_COMMENT();
		EnterRule("ML_COMMENT", 138);
		TraceIn("ML_COMMENT", 138);
		try
		{
			int _type = ML_COMMENT;
			int _channel = DefaultTokenChannel;
			// AS3.g:1290:2: ( '/*' ( options {greedy=false; } : . )* '*/' )
			DebugEnterAlt(1);
			// AS3.g:1290:4: '/*' ( options {greedy=false; } : . )* '*/'
			{
			DebugLocation(1290, 4);
			Match("/*"); if (state.failed) return;

			DebugLocation(1290, 9);
			// AS3.g:1290:9: ( options {greedy=false; } : . )*
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1=='*'))
				{
					int LA37_2 = input.LA(2);

					if ((LA37_2=='/'))
					{
						alt37 = 2;
					}
					else if (((LA37_2>='\u0000' && LA37_2<='.')||(LA37_2>='0' && LA37_2<='\uFFFF')))
					{
						alt37 = 1;
					}


				}
				else if (((LA37_1>='\u0000' && LA37_1<=')')||(LA37_1>='+' && LA37_1<='\uFFFF')))
				{
					alt37 = 1;
				}


				} finally { DebugExitDecision(37); }
				switch ( alt37 )
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:1290:37: .
					{
					DebugLocation(1290, 37);
					MatchAny(); if (state.failed) return;

					}
					break;

				default:
					goto loop37;
				}
			}

			loop37:
				;

			} finally { DebugExitSubRule(37); }

			DebugLocation(1290, 42);
			Match("*/"); if (state.failed) return;

			DebugLocation(1291, 3);
			if (state.backtracking == 0)
			{
				_channel=Hidden;
			}

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("ML_COMMENT", 138);
			LeaveRule("ML_COMMENT", 138);
			LeaveRule_ML_COMMENT();
		}
	}
	// $ANTLR end "ML_COMMENT"

	partial void EnterRule_EXPONENT();
	partial void LeaveRule_EXPONENT();

	// $ANTLR start "EXPONENT"
	[GrammarRule("EXPONENT")]
	private void mEXPONENT()
	{
		EnterRule_EXPONENT();
		EnterRule("EXPONENT", 139);
		TraceIn("EXPONENT", 139);
		try
		{
			// AS3.g:1295:2: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
			DebugEnterAlt(1);
			// AS3.g:1295:4: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
			{
			DebugLocation(1295, 4);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(1295, 14);
			// AS3.g:1295:14: ( '+' | '-' )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1=='+'||LA38_1=='-'))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:
				{
				DebugLocation(1295, 14);
				input.Consume();
				state.failed=false;

				}
				break;

			}
			} finally { DebugExitSubRule(38); }

			DebugLocation(1295, 25);
			// AS3.g:1295:25: ( '0' .. '9' )+
			int cnt39=0;
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if (((LA39_1>='0' && LA39_1<='9')))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch (alt39)
				{
				case 1:
					DebugEnterAlt(1);
					// AS3.g:
					{
					DebugLocation(1295, 25);
					input.Consume();
					state.failed=false;

					}
					break;

				default:
					if (cnt39 >= 1)
						goto loop39;

					if (state.backtracking>0) {state.failed=true; return;}
					EarlyExitException eee39 = new EarlyExitException( 39, input );
					DebugRecognitionException(eee39);
					throw eee39;
				}
				cnt39++;
			}
			loop39:
				;

			} finally { DebugExitSubRule(39); }


			}

		}
		finally
		{
			TraceOut("EXPONENT", 139);
			LeaveRule("EXPONENT", 139);
			LeaveRule_EXPONENT();
		}
	}
	// $ANTLR end "EXPONENT"

	partial void EnterRule_HEX_DIGIT();
	partial void LeaveRule_HEX_DIGIT();

	// $ANTLR start "HEX_DIGIT"
	[GrammarRule("HEX_DIGIT")]
	private void mHEX_DIGIT()
	{
		EnterRule_HEX_DIGIT();
		EnterRule("HEX_DIGIT", 140);
		TraceIn("HEX_DIGIT", 140);
		try
		{
			// AS3.g:1298:2: ( ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' ) )
			DebugEnterAlt(1);
			// AS3.g:
			{
			DebugLocation(1298, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("HEX_DIGIT", 140);
			LeaveRule("HEX_DIGIT", 140);
			LeaveRule_HEX_DIGIT();
		}
	}
	// $ANTLR end "HEX_DIGIT"

	partial void EnterRule_OCT_DIGIT();
	partial void LeaveRule_OCT_DIGIT();

	// $ANTLR start "OCT_DIGIT"
	[GrammarRule("OCT_DIGIT")]
	private void mOCT_DIGIT()
	{
		EnterRule_OCT_DIGIT();
		EnterRule("OCT_DIGIT", 141);
		TraceIn("OCT_DIGIT", 141);
		try
		{
			// AS3.g:1302:2: ( '0' .. '7' )
			DebugEnterAlt(1);
			// AS3.g:
			{
			DebugLocation(1302, 2);
			if ((input.LA(1)>='0' && input.LA(1)<='7'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("OCT_DIGIT", 141);
			LeaveRule("OCT_DIGIT", 141);
			LeaveRule_OCT_DIGIT();
		}
	}
	// $ANTLR end "OCT_DIGIT"

	partial void EnterRule_ESC();
	partial void LeaveRule_ESC();

	// $ANTLR start "ESC"
	[GrammarRule("ESC")]
	private void mESC()
	{
		EnterRule_ESC();
		EnterRule("ESC", 142);
		TraceIn("ESC", 142);
		try
		{
			// AS3.g:1306:2: ( CTRLCHAR_ESC | UNICODE_ESC | OCTAL_ESC )
			int alt40=3;
			try { DebugEnterDecision(40, false);
			int LA40_1 = input.LA(1);

			if ((LA40_1=='\\'))
			{
				switch (input.LA(2))
				{
				case '\"':
				case '\'':
				case '\\':
				case 'b':
				case 'f':
				case 'n':
				case 'r':
				case 't':
					{
					alt40 = 1;
					}
					break;
				case 'u':
					{
					alt40 = 2;
					}
					break;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
					{
					alt40 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return;}
						NoViableAltException nvae = new NoViableAltException("", 40, 1, input, 2);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 40, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(40); }
			switch (alt40)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1306:6: CTRLCHAR_ESC
				{
				DebugLocation(1306, 6);
				mCTRLCHAR_ESC(); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1307:6: UNICODE_ESC
				{
				DebugLocation(1307, 6);
				mUNICODE_ESC(); if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:1308:6: OCTAL_ESC
				{
				DebugLocation(1308, 6);
				mOCTAL_ESC(); if (state.failed) return;

				}
				break;

			}
		}
		finally
		{
			TraceOut("ESC", 142);
			LeaveRule("ESC", 142);
			LeaveRule_ESC();
		}
	}
	// $ANTLR end "ESC"

	partial void EnterRule_CTRLCHAR_ESC();
	partial void LeaveRule_CTRLCHAR_ESC();

	// $ANTLR start "CTRLCHAR_ESC"
	[GrammarRule("CTRLCHAR_ESC")]
	private void mCTRLCHAR_ESC()
	{
		EnterRule_CTRLCHAR_ESC();
		EnterRule("CTRLCHAR_ESC", 143);
		TraceIn("CTRLCHAR_ESC", 143);
		try
		{
			// AS3.g:1312:2: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) )
			DebugEnterAlt(1);
			// AS3.g:1312:4: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
			{
			DebugLocation(1312, 4);
			Match('\\'); if (state.failed) return;
			DebugLocation(1312, 9);
			if (input.LA(1)=='\"'||input.LA(1)=='\''||input.LA(1)=='\\'||input.LA(1)=='b'||input.LA(1)=='f'||input.LA(1)=='n'||input.LA(1)=='r'||input.LA(1)=='t')
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("CTRLCHAR_ESC", 143);
			LeaveRule("CTRLCHAR_ESC", 143);
			LeaveRule_CTRLCHAR_ESC();
		}
	}
	// $ANTLR end "CTRLCHAR_ESC"

	partial void EnterRule_OCTAL_ESC();
	partial void LeaveRule_OCTAL_ESC();

	// $ANTLR start "OCTAL_ESC"
	[GrammarRule("OCTAL_ESC")]
	private void mOCTAL_ESC()
	{
		EnterRule_OCTAL_ESC();
		EnterRule("OCTAL_ESC", 144);
		TraceIn("OCTAL_ESC", 144);
		try
		{
			// AS3.g:1316:2: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
			int alt41=3;
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1=='\\'))
			{
				int LA41_2 = input.LA(2);

				if (((LA41_2>='0' && LA41_2<='3')))
				{
					int LA41_3 = input.LA(3);

					if (((LA41_3>='0' && LA41_3<='7')))
					{
						int LA41_4 = input.LA(4);

						if (((LA41_4>='0' && LA41_4<='7')))
						{
							alt41 = 1;
						}
						else
						{
							alt41 = 2;
						}
					}
					else
					{
						alt41 = 3;
					}
				}
				else if (((LA41_2>='4' && LA41_2<='7')))
				{
					int LA41_3 = input.LA(3);

					if (((LA41_3>='0' && LA41_3<='7')))
					{
						alt41 = 2;
					}
					else
					{
						alt41 = 3;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 41, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// AS3.g:1316:6: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
				{
				DebugLocation(1316, 6);
				Match('\\'); if (state.failed) return;
				DebugLocation(1316, 11);
				input.Consume();
				state.failed=false;
				DebugLocation(1316, 22);
				input.Consume();
				state.failed=false;
				DebugLocation(1316, 33);
				input.Consume();
				state.failed=false;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// AS3.g:1317:6: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
				{
				DebugLocation(1317, 6);
				Match('\\'); if (state.failed) return;
				DebugLocation(1317, 11);
				input.Consume();
				state.failed=false;
				DebugLocation(1317, 22);
				input.Consume();
				state.failed=false;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// AS3.g:1318:6: '\\\\' ( '0' .. '7' )
				{
				DebugLocation(1318, 6);
				Match('\\'); if (state.failed) return;
				DebugLocation(1318, 11);
				input.Consume();
				state.failed=false;

				}
				break;

			}
		}
		finally
		{
			TraceOut("OCTAL_ESC", 144);
			LeaveRule("OCTAL_ESC", 144);
			LeaveRule_OCTAL_ESC();
		}
	}
	// $ANTLR end "OCTAL_ESC"

	partial void EnterRule_UNICODE_ESC();
	partial void LeaveRule_UNICODE_ESC();

	// $ANTLR start "UNICODE_ESC"
	[GrammarRule("UNICODE_ESC")]
	private void mUNICODE_ESC()
	{
		EnterRule_UNICODE_ESC();
		EnterRule("UNICODE_ESC", 145);
		TraceIn("UNICODE_ESC", 145);
		try
		{
			// AS3.g:1322:2: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
			DebugEnterAlt(1);
			// AS3.g:1322:6: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
			{
			DebugLocation(1322, 6);
			Match('\\'); if (state.failed) return;
			DebugLocation(1322, 11);
			Match('u'); if (state.failed) return;
			DebugLocation(1322, 15);
			mHEX_DIGIT(); if (state.failed) return;
			DebugLocation(1322, 25);
			mHEX_DIGIT(); if (state.failed) return;
			DebugLocation(1322, 35);
			mHEX_DIGIT(); if (state.failed) return;
			DebugLocation(1322, 45);
			mHEX_DIGIT(); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("UNICODE_ESC", 145);
			LeaveRule("UNICODE_ESC", 145);
			LeaveRule_UNICODE_ESC();
		}
	}
	// $ANTLR end "UNICODE_ESC"

	public override void mTokens()
	{
		// AS3.g:1:8: ( T__241 | T__242 | T__243 | T__244 | T__245 | T__246 | T__247 | T__248 | T__249 | T__250 | T__251 | T__252 | T__253 | T__254 | T__255 | T__256 | T__257 | PACKAGE | PUBLIC | PRIVATE | PROTECTED | INTERNAL | FUNCTION | EXTENDS | IMPLEMENTS | VAR | STATIC | IF | IMPORT | FOR | EACH | IN | WHILE | DO | SWITCH | CASE | DEFAULT | ELSE | CONST | CLASS | INTERFACE | TRUE | FALSE | DYNAMIC | USE | XML | NAMESPACE | IS | AS | GET | SET | WITH | RETURN | CONTINUE | BREAK | NULL | NEW | SUPER | QUESTION | LPAREN | RPAREN | LBRACK | RBRACK | LCURLY | RCURLY | COLON | DBL_COLON | COMMA | ASSIGN | EQUAL | STRICT_EQUAL | LNOT | BNOT | NOT_EQUAL | STRICT_NOT_EQUAL | PLUS | PLUS_ASSIGN | INC | MINUS | MINUS_ASSIGN | DEC | STAR | STAR_ASSIGN | MOD | MOD_ASSIGN | SR | SR_ASSIGN | BSR | BSR_ASSIGN | GE | GT | BXOR | BXOR_ASSIGN | BOR | BOR_ASSIGN | LOR | BAND | BAND_ASSIGN | LAND | LAND_ASSIGN | LOR_ASSIGN | E4X_ATTRI | SEMI | BSLASH | DOT | E4X_DESC | REST | REGEX_LITERAL | DIV_ASSIGN | DIV | XML_LITERAL | SL | SL_ASSIGN | LE | LT | IDENT | STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL | WS | NL | BOM | INCLUDE_DIRECTIVE | SL_COMMENT | ML_COMMENT )
		int alt42=128;
		try { DebugEnterDecision(42, false);
		try
		{
			alt42 = dfa42.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(42); }
		switch (alt42)
		{
		case 1:
			DebugEnterAlt(1);
			// AS3.g:1:10: T__241
			{
			DebugLocation(1, 10);
			mT__241(); if (state.failed) return;

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// AS3.g:1:17: T__242
			{
			DebugLocation(1, 17);
			mT__242(); if (state.failed) return;

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// AS3.g:1:24: T__243
			{
			DebugLocation(1, 24);
			mT__243(); if (state.failed) return;

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// AS3.g:1:31: T__244
			{
			DebugLocation(1, 31);
			mT__244(); if (state.failed) return;

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// AS3.g:1:38: T__245
			{
			DebugLocation(1, 38);
			mT__245(); if (state.failed) return;

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// AS3.g:1:45: T__246
			{
			DebugLocation(1, 45);
			mT__246(); if (state.failed) return;

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// AS3.g:1:52: T__247
			{
			DebugLocation(1, 52);
			mT__247(); if (state.failed) return;

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// AS3.g:1:59: T__248
			{
			DebugLocation(1, 59);
			mT__248(); if (state.failed) return;

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// AS3.g:1:66: T__249
			{
			DebugLocation(1, 66);
			mT__249(); if (state.failed) return;

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// AS3.g:1:73: T__250
			{
			DebugLocation(1, 73);
			mT__250(); if (state.failed) return;

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// AS3.g:1:80: T__251
			{
			DebugLocation(1, 80);
			mT__251(); if (state.failed) return;

			}
			break;
		case 12:
			DebugEnterAlt(12);
			// AS3.g:1:87: T__252
			{
			DebugLocation(1, 87);
			mT__252(); if (state.failed) return;

			}
			break;
		case 13:
			DebugEnterAlt(13);
			// AS3.g:1:94: T__253
			{
			DebugLocation(1, 94);
			mT__253(); if (state.failed) return;

			}
			break;
		case 14:
			DebugEnterAlt(14);
			// AS3.g:1:101: T__254
			{
			DebugLocation(1, 101);
			mT__254(); if (state.failed) return;

			}
			break;
		case 15:
			DebugEnterAlt(15);
			// AS3.g:1:108: T__255
			{
			DebugLocation(1, 108);
			mT__255(); if (state.failed) return;

			}
			break;
		case 16:
			DebugEnterAlt(16);
			// AS3.g:1:115: T__256
			{
			DebugLocation(1, 115);
			mT__256(); if (state.failed) return;

			}
			break;
		case 17:
			DebugEnterAlt(17);
			// AS3.g:1:122: T__257
			{
			DebugLocation(1, 122);
			mT__257(); if (state.failed) return;

			}
			break;
		case 18:
			DebugEnterAlt(18);
			// AS3.g:1:129: PACKAGE
			{
			DebugLocation(1, 129);
			mPACKAGE(); if (state.failed) return;

			}
			break;
		case 19:
			DebugEnterAlt(19);
			// AS3.g:1:137: PUBLIC
			{
			DebugLocation(1, 137);
			mPUBLIC(); if (state.failed) return;

			}
			break;
		case 20:
			DebugEnterAlt(20);
			// AS3.g:1:144: PRIVATE
			{
			DebugLocation(1, 144);
			mPRIVATE(); if (state.failed) return;

			}
			break;
		case 21:
			DebugEnterAlt(21);
			// AS3.g:1:152: PROTECTED
			{
			DebugLocation(1, 152);
			mPROTECTED(); if (state.failed) return;

			}
			break;
		case 22:
			DebugEnterAlt(22);
			// AS3.g:1:162: INTERNAL
			{
			DebugLocation(1, 162);
			mINTERNAL(); if (state.failed) return;

			}
			break;
		case 23:
			DebugEnterAlt(23);
			// AS3.g:1:171: FUNCTION
			{
			DebugLocation(1, 171);
			mFUNCTION(); if (state.failed) return;

			}
			break;
		case 24:
			DebugEnterAlt(24);
			// AS3.g:1:180: EXTENDS
			{
			DebugLocation(1, 180);
			mEXTENDS(); if (state.failed) return;

			}
			break;
		case 25:
			DebugEnterAlt(25);
			// AS3.g:1:188: IMPLEMENTS
			{
			DebugLocation(1, 188);
			mIMPLEMENTS(); if (state.failed) return;

			}
			break;
		case 26:
			DebugEnterAlt(26);
			// AS3.g:1:199: VAR
			{
			DebugLocation(1, 199);
			mVAR(); if (state.failed) return;

			}
			break;
		case 27:
			DebugEnterAlt(27);
			// AS3.g:1:203: STATIC
			{
			DebugLocation(1, 203);
			mSTATIC(); if (state.failed) return;

			}
			break;
		case 28:
			DebugEnterAlt(28);
			// AS3.g:1:210: IF
			{
			DebugLocation(1, 210);
			mIF(); if (state.failed) return;

			}
			break;
		case 29:
			DebugEnterAlt(29);
			// AS3.g:1:213: IMPORT
			{
			DebugLocation(1, 213);
			mIMPORT(); if (state.failed) return;

			}
			break;
		case 30:
			DebugEnterAlt(30);
			// AS3.g:1:220: FOR
			{
			DebugLocation(1, 220);
			mFOR(); if (state.failed) return;

			}
			break;
		case 31:
			DebugEnterAlt(31);
			// AS3.g:1:224: EACH
			{
			DebugLocation(1, 224);
			mEACH(); if (state.failed) return;

			}
			break;
		case 32:
			DebugEnterAlt(32);
			// AS3.g:1:229: IN
			{
			DebugLocation(1, 229);
			mIN(); if (state.failed) return;

			}
			break;
		case 33:
			DebugEnterAlt(33);
			// AS3.g:1:232: WHILE
			{
			DebugLocation(1, 232);
			mWHILE(); if (state.failed) return;

			}
			break;
		case 34:
			DebugEnterAlt(34);
			// AS3.g:1:238: DO
			{
			DebugLocation(1, 238);
			mDO(); if (state.failed) return;

			}
			break;
		case 35:
			DebugEnterAlt(35);
			// AS3.g:1:241: SWITCH
			{
			DebugLocation(1, 241);
			mSWITCH(); if (state.failed) return;

			}
			break;
		case 36:
			DebugEnterAlt(36);
			// AS3.g:1:248: CASE
			{
			DebugLocation(1, 248);
			mCASE(); if (state.failed) return;

			}
			break;
		case 37:
			DebugEnterAlt(37);
			// AS3.g:1:253: DEFAULT
			{
			DebugLocation(1, 253);
			mDEFAULT(); if (state.failed) return;

			}
			break;
		case 38:
			DebugEnterAlt(38);
			// AS3.g:1:261: ELSE
			{
			DebugLocation(1, 261);
			mELSE(); if (state.failed) return;

			}
			break;
		case 39:
			DebugEnterAlt(39);
			// AS3.g:1:266: CONST
			{
			DebugLocation(1, 266);
			mCONST(); if (state.failed) return;

			}
			break;
		case 40:
			DebugEnterAlt(40);
			// AS3.g:1:272: CLASS
			{
			DebugLocation(1, 272);
			mCLASS(); if (state.failed) return;

			}
			break;
		case 41:
			DebugEnterAlt(41);
			// AS3.g:1:278: INTERFACE
			{
			DebugLocation(1, 278);
			mINTERFACE(); if (state.failed) return;

			}
			break;
		case 42:
			DebugEnterAlt(42);
			// AS3.g:1:288: TRUE
			{
			DebugLocation(1, 288);
			mTRUE(); if (state.failed) return;

			}
			break;
		case 43:
			DebugEnterAlt(43);
			// AS3.g:1:293: FALSE
			{
			DebugLocation(1, 293);
			mFALSE(); if (state.failed) return;

			}
			break;
		case 44:
			DebugEnterAlt(44);
			// AS3.g:1:299: DYNAMIC
			{
			DebugLocation(1, 299);
			mDYNAMIC(); if (state.failed) return;

			}
			break;
		case 45:
			DebugEnterAlt(45);
			// AS3.g:1:307: USE
			{
			DebugLocation(1, 307);
			mUSE(); if (state.failed) return;

			}
			break;
		case 46:
			DebugEnterAlt(46);
			// AS3.g:1:311: XML
			{
			DebugLocation(1, 311);
			mXML(); if (state.failed) return;

			}
			break;
		case 47:
			DebugEnterAlt(47);
			// AS3.g:1:315: NAMESPACE
			{
			DebugLocation(1, 315);
			mNAMESPACE(); if (state.failed) return;

			}
			break;
		case 48:
			DebugEnterAlt(48);
			// AS3.g:1:325: IS
			{
			DebugLocation(1, 325);
			mIS(); if (state.failed) return;

			}
			break;
		case 49:
			DebugEnterAlt(49);
			// AS3.g:1:328: AS
			{
			DebugLocation(1, 328);
			mAS(); if (state.failed) return;

			}
			break;
		case 50:
			DebugEnterAlt(50);
			// AS3.g:1:331: GET
			{
			DebugLocation(1, 331);
			mGET(); if (state.failed) return;

			}
			break;
		case 51:
			DebugEnterAlt(51);
			// AS3.g:1:335: SET
			{
			DebugLocation(1, 335);
			mSET(); if (state.failed) return;

			}
			break;
		case 52:
			DebugEnterAlt(52);
			// AS3.g:1:339: WITH
			{
			DebugLocation(1, 339);
			mWITH(); if (state.failed) return;

			}
			break;
		case 53:
			DebugEnterAlt(53);
			// AS3.g:1:344: RETURN
			{
			DebugLocation(1, 344);
			mRETURN(); if (state.failed) return;

			}
			break;
		case 54:
			DebugEnterAlt(54);
			// AS3.g:1:351: CONTINUE
			{
			DebugLocation(1, 351);
			mCONTINUE(); if (state.failed) return;

			}
			break;
		case 55:
			DebugEnterAlt(55);
			// AS3.g:1:360: BREAK
			{
			DebugLocation(1, 360);
			mBREAK(); if (state.failed) return;

			}
			break;
		case 56:
			DebugEnterAlt(56);
			// AS3.g:1:366: NULL
			{
			DebugLocation(1, 366);
			mNULL(); if (state.failed) return;

			}
			break;
		case 57:
			DebugEnterAlt(57);
			// AS3.g:1:371: NEW
			{
			DebugLocation(1, 371);
			mNEW(); if (state.failed) return;

			}
			break;
		case 58:
			DebugEnterAlt(58);
			// AS3.g:1:375: SUPER
			{
			DebugLocation(1, 375);
			mSUPER(); if (state.failed) return;

			}
			break;
		case 59:
			DebugEnterAlt(59);
			// AS3.g:1:381: QUESTION
			{
			DebugLocation(1, 381);
			mQUESTION(); if (state.failed) return;

			}
			break;
		case 60:
			DebugEnterAlt(60);
			// AS3.g:1:390: LPAREN
			{
			DebugLocation(1, 390);
			mLPAREN(); if (state.failed) return;

			}
			break;
		case 61:
			DebugEnterAlt(61);
			// AS3.g:1:397: RPAREN
			{
			DebugLocation(1, 397);
			mRPAREN(); if (state.failed) return;

			}
			break;
		case 62:
			DebugEnterAlt(62);
			// AS3.g:1:404: LBRACK
			{
			DebugLocation(1, 404);
			mLBRACK(); if (state.failed) return;

			}
			break;
		case 63:
			DebugEnterAlt(63);
			// AS3.g:1:411: RBRACK
			{
			DebugLocation(1, 411);
			mRBRACK(); if (state.failed) return;

			}
			break;
		case 64:
			DebugEnterAlt(64);
			// AS3.g:1:418: LCURLY
			{
			DebugLocation(1, 418);
			mLCURLY(); if (state.failed) return;

			}
			break;
		case 65:
			DebugEnterAlt(65);
			// AS3.g:1:425: RCURLY
			{
			DebugLocation(1, 425);
			mRCURLY(); if (state.failed) return;

			}
			break;
		case 66:
			DebugEnterAlt(66);
			// AS3.g:1:432: COLON
			{
			DebugLocation(1, 432);
			mCOLON(); if (state.failed) return;

			}
			break;
		case 67:
			DebugEnterAlt(67);
			// AS3.g:1:438: DBL_COLON
			{
			DebugLocation(1, 438);
			mDBL_COLON(); if (state.failed) return;

			}
			break;
		case 68:
			DebugEnterAlt(68);
			// AS3.g:1:448: COMMA
			{
			DebugLocation(1, 448);
			mCOMMA(); if (state.failed) return;

			}
			break;
		case 69:
			DebugEnterAlt(69);
			// AS3.g:1:454: ASSIGN
			{
			DebugLocation(1, 454);
			mASSIGN(); if (state.failed) return;

			}
			break;
		case 70:
			DebugEnterAlt(70);
			// AS3.g:1:461: EQUAL
			{
			DebugLocation(1, 461);
			mEQUAL(); if (state.failed) return;

			}
			break;
		case 71:
			DebugEnterAlt(71);
			// AS3.g:1:467: STRICT_EQUAL
			{
			DebugLocation(1, 467);
			mSTRICT_EQUAL(); if (state.failed) return;

			}
			break;
		case 72:
			DebugEnterAlt(72);
			// AS3.g:1:480: LNOT
			{
			DebugLocation(1, 480);
			mLNOT(); if (state.failed) return;

			}
			break;
		case 73:
			DebugEnterAlt(73);
			// AS3.g:1:485: BNOT
			{
			DebugLocation(1, 485);
			mBNOT(); if (state.failed) return;

			}
			break;
		case 74:
			DebugEnterAlt(74);
			// AS3.g:1:490: NOT_EQUAL
			{
			DebugLocation(1, 490);
			mNOT_EQUAL(); if (state.failed) return;

			}
			break;
		case 75:
			DebugEnterAlt(75);
			// AS3.g:1:500: STRICT_NOT_EQUAL
			{
			DebugLocation(1, 500);
			mSTRICT_NOT_EQUAL(); if (state.failed) return;

			}
			break;
		case 76:
			DebugEnterAlt(76);
			// AS3.g:1:517: PLUS
			{
			DebugLocation(1, 517);
			mPLUS(); if (state.failed) return;

			}
			break;
		case 77:
			DebugEnterAlt(77);
			// AS3.g:1:522: PLUS_ASSIGN
			{
			DebugLocation(1, 522);
			mPLUS_ASSIGN(); if (state.failed) return;

			}
			break;
		case 78:
			DebugEnterAlt(78);
			// AS3.g:1:534: INC
			{
			DebugLocation(1, 534);
			mINC(); if (state.failed) return;

			}
			break;
		case 79:
			DebugEnterAlt(79);
			// AS3.g:1:538: MINUS
			{
			DebugLocation(1, 538);
			mMINUS(); if (state.failed) return;

			}
			break;
		case 80:
			DebugEnterAlt(80);
			// AS3.g:1:544: MINUS_ASSIGN
			{
			DebugLocation(1, 544);
			mMINUS_ASSIGN(); if (state.failed) return;

			}
			break;
		case 81:
			DebugEnterAlt(81);
			// AS3.g:1:557: DEC
			{
			DebugLocation(1, 557);
			mDEC(); if (state.failed) return;

			}
			break;
		case 82:
			DebugEnterAlt(82);
			// AS3.g:1:561: STAR
			{
			DebugLocation(1, 561);
			mSTAR(); if (state.failed) return;

			}
			break;
		case 83:
			DebugEnterAlt(83);
			// AS3.g:1:566: STAR_ASSIGN
			{
			DebugLocation(1, 566);
			mSTAR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 84:
			DebugEnterAlt(84);
			// AS3.g:1:578: MOD
			{
			DebugLocation(1, 578);
			mMOD(); if (state.failed) return;

			}
			break;
		case 85:
			DebugEnterAlt(85);
			// AS3.g:1:582: MOD_ASSIGN
			{
			DebugLocation(1, 582);
			mMOD_ASSIGN(); if (state.failed) return;

			}
			break;
		case 86:
			DebugEnterAlt(86);
			// AS3.g:1:593: SR
			{
			DebugLocation(1, 593);
			mSR(); if (state.failed) return;

			}
			break;
		case 87:
			DebugEnterAlt(87);
			// AS3.g:1:596: SR_ASSIGN
			{
			DebugLocation(1, 596);
			mSR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 88:
			DebugEnterAlt(88);
			// AS3.g:1:606: BSR
			{
			DebugLocation(1, 606);
			mBSR(); if (state.failed) return;

			}
			break;
		case 89:
			DebugEnterAlt(89);
			// AS3.g:1:610: BSR_ASSIGN
			{
			DebugLocation(1, 610);
			mBSR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 90:
			DebugEnterAlt(90);
			// AS3.g:1:621: GE
			{
			DebugLocation(1, 621);
			mGE(); if (state.failed) return;

			}
			break;
		case 91:
			DebugEnterAlt(91);
			// AS3.g:1:624: GT
			{
			DebugLocation(1, 624);
			mGT(); if (state.failed) return;

			}
			break;
		case 92:
			DebugEnterAlt(92);
			// AS3.g:1:627: BXOR
			{
			DebugLocation(1, 627);
			mBXOR(); if (state.failed) return;

			}
			break;
		case 93:
			DebugEnterAlt(93);
			// AS3.g:1:632: BXOR_ASSIGN
			{
			DebugLocation(1, 632);
			mBXOR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 94:
			DebugEnterAlt(94);
			// AS3.g:1:644: BOR
			{
			DebugLocation(1, 644);
			mBOR(); if (state.failed) return;

			}
			break;
		case 95:
			DebugEnterAlt(95);
			// AS3.g:1:648: BOR_ASSIGN
			{
			DebugLocation(1, 648);
			mBOR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 96:
			DebugEnterAlt(96);
			// AS3.g:1:659: LOR
			{
			DebugLocation(1, 659);
			mLOR(); if (state.failed) return;

			}
			break;
		case 97:
			DebugEnterAlt(97);
			// AS3.g:1:663: BAND
			{
			DebugLocation(1, 663);
			mBAND(); if (state.failed) return;

			}
			break;
		case 98:
			DebugEnterAlt(98);
			// AS3.g:1:668: BAND_ASSIGN
			{
			DebugLocation(1, 668);
			mBAND_ASSIGN(); if (state.failed) return;

			}
			break;
		case 99:
			DebugEnterAlt(99);
			// AS3.g:1:680: LAND
			{
			DebugLocation(1, 680);
			mLAND(); if (state.failed) return;

			}
			break;
		case 100:
			DebugEnterAlt(100);
			// AS3.g:1:685: LAND_ASSIGN
			{
			DebugLocation(1, 685);
			mLAND_ASSIGN(); if (state.failed) return;

			}
			break;
		case 101:
			DebugEnterAlt(101);
			// AS3.g:1:697: LOR_ASSIGN
			{
			DebugLocation(1, 697);
			mLOR_ASSIGN(); if (state.failed) return;

			}
			break;
		case 102:
			DebugEnterAlt(102);
			// AS3.g:1:708: E4X_ATTRI
			{
			DebugLocation(1, 708);
			mE4X_ATTRI(); if (state.failed) return;

			}
			break;
		case 103:
			DebugEnterAlt(103);
			// AS3.g:1:718: SEMI
			{
			DebugLocation(1, 718);
			mSEMI(); if (state.failed) return;

			}
			break;
		case 104:
			DebugEnterAlt(104);
			// AS3.g:1:723: BSLASH
			{
			DebugLocation(1, 723);
			mBSLASH(); if (state.failed) return;

			}
			break;
		case 105:
			DebugEnterAlt(105);
			// AS3.g:1:730: DOT
			{
			DebugLocation(1, 730);
			mDOT(); if (state.failed) return;

			}
			break;
		case 106:
			DebugEnterAlt(106);
			// AS3.g:1:734: E4X_DESC
			{
			DebugLocation(1, 734);
			mE4X_DESC(); if (state.failed) return;

			}
			break;
		case 107:
			DebugEnterAlt(107);
			// AS3.g:1:743: REST
			{
			DebugLocation(1, 743);
			mREST(); if (state.failed) return;

			}
			break;
		case 108:
			DebugEnterAlt(108);
			// AS3.g:1:748: REGEX_LITERAL
			{
			DebugLocation(1, 748);
			mREGEX_LITERAL(); if (state.failed) return;

			}
			break;
		case 109:
			DebugEnterAlt(109);
			// AS3.g:1:762: DIV_ASSIGN
			{
			DebugLocation(1, 762);
			mDIV_ASSIGN(); if (state.failed) return;

			}
			break;
		case 110:
			DebugEnterAlt(110);
			// AS3.g:1:773: DIV
			{
			DebugLocation(1, 773);
			mDIV(); if (state.failed) return;

			}
			break;
		case 111:
			DebugEnterAlt(111);
			// AS3.g:1:777: XML_LITERAL
			{
			DebugLocation(1, 777);
			mXML_LITERAL(); if (state.failed) return;

			}
			break;
		case 112:
			DebugEnterAlt(112);
			// AS3.g:1:789: SL
			{
			DebugLocation(1, 789);
			mSL(); if (state.failed) return;

			}
			break;
		case 113:
			DebugEnterAlt(113);
			// AS3.g:1:792: SL_ASSIGN
			{
			DebugLocation(1, 792);
			mSL_ASSIGN(); if (state.failed) return;

			}
			break;
		case 114:
			DebugEnterAlt(114);
			// AS3.g:1:802: LE
			{
			DebugLocation(1, 802);
			mLE(); if (state.failed) return;

			}
			break;
		case 115:
			DebugEnterAlt(115);
			// AS3.g:1:805: LT
			{
			DebugLocation(1, 805);
			mLT(); if (state.failed) return;

			}
			break;
		case 116:
			DebugEnterAlt(116);
			// AS3.g:1:808: IDENT
			{
			DebugLocation(1, 808);
			mIDENT(); if (state.failed) return;

			}
			break;
		case 117:
			DebugEnterAlt(117);
			// AS3.g:1:814: STRING_LITERAL_DOUBLE
			{
			DebugLocation(1, 814);
			mSTRING_LITERAL_DOUBLE(); if (state.failed) return;

			}
			break;
		case 118:
			DebugEnterAlt(118);
			// AS3.g:1:836: STRING_LITERAL_SINGLE
			{
			DebugLocation(1, 836);
			mSTRING_LITERAL_SINGLE(); if (state.failed) return;

			}
			break;
		case 119:
			DebugEnterAlt(119);
			// AS3.g:1:858: HEX_LITERAL
			{
			DebugLocation(1, 858);
			mHEX_LITERAL(); if (state.failed) return;

			}
			break;
		case 120:
			DebugEnterAlt(120);
			// AS3.g:1:870: DECIMAL_LITERAL
			{
			DebugLocation(1, 870);
			mDECIMAL_LITERAL(); if (state.failed) return;

			}
			break;
		case 121:
			DebugEnterAlt(121);
			// AS3.g:1:886: OCTAL_LITERAL
			{
			DebugLocation(1, 886);
			mOCTAL_LITERAL(); if (state.failed) return;

			}
			break;
		case 122:
			DebugEnterAlt(122);
			// AS3.g:1:900: FLOAT_LITERAL
			{
			DebugLocation(1, 900);
			mFLOAT_LITERAL(); if (state.failed) return;

			}
			break;
		case 123:
			DebugEnterAlt(123);
			// AS3.g:1:914: WS
			{
			DebugLocation(1, 914);
			mWS(); if (state.failed) return;

			}
			break;
		case 124:
			DebugEnterAlt(124);
			// AS3.g:1:917: NL
			{
			DebugLocation(1, 917);
			mNL(); if (state.failed) return;

			}
			break;
		case 125:
			DebugEnterAlt(125);
			// AS3.g:1:920: BOM
			{
			DebugLocation(1, 920);
			mBOM(); if (state.failed) return;

			}
			break;
		case 126:
			DebugEnterAlt(126);
			// AS3.g:1:924: INCLUDE_DIRECTIVE
			{
			DebugLocation(1, 924);
			mINCLUDE_DIRECTIVE(); if (state.failed) return;

			}
			break;
		case 127:
			DebugEnterAlt(127);
			// AS3.g:1:942: SL_COMMENT
			{
			DebugLocation(1, 942);
			mSL_COMMENT(); if (state.failed) return;

			}
			break;
		case 128:
			DebugEnterAlt(128);
			// AS3.g:1:953: ML_COMMENT
			{
			DebugLocation(1, 953);
			mML_COMMENT(); if (state.failed) return;

			}
			break;

		}

	}

	partial void EnterRule_synpred2_AS3_fragment();
	partial void LeaveRule_synpred2_AS3_fragment();

	// $ANTLR start synpred2_AS3
	private void synpred2_AS3_fragment()
	{
		EnterRule_synpred2_AS3_fragment();
		EnterRule("synpred2_AS3_fragment", 148);
		TraceIn("synpred2_AS3_fragment", 148);
		try
		{
			// AS3.g:1188:5: ( '/' ~ '>' )
			DebugEnterAlt(1);
			// AS3.g:1188:6: '/' ~ '>'
			{
			DebugLocation(1188, 6);
			Match('/'); if (state.failed) return;
			DebugLocation(1188, 10);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred2_AS3_fragment", 148);
			LeaveRule("synpred2_AS3_fragment", 148);
			LeaveRule_synpred2_AS3_fragment();
		}
	}
	// $ANTLR end synpred2_AS3

	partial void EnterRule_synpred3_AS3_fragment();
	partial void LeaveRule_synpred3_AS3_fragment();

	// $ANTLR start synpred3_AS3
	private void synpred3_AS3_fragment()
	{
		EnterRule_synpred3_AS3_fragment();
		EnterRule("synpred3_AS3_fragment", 149);
		TraceIn("synpred3_AS3_fragment", 149);
		try
		{
			// AS3.g:1198:5: ( '-' ~ '-' )
			DebugEnterAlt(1);
			// AS3.g:1198:6: '-' ~ '-'
			{
			DebugLocation(1198, 6);
			Match('-'); if (state.failed) return;
			DebugLocation(1198, 10);
			if ((input.LA(1)>='\u0000' && input.LA(1)<=',')||(input.LA(1)>='.' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred3_AS3_fragment", 149);
			LeaveRule("synpred3_AS3_fragment", 149);
			LeaveRule_synpred3_AS3_fragment();
		}
	}
	// $ANTLR end synpred3_AS3

	partial void EnterRule_synpred4_AS3_fragment();
	partial void LeaveRule_synpred4_AS3_fragment();

	// $ANTLR start synpred4_AS3
	private void synpred4_AS3_fragment()
	{
		EnterRule_synpred4_AS3_fragment();
		EnterRule("synpred4_AS3_fragment", 150);
		TraceIn("synpred4_AS3_fragment", 150);
		try
		{
			// AS3.g:1206:12: ( ']' ~ ']' )
			DebugEnterAlt(1);
			// AS3.g:1206:13: ']' ~ ']'
			{
			DebugLocation(1206, 13);
			Match(']'); if (state.failed) return;
			DebugLocation(1206, 17);
			if ((input.LA(1)>='\u0000' && input.LA(1)<='\\')||(input.LA(1)>='^' && input.LA(1)<='\uFFFF'))
			{
				input.Consume();
			state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

		}
		finally
		{
			TraceOut("synpred4_AS3_fragment", 150);
			LeaveRule("synpred4_AS3_fragment", 150);
			LeaveRule_synpred4_AS3_fragment();
		}
	}
	// $ANTLR end synpred4_AS3

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	DFA42 dfa42;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa42 = new DFA42(this, SpecialStateTransition42);
	}

	private class DFA42 : DFA
	{
		private const string DFA42_eotS =
			"\x1\xFFFF\x12\x2D\x7\xFFFF\x1\x64\x1\xFFFF\x1\x66\x1\x68\x1\xFFFF\x1"+
			"\x6B\x1\x6E\x1\x70\x1\x72\x1\x75\x1\x77\x1\x7A\x1\x7D\x3\xFFFF\x1\x7F"+
			"\x1\x85\x1\x89\x3\xFFFF\x2\x8B\x4\xFFFF\x1\x2D\x1\x8F\x4\x2D\x1\x96\x9"+
			"\x2D\x1\xA4\x1\x2D\x1\xA6\x1\xA7\x1\xA8\x18\x2D\x2\xFFFF\x1\xC4\x1\xFFFF"+
			"\x1\xC6\xB\xFFFF\x1\xC9\x5\xFFFF\x1\xCB\x2\xFFFF\x1\xCD\x1\xFFFF\x1\xCF"+
			"\x2\xFFFF\x1\xD0\x4\xFFFF\x1\xD2\x5\xFFFF\x1\xD3\x1\x8B\x1\xD4\x1\xFFFF"+
			"\x6\x2D\x1\xFFFF\x8\x2D\x1\xE4\x4\x2D\x1\xFFFF\x1\x2D\x3\xFFFF\x2\x2D"+
			"\x1\xEE\x3\x2D\x1\xF2\x1\x2D\x1\xF4\x6\x2D\x1\xFB\x3\x2D\x1\xFF\x2\x2D"+
			"\x1\x102\x1\x103\x2\x2D\x5\xFFFF\x1\x107\xC\xFFFF\x1\x2D\x1\x109\x9\x2D"+
			"\x1\x113\x1\x114\x2\x2D\x1\xFFFF\x9\x2D\x1\xFFFF\x1\x120\x2\x2D\x1\xFFFF"+
			"\x1\x123\x1\xFFFF\x6\x2D\x1\xFFFF\x2\x2D\x1\x12C\x1\xFFFF\x1\x2D\x1\x12E"+
			"\x2\xFFFF\x2\x2D\x2\xFFFF\x1\x131\x1\xFFFF\x1\x132\x1\x2D\x1\x134\x6"+
			"\x2D\x2\xFFFF\x1\x13C\x1\x2D\x1\x13E\x7\x2D\x1\x147\x1\xFFFF\x2\x2D\x1"+
			"\xFFFF\x6\x2D\x1\x150\x1\x151\x1\xFFFF\x1\x2D\x1\xFFFF\x1\x2D\x1\x154"+
			"\x2\xFFFF\x1\x2D\x1\xFFFF\x1\x156\x6\x2D\x1\xFFFF\x1\x2D\x1\xFFFF\x6"+
			"\x2D\x1\x164\x1\x2D\x1\xFFFF\x1\x166\x2\x2D\x1\x169\x2\x2D\x1\x16C\x1"+
			"\x16D\x2\xFFFF\x1\x2D\x1\x16F\x1\xFFFF\x1\x2D\x1\xFFFF\x1\x171\x1\x172"+
			"\x2\x2D\x1\x175\x1\x176\x1\x2D\x1\x178\x5\x2D\x1\xFFFF\x1\x2D\x1\xFFFF"+
			"\x1\x2D\x1\x180\x1\xFFFF\x1\x181\x1\x2D\x2\xFFFF\x1\x2D\x1\xFFFF\x1\x184"+
			"\x2\xFFFF\x1\x2D\x1\x186\x2\xFFFF\x1\x187\x1\xFFFF\x2\x2D\x1\x18A\x2"+
			"\x2D\x1\x18D\x1\x2D\x2\xFFFF\x2\x2D\x1\xFFFF\x1\x2D\x2\xFFFF\x1\x2D\x1"+
			"\x193\x1\xFFFF\x1\x194\x1\x2D\x1\xFFFF\x1\x196\x1\x197\x1\x198\x1\x199"+
			"\x1\x19A\x2\xFFFF\x1\x19B\x6\xFFFF";
		private const string DFA42_eofS =
			"\x19C\xFFFF";
		private const string DFA42_minS =
			"\x1\x9\x1\x6E\x1\x61\x1\x65\x2\x61\x1\x66\x1\x72\x1\x68\x1\x6E\x2\x61"+
			"\x1\x65\x1\x68\x1\x6D\x1\x61\x2\x65\x1\x72\x7\xFFFF\x1\x3A\x1\xFFFF\x2"+
			"\x3D\x1\xFFFF\x1\x2B\x1\x2D\x5\x3D\x1\x26\x3\xFFFF\x1\x2E\x1\x0\x1\x24"+
			"\x3\xFFFF\x2\x2E\x4\xFFFF\x1\x64\x1\x24\x1\x73\x1\x6E\x1\x61\x1\x66\x1"+
			"\x24\x1\x6E\x1\x75\x1\x70\x1\x63\x1\x73\x2\x6E\x1\x72\x1\x6C\x1\x24\x1"+
			"\x70\x3\x24\x1\x65\x1\x72\x1\x75\x1\x70\x1\x64\x1\x65\x1\x69\x1\x72\x1"+
			"\x63\x1\x62\x1\x69\x1\x61\x1\x69\x1\x74\x1\x70\x1\x69\x1\x74\x1\x6C\x1"+
			"\x6D\x1\x6C\x1\x77\x2\x74\x1\x65\x2\xFFFF\x1\x3D\x1\xFFFF\x1\x3D\xB\xFFFF"+
			"\x1\x3D\x5\xFFFF\x1\x3D\x2\xFFFF\x1\x3D\x1\xFFFF\x1\x2E\x2\xFFFF\x1\x0"+
			"\x4\xFFFF\x1\x3D\x5\xFFFF\x2\x2E\x1\x24\x1\xFFFF\x1\x63\x1\x65\x2\x73"+
			"\x1\x65\x1\x61\x1\xFFFF\x1\x61\x1\x6D\x1\x6C\x1\x65\x1\x68\x1\x65\x1"+
			"\x61\x1\x63\x1\x24\x1\x73\x1\x6C\x1\x74\x1\x65\x1\xFFFF\x1\x6C\x3\xFFFF"+
			"\x1\x72\x1\x6F\x1\x24\x3\x65\x1\x24\x1\x64\x1\x24\x1\x6B\x1\x6C\x1\x76"+
			"\x3\x74\x1\x24\x1\x65\x1\x6C\x1\x68\x1\x24\x1\x65\x1\x6C\x2\x24\x1\x75"+
			"\x1\x61\x5\xFFFF\x1\x3D\xC\xFFFF\x1\x68\x1\x24\x1\x74\x1\x69\x1\x73\x1"+
			"\x74\x1\x75\x1\x6D\x1\x65\x1\x69\x1\x6E\x2\x24\x1\x6C\x1\x74\x1\xFFFF"+
			"\x1\x65\x1\x75\x1\x61\x1\x69\x1\x72\x1\x65\x2\x72\x1\x77\x1\xFFFF\x1"+
			"\x24\x1\x6F\x1\x66\x1\xFFFF\x1\x24\x1\xFFFF\x1\x61\x1\x69\x1\x61\x1\x65"+
			"\x1\x69\x1\x63\x1\xFFFF\x1\x72\x1\x65\x1\x24\x1\xFFFF\x1\x73\x1\x24\x2"+
			"\xFFFF\x1\x72\x1\x6B\x2\xFFFF\x1\x24\x1\xFFFF\x1\x24\x1\x6E\x1\x24\x1"+
			"\x65\x1\x6C\x1\x69\x1\x72\x1\x63\x1\x64\x2\xFFFF\x1\x24\x1\x69\x1\x24"+
			"\x1\x64\x2\x6E\x1\x66\x1\x6D\x1\x74\x1\x69\x1\x24\x1\xFFFF\x1\x66\x1"+
			"\x69\x1\xFFFF\x1\x67\x1\x63\x1\x74\x2\x63\x1\x68\x2\x24\x1\xFFFF\x1\x70"+
			"\x1\xFFFF\x1\x6E\x1\x24\x2\xFFFF\x1\x75\x1\xFFFF\x1\x24\x1\x74\x1\x63"+
			"\x1\x61\x1\x69\x1\x73\x1\x79\x1\xFFFF\x1\x6F\x1\xFFFF\x1\x65\x1\x63\x1"+
			"\x73\x2\x61\x1\x65\x1\x24\x1\x64\x1\xFFFF\x1\x24\x1\x6E\x1\x65\x1\x24"+
			"\x1\x65\x1\x74\x2\x24\x2\xFFFF\x1\x61\x1\x24\x1\xFFFF\x1\x65\x1\xFFFF"+
			"\x2\x24\x1\x62\x1\x74\x2\x24\x1\x6E\x1\x24\x1\x65\x1\x69\x1\x6C\x1\x63"+
			"\x1\x6E\x1\xFFFF\x1\x65\x1\xFFFF\x1\x65\x1\x24\x1\xFFFF\x1\x24\x1\x65"+
			"\x2\xFFFF\x1\x63\x1\xFFFF\x1\x24\x2\xFFFF\x1\x6C\x1\x24\x2\xFFFF\x1\x24"+
			"\x1\xFFFF\x1\x6F\x1\x63\x1\x24\x1\x65\x1\x74\x1\x24\x1\x64\x2\xFFFF\x1"+
			"\x64\x1\x65\x1\xFFFF\x1\x65\x2\xFFFF\x1\x66\x1\x24\x1\xFFFF\x1\x24\x1"+
			"\x73\x1\xFFFF\x5\x24\x2\xFFFF\x1\x24\x6\xFFFF";
		private const string DFA42_maxS =
			"\x1\xFEFF\x1\x73\x1\x6F\x1\x79\x1\x78\x1\x75\x1\x73\x1\x76\x1\x79\x1"+
			"\x73\x1\x6F\x1\x75\x1\x77\x1\x69\x1\x6D\x1\x75\x2\x65\x1\x72\x7\xFFFF"+
			"\x1\x3A\x1\xFFFF\x2\x3D\x1\xFFFF\x4\x3D\x1\x3E\x1\x3D\x1\x7C\x1\x3D\x3"+
			"\xFFFF\x1\x39\x1\xFFFF\x1\x7A\x3\xFFFF\x1\x78\x1\x39\x4\xFFFF\x1\x64"+
			"\x1\x7A\x1\x74\x1\x6E\x1\x61\x1\x6C\x1\x7A\x1\x6E\x1\x75\x1\x74\x1\x63"+
			"\x1\x73\x2\x6E\x1\x72\x1\x6C\x1\x7A\x1\x70\x3\x7A\x1\x65\x1\x72\x1\x79"+
			"\x1\x70\x1\x64\x1\x65\x1\x69\x1\x72\x1\x63\x1\x62\x1\x6F\x1\x61\x1\x69"+
			"\x1\x74\x1\x70\x1\x69\x1\x74\x1\x6C\x1\x6D\x1\x6C\x1\x77\x2\x74\x1\x65"+
			"\x2\xFFFF\x1\x3D\x1\xFFFF\x1\x3D\xB\xFFFF\x1\x3E\x5\xFFFF\x1\x3D\x2\xFFFF"+
			"\x1\x3D\x1\xFFFF\x1\x2E\x2\xFFFF\x1\xFFFF\x4\xFFFF\x1\x3D\x5\xFFFF\x2"+
			"\x39\x1\x7A\x1\xFFFF\x1\x63\x1\x65\x1\x74\x1\x73\x1\x65\x1\x61\x1\xFFFF"+
			"\x1\x61\x1\x6D\x1\x6C\x1\x65\x1\x68\x1\x65\x1\x61\x1\x63\x1\x7A\x1\x73"+
			"\x1\x6C\x1\x74\x1\x72\x1\xFFFF\x1\x6F\x3\xFFFF\x1\x72\x1\x6F\x1\x7A\x3"+
			"\x65\x1\x7A\x1\x64\x1\x7A\x1\x6B\x1\x6C\x1\x76\x3\x74\x1\x7A\x1\x65\x1"+
			"\x6C\x1\x68\x1\x7A\x1\x65\x1\x6C\x2\x7A\x1\x75\x1\x61\x5\xFFFF\x1\x3D"+
			"\xC\xFFFF\x1\x68\x1\x7A\x1\x74\x1\x69\x1\x73\x1\x74\x1\x75\x1\x6D\x1"+
			"\x65\x1\x69\x1\x6E\x2\x7A\x1\x6C\x1\x74\x1\xFFFF\x1\x65\x1\x75\x1\x61"+
			"\x1\x69\x1\x72\x1\x65\x2\x72\x1\x77\x1\xFFFF\x1\x7A\x1\x6F\x1\x66\x1"+
			"\xFFFF\x1\x7A\x1\xFFFF\x1\x61\x1\x69\x1\x61\x1\x65\x1\x69\x1\x63\x1\xFFFF"+
			"\x1\x72\x1\x65\x1\x7A\x1\xFFFF\x1\x73\x1\x7A\x2\xFFFF\x1\x72\x1\x6B\x2"+
			"\xFFFF\x1\x7A\x1\xFFFF\x1\x7A\x1\x6E\x1\x7A\x1\x65\x1\x6C\x1\x69\x1\x72"+
			"\x1\x63\x1\x64\x2\xFFFF\x1\x7A\x1\x69\x1\x7A\x1\x64\x3\x6E\x1\x6D\x1"+
			"\x74\x1\x69\x1\x7A\x1\xFFFF\x1\x66\x1\x69\x1\xFFFF\x1\x67\x1\x63\x1\x74"+
			"\x2\x63\x1\x68\x2\x7A\x1\xFFFF\x1\x70\x1\xFFFF\x1\x6E\x1\x7A\x2\xFFFF"+
			"\x1\x75\x1\xFFFF\x1\x7A\x1\x74\x1\x63\x1\x61\x1\x69\x1\x73\x1\x79\x1"+
			"\xFFFF\x1\x6F\x1\xFFFF\x1\x65\x1\x63\x1\x73\x2\x61\x1\x65\x1\x7A\x1\x64"+
			"\x1\xFFFF\x1\x7A\x1\x6E\x1\x65\x1\x7A\x1\x65\x1\x74\x2\x7A\x2\xFFFF\x1"+
			"\x61\x1\x7A\x1\xFFFF\x1\x65\x1\xFFFF\x2\x7A\x1\x62\x1\x74\x2\x7A\x1\x6E"+
			"\x1\x7A\x1\x65\x1\x69\x1\x6C\x1\x63\x1\x6E\x1\xFFFF\x1\x65\x1\xFFFF\x1"+
			"\x65\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x2\xFFFF\x1\x63\x1\xFFFF\x1\x7A\x2"+
			"\xFFFF\x1\x6C\x1\x7A\x2\xFFFF\x1\x7A\x1\xFFFF\x1\x6F\x1\x63\x1\x7A\x1"+
			"\x65\x1\x74\x1\x7A\x1\x64\x2\xFFFF\x1\x64\x1\x65\x1\xFFFF\x1\x65\x2\xFFFF"+
			"\x1\x66\x1\x7A\x1\xFFFF\x1\x7A\x1\x73\x1\xFFFF\x5\x7A\x2\xFFFF\x1\x7A"+
			"\x6\xFFFF";
		private const string DFA42_acceptS =
			"\x13\xFFFF\x1\x3B\x1\x3C\x1\x3D\x1\x3E\x1\x3F\x1\x40\x1\x41\x1\xFFFF"+
			"\x1\x44\x2\xFFFF\x1\x49\x8\xFFFF\x1\x66\x1\x67\x1\x68\x3\xFFFF\x1\x74"+
			"\x1\x75\x1\x76\x2\xFFFF\x1\x7B\x1\x7C\x1\x7D\x1\x7E\x2D\xFFFF\x1\x43"+
			"\x1\x42\x1\xFFFF\x1\x45\x1\xFFFF\x1\x48\x1\x4D\x1\x4E\x1\x4C\x1\x50\x1"+
			"\x51\x1\x4F\x1\x53\x1\x52\x1\x55\x1\x54\x1\xFFFF\x1\x5A\x1\x5B\x1\x5D"+
			"\x1\x5C\x1\x5F\x1\xFFFF\x1\x5E\x1\x62\x1\xFFFF\x1\x61\x1\xFFFF\x1\x69"+
			"\x1\x7A\x1\xFFFF\x1\x7F\x1\x80\x1\x6C\x1\x6E\x1\xFFFF\x1\x72\x1\x6F\x1"+
			"\x73\x1\x77\x1\x78\x3\xFFFF\x1\x31\x6\xFFFF\x1\x22\xD\xFFFF\x1\x20\x1"+
			"\xFFFF\x1\x1C\x1\x30\x1\xB\x1A\xFFFF\x1\x47\x1\x46\x1\x4B\x1\x4A\x1\x57"+
			"\x1\xFFFF\x1\x56\x1\x65\x1\x60\x1\x64\x1\x63\x1\x6B\x1\x6A\x1\x6D\x1"+
			"\x71\x1\x70\x1\x79\x1\x1\xF\xFFFF\x1\x1E\x9\xFFFF\x1\xE\x3\xFFFF\x1\x2D"+
			"\x1\xFFFF\x1\x1A\x6\xFFFF\x1\x33\x3\xFFFF\x1\x2E\x2\xFFFF\x1\x39\x1\x32"+
			"\x2\xFFFF\x1\x59\x1\x58\x1\xFFFF\x1\x24\x9\xFFFF\x1\x1F\x1\x26\xB\xFFFF"+
			"\x1\x2A\x2\xFFFF\x1\x11\x8\xFFFF\x1\x34\x1\xFFFF\x1\x38\x2\xFFFF\x1\x2"+
			"\x1\x27\x1\xFFFF\x1\x28\x7\xFFFF\x1\x6\x1\xFFFF\x1\x2B\x8\xFFFF\x1\xD"+
			"\x8\xFFFF\x1\x3A\x1\x21\x2\xFFFF\x1\x37\x1\xFFFF\x1\x3\xD\xFFFF\x1\x1D"+
			"\x1\xFFFF\x1\xF\x2\xFFFF\x1\x13\x2\xFFFF\x1\x1B\x1\x23\x1\xFFFF\x1\x35"+
			"\x1\xFFFF\x1\x25\x1\x2C\x2\xFFFF\x1\x18\x1\x7\x1\xFFFF\x1\x8\x7\xFFFF"+
			"\x1\x12\x1\x14\x2\xFFFF\x1\x36\x1\xFFFF\x1\x5\x1\x17\x2\xFFFF\x1\x16"+
			"\x2\xFFFF\x1\xC\x5\xFFFF\x1\xA\x1\x29\x1\xFFFF\x1\x10\x1\x15\x1\x2F\x1"+
			"\x4\x1\x9\x1\x19";
		private const string DFA42_specialS =
			"\x2B\xFFFF\x1\x0\x55\xFFFF\x1\x1\x11A\xFFFF}>";
		private static readonly string[] DFA42_transitionS =
			{
				"\x1\x32\x1\x33\x1\xFFFF\x1\x32\x1\x33\x12\xFFFF\x1\x32\x1\x1D\x1\x2E"+
				"\x1\x35\x1\x2D\x1\x22\x1\x26\x1\x2F\x1\x14\x1\x15\x1\x21\x1\x1F\x1\x1B"+
				"\x1\x20\x1\x2A\x1\x2B\x1\x30\x9\x31\x1\x1A\x1\x28\x1\x2C\x1\x1C\x1\x23"+
				"\x1\x13\x1\x27\x1A\x2D\x1\x16\x1\x29\x1\x17\x1\x24\x1\x2D\x1\xFFFF\x1"+
				"\x1\x1\x12\x1\x2\x1\x3\x1\x4\x1\x5\x1\x10\x1\x2D\x1\x6\x4\x2D\x1\xF"+
				"\x1\x7\x1\xB\x1\x2D\x1\x11\x1\xC\x1\x8\x1\x9\x1\xA\x1\xD\x1\xE\x2\x2D"+
				"\x1\x18\x1\x25\x1\x19\x1\x1E\x70\xFFFF\x1\x34\xFE0F\xFFFF\x1\x34",
				"\x1\x36\x4\xFFFF\x1\x37",
				"\x1\x38\xA\xFFFF\x1\x3A\x2\xFFFF\x1\x39",
				"\x1\x3B\x9\xFFFF\x1\x3C\x9\xFFFF\x1\x3D",
				"\x1\x40\xA\xFFFF\x1\x41\x1\xFFFF\x1\x3E\x9\xFFFF\x1\x3F",
				"\x1\x45\x7\xFFFF\x1\x42\x5\xFFFF\x1\x44\x5\xFFFF\x1\x43",
				"\x1\x48\x6\xFFFF\x1\x47\x1\x46\x4\xFFFF\x1\x49",
				"\x1\x4A\x3\xFFFF\x1\x4B",
				"\x1\x4C\x9\xFFFF\x1\x4D\x6\xFFFF\x1\x4E",
				"\x1\x4F\x4\xFFFF\x1\x50",
				"\x1\x52\xD\xFFFF\x1\x51",
				"\x1\x53\x10\xFFFF\x1\x55\x2\xFFFF\x1\x54",
				"\x1\x58\xE\xFFFF\x1\x56\x1\x59\x1\xFFFF\x1\x57",
				"\x1\x5A\x1\x5B",
				"\x1\x5C",
				"\x1\x5D\x3\xFFFF\x1\x5F\xF\xFFFF\x1\x5E",
				"\x1\x60",
				"\x1\x61",
				"\x1\x62",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x63",
				"",
				"\x1\x65",
				"\x1\x67",
				"",
				"\x1\x6A\x11\xFFFF\x1\x69",
				"\x1\x6D\xF\xFFFF\x1\x6C",
				"\x1\x6F",
				"\x1\x71",
				"\x1\x74\x1\x73",
				"\x1\x76",
				"\x1\x78\x3E\xFFFF\x1\x79",
				"\x1\x7C\x16\xFFFF\x1\x7B",
				"",
				"",
				"",
				"\x1\x7E\x1\xFFFF\xA\x80",
				"\xA\x84\x1\xFFFF\x2\x84\x1\xFFFF\x1C\x84\x1\x83\x4\x84\x1\x82\xD\x84"+
				"\x1\x81\xFFC2\x84",
				"\x1\x88\x17\xFFFF\x1\x86\x1\x87\x3\xFFFF\x1A\x88\x4\xFFFF\x1\x88\x1"+
				"\xFFFF\x1A\x88",
				"",
				"",
				"",
				"\x1\x80\x1\xFFFF\x8\x8C\x2\x80\x1E\xFFFF\x1\x8A\x1F\xFFFF\x1\x8A",
				"\x1\x80\x1\xFFFF\xA\x8D",
				"",
				"",
				"",
				"",
				"\x1\x8E",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x91\x1\x90",
				"\x1\x92",
				"\x1\x93",
				"\x1\x95\x5\xFFFF\x1\x94",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x97",
				"\x1\x98",
				"\x1\x99\x3\xFFFF\x1\x9A",
				"\x1\x9B",
				"\x1\x9C",
				"\x1\x9D",
				"\x1\x9E",
				"\x1\x9F",
				"\x1\xA0",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x2"+
				"\x2D\x1\xA1\xF\x2D\x1\xA2\x1\xA3\x6\x2D",
				"\x1\xA5",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xA9",
				"\x1\xAA",
				"\x1\xAC\x3\xFFFF\x1\xAB",
				"\x1\xAD",
				"\x1\xAE",
				"\x1\xAF",
				"\x1\xB0",
				"\x1\xB1",
				"\x1\xB2",
				"\x1\xB3",
				"\x1\xB4\x5\xFFFF\x1\xB5",
				"\x1\xB6",
				"\x1\xB7",
				"\x1\xB8",
				"\x1\xB9",
				"\x1\xBA",
				"\x1\xBB",
				"\x1\xBC",
				"\x1\xBD",
				"\x1\xBE",
				"\x1\xBF",
				"\x1\xC0",
				"\x1\xC1",
				"\x1\xC2",
				"",
				"",
				"\x1\xC3",
				"",
				"\x1\xC5",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xC7\x1\xC8",
				"",
				"",
				"",
				"",
				"",
				"\x1\xCA",
				"",
				"",
				"\x1\xCC",
				"",
				"\x1\xCE",
				"",
				"",
				"\xA\x84\x1\xFFFF\x2\x84\x1\xFFFF\xFFF2\x84",
				"",
				"",
				"",
				"",
				"\x1\xD1",
				"",
				"",
				"",
				"",
				"",
				"\x1\x80\x1\xFFFF\x8\x8C\x2\x80",
				"\x1\x80\x1\xFFFF\xA\x8D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\xD5",
				"\x1\xD6",
				"\x1\xD7\x1\xD8",
				"\x1\xD9",
				"\x1\xDA",
				"\x1\xDB",
				"",
				"\x1\xDC",
				"\x1\xDD",
				"\x1\xDE",
				"\x1\xDF",
				"\x1\xE0",
				"\x1\xE1",
				"\x1\xE2",
				"\x1\xE3",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xE5",
				"\x1\xE6",
				"\x1\xE7",
				"\x1\xE9\xC\xFFFF\x1\xE8",
				"",
				"\x1\xEA\x2\xFFFF\x1\xEB",
				"",
				"",
				"",
				"\x1\xEC",
				"\x1\xED",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xEF",
				"\x1\xF0",
				"\x1\xF1",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xF3",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xF5",
				"\x1\xF6",
				"\x1\xF7",
				"\x1\xF8",
				"\x1\xF9",
				"\x1\xFA",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\xFC",
				"\x1\xFD",
				"\x1\xFE",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x100",
				"\x1\x101",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x104",
				"\x1\x105",
				"",
				"",
				"",
				"",
				"",
				"\x1\x106",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x108",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x10A",
				"\x1\x10B",
				"\x1\x10C",
				"\x1\x10D",
				"\x1\x10E",
				"\x1\x10F",
				"\x1\x110",
				"\x1\x111",
				"\x1\x112",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x115",
				"\x1\x116",
				"",
				"\x1\x117",
				"\x1\x118",
				"\x1\x119",
				"\x1\x11A",
				"\x1\x11B",
				"\x1\x11C",
				"\x1\x11D",
				"\x1\x11E",
				"\x1\x11F",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x121",
				"\x1\x122",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x124",
				"\x1\x125",
				"\x1\x126",
				"\x1\x127",
				"\x1\x128",
				"\x1\x129",
				"",
				"\x1\x12A",
				"\x1\x12B",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x12D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x12F",
				"\x1\x130",
				"",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x133",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x135",
				"\x1\x136",
				"\x1\x137",
				"\x1\x138",
				"\x1\x139",
				"\x1\x13A",
				"",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\xB"+
				"\x2D\x1\x13B\xE\x2D",
				"\x1\x13D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x13F",
				"\x1\x140",
				"\x1\x141",
				"\x1\x143\x7\xFFFF\x1\x142",
				"\x1\x144",
				"\x1\x145",
				"\x1\x146",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x148",
				"\x1\x149",
				"",
				"\x1\x14A",
				"\x1\x14B",
				"\x1\x14C",
				"\x1\x14D",
				"\x1\x14E",
				"\x1\x14F",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x152",
				"",
				"\x1\x153",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x155",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x157",
				"\x1\x158",
				"\x1\x159",
				"\x1\x15A",
				"\x1\x15B",
				"\x1\x15C",
				"",
				"\x1\x15D",
				"",
				"\x1\x15E",
				"\x1\x15F",
				"\x1\x160",
				"\x1\x161",
				"\x1\x162",
				"\x1\x163",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x165",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x167",
				"\x1\x168",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x16A",
				"\x1\x16B",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x16E",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x170",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x173",
				"\x1\x174",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x177",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x179",
				"\x1\x17A",
				"\x1\x17B",
				"\x1\x17C",
				"\x1\x17D",
				"",
				"\x1\x17E",
				"",
				"\x1\x17F",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x182",
				"",
				"",
				"\x1\x183",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x185",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x188",
				"\x1\x189",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x18B",
				"\x1\x18C",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x18E",
				"",
				"",
				"\x1\x18F",
				"\x1\x190",
				"",
				"\x1\x191",
				"",
				"",
				"\x1\x192",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x195",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"\x1\x2D\xB\xFFFF\xA\x2D\x7\xFFFF\x1A\x2D\x4\xFFFF\x1\x2D\x1\xFFFF\x1A"+
				"\x2D",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA42_eot = DFA.UnpackEncodedString(DFA42_eotS);
		private static readonly short[] DFA42_eof = DFA.UnpackEncodedString(DFA42_eofS);
		private static readonly char[] DFA42_min = DFA.UnpackEncodedStringToUnsignedChars(DFA42_minS);
		private static readonly char[] DFA42_max = DFA.UnpackEncodedStringToUnsignedChars(DFA42_maxS);
		private static readonly short[] DFA42_accept = DFA.UnpackEncodedString(DFA42_acceptS);
		private static readonly short[] DFA42_special = DFA.UnpackEncodedString(DFA42_specialS);
		private static readonly short[][] DFA42_transition;

		static DFA42()
		{
			int numStates = DFA42_transitionS.Length;
			DFA42_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA42_transition[i] = DFA.UnpackEncodedString(DFA42_transitionS[i]);
			}
		}

		public DFA42( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 42;
			this.eot = DFA42_eot;
			this.eof = DFA42_eof;
			this.min = DFA42_min;
			this.max = DFA42_max;
			this.accept = DFA42_accept;
			this.special = DFA42_special;
			this.transition = DFA42_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( T__241 | T__242 | T__243 | T__244 | T__245 | T__246 | T__247 | T__248 | T__249 | T__250 | T__251 | T__252 | T__253 | T__254 | T__255 | T__256 | T__257 | PACKAGE | PUBLIC | PRIVATE | PROTECTED | INTERNAL | FUNCTION | EXTENDS | IMPLEMENTS | VAR | STATIC | IF | IMPORT | FOR | EACH | IN | WHILE | DO | SWITCH | CASE | DEFAULT | ELSE | CONST | CLASS | INTERFACE | TRUE | FALSE | DYNAMIC | USE | XML | NAMESPACE | IS | AS | GET | SET | WITH | RETURN | CONTINUE | BREAK | NULL | NEW | SUPER | QUESTION | LPAREN | RPAREN | LBRACK | RBRACK | LCURLY | RCURLY | COLON | DBL_COLON | COMMA | ASSIGN | EQUAL | STRICT_EQUAL | LNOT | BNOT | NOT_EQUAL | STRICT_NOT_EQUAL | PLUS | PLUS_ASSIGN | INC | MINUS | MINUS_ASSIGN | DEC | STAR | STAR_ASSIGN | MOD | MOD_ASSIGN | SR | SR_ASSIGN | BSR | BSR_ASSIGN | GE | GT | BXOR | BXOR_ASSIGN | BOR | BOR_ASSIGN | LOR | BAND | BAND_ASSIGN | LAND | LAND_ASSIGN | LOR_ASSIGN | E4X_ATTRI | SEMI | BSLASH | DOT | E4X_DESC | REST | REGEX_LITERAL | DIV_ASSIGN | DIV | XML_LITERAL | SL | SL_ASSIGN | LE | LT | IDENT | STRING_LITERAL_DOUBLE | STRING_LITERAL_SINGLE | HEX_LITERAL | DECIMAL_LITERAL | OCTAL_LITERAL | FLOAT_LITERAL | WS | NL | BOM | INCLUDE_DIRECTIVE | SL_COMMENT | ML_COMMENT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition42(DFA dfa, int s, IIntStream _input)
	{
		IIntStream input = _input;
		int _s = s;
		s = -1;
		int LA42_1 = input.LA(1);
		int index42_1 = input.Index;
		switch (_s)
		{
		case 0:
			{
				input.Rewind();
				if ((LA42_1=='=')) {s = 129;}

				else if ((LA42_1=='/')) {s = 130;}

				else if ((LA42_1=='*')) {s = 131;}

				else if (((LA42_1>='\u0000' && LA42_1<='\t')||(LA42_1>='\u000B' && LA42_1<='\f')||(LA42_1>='\u000E' && LA42_1<=')')||(LA42_1>='+' && LA42_1<='.')||(LA42_1>='0' && LA42_1<='<')||(LA42_1>='>' && LA42_1<='\uFFFF')) && (( constantIsOk() ))) {s = 132;}

				else s = 133;

				input.Seek(index42_1);
				break;
			}
		case 1:
			{
				input.Rewind();
				if (((LA42_1>='\u0000' && LA42_1<='\t')||(LA42_1>='\u000B' && LA42_1<='\f')||(LA42_1>='\u000E' && LA42_1<='\uFFFF')) && (( constantIsOk() ))) {s = 132;}

				else s = 208;

				input.Seek(index42_1);
				break;
			}

		default:
			break;
		}

		if (s >= 0)
			return s;

		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 42, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion

}
