/* Autogenerated by xas on 1/15/2012 3:22:06 PM */
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "SE13NetworkTable.h"
/*
Copyright 2011 Research In Motion Limited.  All Rights Reserved.
*/

// package qnx/radio/ons
{
	#include "flash/data/SQLConnection.h"
	#include "flash/data/SQLMode.h"
	#include "flash/data/SQLResult.h"
	#include "flash/data/SQLSchemaResult.h"
	#include "flash/data/SQLStatement.h"
	#include "flash/data/SQLTableSchema.h"
	#include "flash/errors/SQLError.h"
	#include "flash/events/SQLEvent.h"
	#include "flash/filesystem/File.h"
	#include "flash/utils/ByteArray.h"
	#include "mx/utils/StringUtil.h"
	
	#include "qnx/radio/ons/data/SE13NetworkList.h"
	#include "qnx/radio/ons/data/SE13NetworkOverrideList.h"
	
	/*
	Implemenation of the SE13 Table
	
	The SE13 Table is a table that consists of the following info:
	1. Preferred Presentation of Country Initials and Mobile Network Name (PPCI&N)
	2. Abbreviated Network Name 
	3. Mobile Country Code (MCC)
	4. Mobile Network Code (MNC)
	
	Data in the table is provided by 
	1. SE.13 network list, which is retrieved from https://infocentre.gsm.org
	2. BBSE-SE13Networks-network-override-list.txt, which is retrieved from Perforce?
	
	Assumption: The SE.13 network list and the network override list consists of
	Line 1: column header names delimited by "|"
	Subsequent lines: corresponding column values delimited by "|"
	End of line: "\r\n"
	*/
	//  class SE13NetworkTable 
	{
		//    char* SE13_DB_FILENAME="SE13NetworkTable.db";
		//    char* SE13_TABLE_NAME="SE13Network";
		//    char* SE13_COL_NAME_PPCIN="PPCI&N";
		//    char* SE13_COL_NAME_ANN="Abrev. Net. Name";
		//    char* SE13_COL_NAME_MCC="MCC";
		//    char* SE13_COL_NAME_MNC="MNC";
		//    char* SE13_COL_DELIMITER="|";
		//    char* SE13_SUBFIELD_DELIMITER=",";
		//    char* SE13_END_OF_LINE="\r\n";
		//    char* SQL_CREATE_TABLE="CREATE TABLE IF NOT EXISTS SE13Network (ppcin TEXT,  ann TEXT, mcc INT, mnc INT, PRIMARY KEY(mcc, mnc))";
		//    char* SQL_REPLACE="REPLACE INTO SE13Network (ppcin, ann, mcc, mnc) VALUES ( :ppcin, :ann, :mcc, :mnc)";
		//    char* SQL_SELECT_PPCIN="SELECT ppcin FROM SE13Network WHERE mcc = :mcc AND mnc = :mnc";
		//    char* SQL_SELECT_ANN="SELECT ann FROM SE13Network WHERE mcc = :mcc AND mnc = :mnc";
		//    char* SQL_SELECT_PPCIN_ANN="SELECT ppcin, ann FROM SE13Network WHERE mcc = :mcc AND mnc = :mnc";
		//    int SQL_SCHEMA_OBJ_NOT_FOUND=1007; //http://help.adobe.com/en_US/as3/dev/WS112915e91f27785047d2b8021256b9bb733-8000.html
		//    char* SQL_PARAM_PPCIN=":ppcin";
		//    char* SQL_PARAM_ANN=":ann";
		//    char* SQL_PARAM_MCC=":mcc";
		//    char* SQL_PARAM_MNC=":mnc";

		//   File __se13DbFile;
		//   SQLConnection __se13Db;
		//   SQLStatement __dbStatement;
		//   bool __ready; // indiates if the database was opened and intialized successfully
		
		/* 
		=========================
		PUBLIC methods
		========================= 
		*/
		
		/* Constructor
		*/
		void SE13NetworkTable::SE13NetworkTable() {
			__se13DbFile=File->applicationStorageDirectory->resolvePath(SE13_DB_FILENAME);
			__se13Db=new SQLConnection();
			__dbStatement=new SQLStatement();
			
			prepareDb();
		}
		
		/* Return the Full Network Name (PPCI&N) and the Abbreviated Network Name
			in the form of SE13NetworkName, given the MCC and MNC
		   Returns null if the MCC-MNC are not found in the table
		*/
		void SE13NetworkTable::getSE13NetworkName(int _mcc, int _mnc) {
			void networkName;
			
			if (__ready) 
			{
				try 
				{
					networkName=getPPCINAndANNFromMccMnc(_mcc);
				} catch(Error _error)
	{
						trace("SE13NetworkTable.getSE13NetworkName failed: ");
					}
			}
			
			return networkName;
		}
		
		/* Return the Full Network Name (PPCI&N), given the MCC and MNC
		*/
		void SE13NetworkTable::getFullNetworkName(int _mcc, int _mnc) {
			char* networkName;
			
			if (__ready) 
			{
				try 
				{
					networkName=getPpcinFromMccMnc(_mcc);
				} catch(Error _error)
	{
						trace("geltFullNetworkName failed: ");
					}
			}
			
			return networkName;
		}
		
		/* Return the Abbreviated Network Name, given the MCC and MNC
		*/
		void SE13NetworkTable::getAbbreviatedNetworkName(int _mcc, int _mnc) {
			
			char* networkName;
			
			if (__ready) 
			{
				try 
				{
					networkName=getAbrevNetNameFromMccMnc(_mcc);
				} catch(Error _error)
	{
						trace("getAbbreviatedNetworkName failed: ");
					}
			}
			
			return networkName;
		}
		
		/* 
		=========================
		PRIVATE methods
		========================= 
		*/
		
		/* Prepare database for access
		*/
		void SE13NetworkTable::prepareDb() void
		{
			try 
			{
				openAndInitializeDatabase();
				__ready=true;
			} 
			catch(SQLError _sqlError)
	{
					trace("prepareDb: sql error: ");
				} catch(Error _error)
	{
					trace("prepareDb: error: ");
				}
			
			if (!__ready) 
			{
				trace("prepareDb failure, closing db connection and deleting db file");
				// delete db so that we have a clean slate
				__se13Db->close();
				__se13DbFile->deleteFile();
			}
		}
		
		/* Open and initialize database.
		*/
		void SE13NetworkTable::openAndInitializeDatabase() void
		{
			trace("open a connection to db");
			__se13Db->open(__se13DbFile); // fyi: close() is called automatically during GC
			                             // __se13DbFile is created if it does not already exists
			
			__dbStatement->sqlConnection=__se13Db;
			
			try {
				// check if table exists in db
				__se13Db->loadSchema(SQLTableSchema);
			} 
			catch(SQLError _error)
	{
					if (_error->detailID == SQL_SCHEMA_OBJ_NOT_FOUND) 
					{
						trace("no table in db, start table creation process...");
						createAndPopulateSE13Table();
						trace("table creation completed");
					} 
					else 
					{
						trace("pass sql error up");
						throw _error;
					}
				}
		}
		
		/* Create and populate table
		*/
		void SE13NetworkTable::createAndPopulateSE13Table() {
			__dbStatement->clearParameters();
			__dbStatement->text=SQL_CREATE_TABLE;
			
			trace ("create db table");
			__dbStatement->execute();
			
			processSe13List();
			processOverrideList();
		}
		
		/* Executes the given _sql statement
		*/
		void SE13NetworkTable::manipulateSe13Table(char* _sql, char* _ppcin, char* _ann, int _mcc, int _mnc) {
			__dbStatement->clearParameters();
			
			__dbStatement->text=_sql;
			__dbStatement->parameters[SQL_PARAM_PPCIN]=_ppcin;
			__dbStatement->parameters[SQL_PARAM_ANN]=_ann;
			__dbStatement->parameters[SQL_PARAM_MCC]=_mcc;
			__dbStatement->parameters[SQL_PARAM_MNC]=_mnc;
			
			__dbStatement->execute();
		}
		
		/* Add given data to table. 
		*/
		void SE13NetworkTable::addToSe13Table(vector<void*> _array) {
			if (_array != NULL && _array->length>1) 
			{
				// first row should be column headers
				// get the indices of the headers that we want
				vector<void*> firstRowArray=_array[0]->toString()->split(SE13_COL_DELIMITER);
				int ppcinIndex=-1;
				int annIndex=-1;
				int mccIndex=-1;
				int mncIndex=-1;
				
				for (int i=0; i<firstRowArray->length; ++i) 
				{
					char* headerName=firstRowArray[i]->toString();
					switch (headerName) {
						case SE13_COL_NAME_PPCIN:
							ppcinIndex=i;
							break;
						case SE13_COL_NAME_ANN:
							annIndex=i;
							break;
						case SE13_COL_NAME_MCC:
							mccIndex=i;
							break;
						case SE13_COL_NAME_MNC:
							mncIndex=i;
							break;
						default:
							// ignore everything else
							break;
					}
				}
				
				if (ppcinIndex != -1 && annIndex != -1 && mccIndex != -1 && mncIndex != -1) 
				{
					trace("number of rows in array: ");
					
					vector<void*> rowArray;
					vector<void*> mncArray;
					char* ppcin;
					char* ann;
					char* mccString;
					char* mncString;
					int mcc;
					int mnc;
					
					__se13Db->begin();  // start transaction
					
					for (int j=1; j<_array->length; ++j) 
					{
						if (_array[j]->toString()->length>0) 
						{
							// split the row string into an array of strings, delimited by "|"
							rowArray=_array[j]->toString()->split(SE13_COL_DELIMITER);
							
							// find the desired data, based on its index within the array
							ppcin=StringUtil->trim(rowArray[ppcinIndex]->toString());
							ann=StringUtil->trim(rowArray[annIndex]->toString());
							mccString=rowArray[mccIndex];
							mncString=rowArray[mncIndex];
							mcc=parseInt(mccString);
							mnc=parseInt(mncString);

							if (!isNaN(mcc) && !isNaN(mnc)) {
								// The MNC field may have multiple MNCs separated by commas
								// parseInt in this case returns the first mnc
								if (mncString->indexOf(SE13_SUBFIELD_DELIMITER) == -1)
								{
									// single MNC case
									manipulateSe13Table(SQL_REPLACE);
								}
								else
								{
									// There is a comma in MNC, so has multiple MNCs 
									mncArray=mncString->split(SE13_SUBFIELD_DELIMITER);
									for (int k=0; k<mncArray->length; ++k)
									{
										mnc=parseInt(mncArray[k]);
										if (!isNaN(mnc))
										{
											manipulateSe13Table(SQL_REPLACE);
										}
									}
								}
							}
						}
					}
					
					__se13Db->commit();  // commit transaction
					
				} else {
					trace("Column headers were not found in list. Unable to continue.");
					trace("ppcinIndex: ");
					
					throw new Error("Expected column headers not found in list");
				}
			}
		}
		
		/* Get data from SE13 network list and add the data to the table
		*/
		void SE13NetworkTable::processSe13List() {
			char* list=new SE13NetworkList()->toString();
			vector<void*> array=list->split(SE13_END_OF_LINE);
			addToSe13Table(array);
		}
		
		/* Get data from override network list and add the data to the table
		*/
		void SE13NetworkTable::processOverrideList() {
			char* list=new SE13NetworkOverrideList()->toString();
			vector<void*> array=list->split(SE13_END_OF_LINE);
			addToSe13Table(array);
		}
		
		/* Return PPCI&N (full network name), given the MCC and MNC
		*/
		void SE13NetworkTable::getPpcinFromMccMnc(int _mcc, int _mnc) {
			char* ppcin;
			
			__dbStatement->clearParameters();
			__dbStatement->text=SQL_SELECT_PPCIN;
			__dbStatement->parameters[SQL_PARAM_MCC]=_mcc;
			__dbStatement->parameters[SQL_PARAM_MNC]=_mnc;
			__dbStatement->execute();
			
			void result=__dbStatement->getResult();
			if (result != NULL && result->data != NULL && result->data->length>0) 
			{
				ppcin=result->data[0]->ppcin;
			}
			
			trace("query ppcin for mcc[");
			return ppcin;
		}
		
		/* Return Abbreviate Network Name, given the MCC and MNC
		*/
		void SE13NetworkTable::getAbrevNetNameFromMccMnc(int _mcc, int _mnc) {
			char* ann;
			
			__dbStatement->clearParameters();
			__dbStatement->text=SQL_SELECT_ANN;
			__dbStatement->parameters[SQL_PARAM_MCC]=_mcc;
			__dbStatement->parameters[SQL_PARAM_MNC]=_mnc;
			__dbStatement->execute();
			
			void result=__dbStatement->getResult();
			if (result != NULL && result->data != NULL && result->data->length>0) 
			{
				ann=result->data[0]->ann;
			}
			
			trace("query ann for mcc[");
			return ann;
		}
		
		/* Return both PPCI&N (full network name) and the Abbreviated network name
			in the form of SE13NetworkName, given the MCC and MNC
		*/
		void SE13NetworkTable::getPPCINAndANNFromMccMnc(int _mcc, int _mnc) {
			char* ppcin;
			char* ann;
			
			__dbStatement->clearParameters();
			__dbStatement->text=SQL_SELECT_PPCIN_ANN;
			__dbStatement->parameters[SQL_PARAM_MCC]=_mcc;
			__dbStatement->parameters[SQL_PARAM_MNC]=_mnc;
			__dbStatement->execute();
			
			void result=__dbStatement->getResult();
			if (result != NULL && result->data != NULL && result->data->length>0) 
			{
				ppcin=result->data[0]->ppcin;
				ann=result->data[0]->ann;
				void se13NetworkName=new SE13NetworkName(ppcin);
				trace("SE13NetworkTable.getSE13NetworkNameFromMccMnc: query ppcin, ann for mcc[");
				return se13NetworkName;
			}
			// If the MCC-MNC cannot be found in the table return null
			return NULL;
			
		}
		
	}  // end of class
} // end of package
